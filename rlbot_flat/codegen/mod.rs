use eyre::{Context, anyhow};
use std::{
    fs,
    io::Write,
    path::{Path, PathBuf},
    time::Instant,
};

const SCHEMA_DIR: &str = "../flatbuffers-schema";
const OUT_FILE: &str = "./src/planus_flat.rs";

fn get_git_rev(dir: impl AsRef<Path>) -> Option<String> {
    let output = std::process::Command::new("git")
        .current_dir(dir)
        .args(&["rev-parse", "--short", "HEAD"])
        .output()
        .ok()?;

    Some(String::from_utf8(output.stdout).ok()?.trim().to_string())
}

pub fn main() -> eyre::Result<()> {
    let start_time = Instant::now();

    if !Path::new(SCHEMA_DIR).exists() {
        Err(anyhow!("Couldn't find flatbuffers schema folder"))?;
    }

    let cleaned_files = read_and_clean_schema_files(SCHEMA_DIR)?;

    let declarations = planus_translation::translate_files_from_memory_with_options(
        &cleaned_files,
        Default::default(),
    );

    let generated_planus = // No idea why planus renames RLBot to RlBot but this fixes it
        planus_codegen::generate_rust(&declarations)?.replace("RlBot", "RLBot");

    let now = Instant::now();
    let time_taken = format!(
        "// @generated by build.rs, took {:?}\n// built from schema {}\n",
        now.duration_since(start_time),
        get_git_rev(SCHEMA_DIR).unwrap_or_else(|| "UNKNOWN".into())
    );

    let raw_out = &[
        time_taken.as_bytes(),
        "////////// PLANUS GENERATED //////////\n".as_bytes(),
        generated_planus.as_bytes(),
    ]
    .concat();

    fs::File::create(OUT_FILE)?.write_all(raw_out)?;

    Ok(())
}

fn read_and_clean_schema_files(
    schema_dir: impl AsRef<Path>,
) -> eyre::Result<Vec<(PathBuf, String)>> {
    let fbs_file_paths: Vec<_> = fs::read_dir(schema_dir)
        .context("failed to read schema dir")?
        .map(|x| x.unwrap().path())
        .filter(|x| x.is_file() && x.extension().map(|x| x.to_str()) == Some(Some("fbs")))
        .collect();

    let include_all_str: String = fbs_file_paths
        .iter()
        // File paths to names
        .map(|x| x.file_name().unwrap().to_str().unwrap().to_owned())
        // Include every file name
        .map(|x| format!("include \"{x}\";"))
        .collect();

    Ok(fbs_file_paths
        .into_iter()
        .map(|fbs_file_path| {
            let mut contents = fs::read_to_string(&fbs_file_path).expect("failed to read file");

            // planus doesn't support multiple root_types
            // removing them doesn't seem to do much
            contents = contents.replace("root_type", "// root_type");

            // comment all existing includes
            contents = contents.replace("include \"", "// include \"");

            // include all files (since we're removing root_types the root_types aren't auto-included)
            contents = include_all_str.clone() + &contents;

            (
                fbs_file_path
                    .strip_prefix(SCHEMA_DIR)
                    .expect("failed to strip SCHEMA_DIR prefix from file path")
                    .to_owned(),
                contents,
            )
        })
        .collect())
}
