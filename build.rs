use std::{
    error::Error,
    fs,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
};

const SCHEMA_FOLDER: &str = "./flatbuffers-schema";
const OUT_FOLDER: &str = "./src/flat_wrapper/generated";
const RENAMED_OBJECTS_FILE: &str = "./src/flat_wrapper/renamed_objects.rs";
const FLATC_BINARY: &str = if cfg!(windows) { "flatc.exe" } else { "flatc" };

fn generate_renamed_objects_rs(
    files: &Vec<PathBuf>,
    outfile_path: PathBuf,
) -> Result<(), Box<dyn Error>> {
    let mut renamed_objects = fs::File::create(outfile_path)?;
    write!(
        renamed_objects,
        "//generated by build.rs\npub use super::generated::rlbot::flat::{{"
    )?;

    let re = regex::Regex::new(r"pub (struct|enum) ([A-Za-z0-9]+)Object")?;
    let sec_re = regex::Regex::new(r"pub (struct|enum) ([A-Za-z0-9]+)")?;
    for file in files {
        let content = std::fs::read_to_string(file)?;

        if let Some(captures) = re.captures(&content) {
            // First regex, this file has a flatbuffers object api specific struct/enum
            let struct_name = captures.get(2).unwrap().as_str();

            write!(renamed_objects, "{struct_name}Object as {struct_name},")?;
        } else if let Some(captures) = sec_re.captures(&content) {
            // Second regex, this file *only* has a normal flatbuffers struct/enum
            let struct_name = captures.get(2).unwrap().as_str();

            write!(renamed_objects, "{struct_name},")?;
        } else {
            Err("couldn't find struct/enum in file")?;
        }
    }

    writeln!(renamed_objects, "}};")?;
    Ok(())
}

fn remove_non_exhaustive(files: &Vec<PathBuf>) -> Result<(), Box<dyn Error>> {
    for file in files {
        let content = std::fs::read_to_string(file)?;
        let clean = content.replace("#[non_exhaustive]\n", "");
        fs::write(file, clean)?;
    }
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("cargo:rerun-if-changed=flatbuffers-schema");

    if !Path::new(SCHEMA_FOLDER).exists() {
        Err("Couldn't find flatbuffers schema folder")?;
    }

    Command::new(format!("{SCHEMA_FOLDER}/{FLATC_BINARY}"))
        .args([
            "--rust",
            "--gen-object-api",
            "--gen-all",
            "--object-suffix",
            "Object",
            "--filename-suffix",
            "",
            "--rust-module-root-file",
            "-o",
            OUT_FOLDER,
            &format!("{SCHEMA_FOLDER}/rlbot.fbs"),
        ])
        .spawn()?
        .wait()?;

    // Read files in OUT_FOLDER recursively
    let mut files = Vec::new();
    for entry in std::fs::read_dir(OUT_FOLDER.to_owned() + "/rlbot/flat")? {
        let entry = entry?;
        if entry.file_type()?.is_file() {
            files.push(entry.path());
        }
    }

    // flatc can't generate object api types without suffix, so we need to
    // re-export the types with suffix as types without suffix
    generate_renamed_objects_rs(&files, PathBuf::from(RENAMED_OBJECTS_FILE))?;

    // flatc forces #[non_exhaustive] on everything, so we need to remove them
    // to be able to export the types
    remove_non_exhaustive(&files)?;

    Ok(())
}
