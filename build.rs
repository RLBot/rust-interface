use std::{
    env,
    error::Error,
    fs::{self, File},
    io::{Read, Seek, SeekFrom, Write},
    path::{Path, PathBuf},
    process::Command,
};

const SCHEMA_FOLDER: &str = "./flatbuffers-schema";
const OUT_FOLDER: &str = "./src/flat_wrapper/generated";
const RENAMED_OBJECTS_FILE: &str = "./src/flat_wrapper/renamed_objects.rs";
const FLATC_BINARY: &str = if cfg!(windows) { "flatc.exe" } else { "flatc" };

fn generate_renamed_objects_rs(
    files: &Vec<PathBuf>,
    outfile_path: PathBuf,
) -> Result<(), Box<dyn Error>> {
    let mut renamed_objects = fs::File::create(outfile_path)?;
    write!(
        renamed_objects,
        concat!(
            "// @generated by build.rs\n",
            "// this file re-exports the flatbuffer object-api types without the Object suffix\n",
            "pub use super::generated::rlbot::flat::*;"
        )
    )?;

    let re = regex::Regex::new(r"pub (struct|enum) ([A-Za-z0-9]+)Object")?;
    let sec_re = regex::Regex::new(r"pub (struct|enum) ([A-Za-z0-9]+)")?;

    let mut keywords_to_rename = vec![];

    for file in files {
        let content = fs::read_to_string(file)?;
        // let content = std::fs::read_to_string(file)?;

        if let Some(captures) = re.captures(&content) {
            // First regex, this file has a flatbuffers object api specific struct/enum
            let struct_name = captures.get(2).unwrap().as_str();

            // write!(renamed_objects, "{struct_name},")?;

            keywords_to_rename.push(struct_name.to_owned());

            // write!(renamed_objects, "{struct_name}Object as {struct_name},")?;
        } else if let Some(captures) = sec_re.captures(&content) {
            // Second regex, this file *only* has a normal flatbuffers struct/enum
            let struct_name = captures.get(2).unwrap().as_str();

            // don't do shit ig
            // write!(renamed_objects, "{struct_name},")?;
        } else {
            Err("couldn't find struct/enum in file")?;
        }
    }

    for file in files {
        let mut opened_file = File::options().read(true).write(true).open(file)?;
        let mut content = {
            let mut s = String::new();
            opened_file.read_to_string(&mut s)?;
            s
        };
        for keyword in keywords_to_rename.iter() {
            let keyword_occurances =
                regex::Regex::new(&r#"([A-Za-z]*)(KEYWORD)([A-Za-z]*)?"#.replace("KEYWORD", keyword))?;
            content = content
                .lines()
                .enumerate()
                .map(|(line_n, line)| {
                    keyword_occurances.replace_all(line, |caps: &regex::Captures| {
                        eprint!("CATCHME: {:?}:{} {} ", file.file_name().unwrap(), line_n + 1, &caps[0]);

                        let before_str = &line[0..caps.get(0).unwrap().start()];
                        let after_str = &line[caps.get(0).unwrap().end()..];
                        if before_str.ends_with("::")
                            || before_str.chars().filter(|x| *x == '"').count() % 2 == 1
                            || (after_str.starts_with("(") && !before_str.ends_with("struct "))
                        {
                            eprintln!("A");
                            // if we're in string or enum variant
                            caps[0].to_owned()
                        } else if &caps[1] == "" && &caps[3] == "Object" {
                            eprintln!("B");
                            caps[2].to_owned()
                        } else if caps[1].len() + caps[3].len() == 0 {
                            eprintln!("C");
                            caps[2].to_owned() + "F"
                        } else {
                            eprintln!("A");
                            // if we're in string or enum variant
                            caps[0].to_owned()
                        }
                    })
                })
                .collect::<Vec<_>>()
                .join("\n");
            opened_file.set_len(0)?;
            opened_file.rewind()?;
            opened_file.write_all(content.as_bytes())?;
        }
    }

    // writeln!(renamed_objects, "}};")?;
    Ok(())
}

fn remove_non_exhaustive(files: &Vec<PathBuf>) -> Result<(), Box<dyn Error>> {
    for file in files {
        let content = std::fs::read_to_string(file)?;
        let clean = content.replace("#[non_exhaustive]\n", "");
        fs::write(file, clean)?;
    }
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("cargo:rerun-if-changed=flatbuffers-schema");
    println!("cargo:rerun-if-changed=build.rs");

    if !Path::new(SCHEMA_FOLDER).exists() {
        Err("Couldn't find flatbuffers schema folder")?;
    }

    let _ = fs::remove_dir_all(OUT_FOLDER);

    Command::new(format!("{SCHEMA_FOLDER}/{FLATC_BINARY}"))
        .args([
            "--rust",
            "--gen-object-api",
            "--gen-all",
            "--rust-serialize",
            "--object-suffix",
            "Object",
            "--filename-suffix",
            "",
            "--rust-module-root-file",
            "-o",
            OUT_FOLDER,
            &format!("{SCHEMA_FOLDER}/rlbot.fbs"),
        ])
        .spawn()?
        .wait()?;

    // Read files in OUT_FOLDER recursively
    let mut files = Vec::new();
    for entry in std::fs::read_dir(OUT_FOLDER.to_owned() + "/rlbot/flat")? {
        let entry = entry?;
        if entry.file_type()?.is_file() {
            files.push(entry.path());
        }
    }

    // flatc can't generate object api types without suffix, so we need to
    // re-export the types with suffix as types without suffix
    generate_renamed_objects_rs(&files, PathBuf::from(RENAMED_OBJECTS_FILE))?;

    // flatc forces #[non_exhaustive] on everything, so we need to remove them
    // to be able to export the types
    remove_non_exhaustive(&files)?;

    Ok(())
}
