// build.rs took 529.204705ms of which planus took 528.831873ms
pub use root::*;

const _: () = ::planus::check_version_compatibility("planus-1.0.0");

/// The root namespace
///
/// Generated from these locations:
/// * File `rlbot/flatbuffers-schema/comms.fbs`
#[no_implicit_prelude]
#[allow(dead_code)]
mod root {
    /// The namespace `rlbot`
    ///
    /// Generated from these locations:
    /// * File `rlbot/flatbuffers-schema/comms.fbs`
    pub mod rlbot {
        /// The namespace `rlbot.flat`
        ///
        /// Generated from these locations:
        /// * File `rlbot/flatbuffers-schema/comms.fbs`
        /// * File `rlbot/flatbuffers-schema/gamestate.fbs`
        /// * File `rlbot/flatbuffers-schema/matchstart.fbs`
        /// * File `rlbot/flatbuffers-schema/rlbot.fbs`
        /// * File `rlbot/flatbuffers-schema/rendering.fbs`
        pub mod flat {
            /// The table `MatchComm` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `MatchComm` in the file `rlbot/flatbuffers-schema/comms.fbs:3`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct MatchComm {
                ///  The index of the player that sent this
                pub index: u32,
                ///  The team of the player that sent this
                pub team: u32,
                ///  True if the chat is team only false if everyone can see it
                pub team_only: bool,
                ///  The message that will be displayed on the screen
                pub display: ::core::option::Option<::planus::alloc::string::String>,
                ///  The contents of the message
                pub content: ::planus::alloc::vec::Vec<u8>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for MatchComm {
                fn default() -> Self {
                    Self {
                        index: 0,
                        team: 0,
                        team_only: false,
                        display: ::core::default::Default::default(),
                        content: ::core::default::Default::default(),
                    }
                }
            }

            impl MatchComm {
                /// Creates a [MatchCommBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> MatchCommBuilder<()> {
                    MatchCommBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_team: impl ::planus::WriteAsDefault<u32, u32>,
                    field_team_only: impl ::planus::WriteAsDefault<bool, bool>,
                    field_display: impl ::planus::WriteAsOptional<
                        ::planus::Offset<::core::primitive::str>,
                    >,
                    field_content: impl ::planus::WriteAs<::planus::Offset<[u8]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_index = field_index.prepare(builder, &0);
                    let prepared_team = field_team.prepare(builder, &0);
                    let prepared_team_only = field_team_only.prepare(builder, &false);
                    let prepared_display = field_display.prepare(builder);
                    let prepared_content = field_content.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_team.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_display.is_some() {
                        table_writer.write_entry::<::planus::Offset<str>>(3);
                    }
                    table_writer.write_entry::<::planus::Offset<[u8]>>(4);
                    if prepared_team_only.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_index) = prepared_index {
                                object_writer.write::<_, _, 4>(&prepared_index);
                            }
                            if let ::core::option::Option::Some(prepared_team) = prepared_team {
                                object_writer.write::<_, _, 4>(&prepared_team);
                            }
                            if let ::core::option::Option::Some(prepared_display) = prepared_display
                            {
                                object_writer.write::<_, _, 4>(&prepared_display);
                            }
                            object_writer.write::<_, _, 4>(&prepared_content);
                            if let ::core::option::Option::Some(prepared_team_only) =
                                prepared_team_only
                            {
                                object_writer.write::<_, _, 1>(&prepared_team_only);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<MatchComm>> for MatchComm {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MatchComm> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<MatchComm>> for MatchComm {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MatchComm>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<MatchComm> for MatchComm {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MatchComm> {
                    MatchComm::create(
                        builder,
                        self.index,
                        self.team,
                        self.team_only,
                        &self.display,
                        &self.content,
                    )
                }
            }

            /// Builder for serializing an instance of the [MatchComm] type.
            ///
            /// Can be created using the [MatchComm::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct MatchCommBuilder<State>(State);

            impl MatchCommBuilder<()> {
                /// Setter for the [`index` field](MatchComm#structfield.index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index<T0>(self, value: T0) -> MatchCommBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    MatchCommBuilder((value,))
                }

                /// Sets the [`index` field](MatchComm#structfield.index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index_as_default(self) -> MatchCommBuilder<(::planus::DefaultValue,)> {
                    self.index(::planus::DefaultValue)
                }
            }

            impl<T0> MatchCommBuilder<(T0,)> {
                /// Setter for the [`team` field](MatchComm#structfield.team).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team<T1>(self, value: T1) -> MatchCommBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    MatchCommBuilder((v0, value))
                }

                /// Sets the [`team` field](MatchComm#structfield.team) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_as_default(self) -> MatchCommBuilder<(T0, ::planus::DefaultValue)> {
                    self.team(::planus::DefaultValue)
                }
            }

            impl<T0, T1> MatchCommBuilder<(T0, T1)> {
                /// Setter for the [`team_only` field](MatchComm#structfield.team_only).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_only<T2>(self, value: T2) -> MatchCommBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    MatchCommBuilder((v0, v1, value))
                }

                /// Sets the [`team_only` field](MatchComm#structfield.team_only) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_only_as_default(
                    self,
                ) -> MatchCommBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.team_only(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> MatchCommBuilder<(T0, T1, T2)> {
                /// Setter for the [`display` field](MatchComm#structfield.display).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn display<T3>(self, value: T3) -> MatchCommBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                {
                    let (v0, v1, v2) = self.0;
                    MatchCommBuilder((v0, v1, v2, value))
                }

                /// Sets the [`display` field](MatchComm#structfield.display) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn display_as_null(self) -> MatchCommBuilder<(T0, T1, T2, ())> {
                    self.display(())
                }
            }

            impl<T0, T1, T2, T3> MatchCommBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`content` field](MatchComm#structfield.content).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn content<T4>(self, value: T4) -> MatchCommBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<[u8]>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    MatchCommBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> MatchCommBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [MatchComm].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<MatchComm>
                where
                    Self: ::planus::WriteAsOffset<MatchComm>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAs<::planus::Offset<MatchComm>>
                for MatchCommBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<MatchComm>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MatchComm> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOptional<::planus::Offset<MatchComm>>
                for MatchCommBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<MatchComm>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MatchComm>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<::core::primitive::str>>,
                    T4: ::planus::WriteAs<::planus::Offset<[u8]>>,
                > ::planus::WriteAsOffset<MatchComm> for MatchCommBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<MatchComm> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    MatchComm::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [MatchComm].
            #[derive(Copy, Clone)]
            pub struct MatchCommRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MatchCommRef<'a> {
                /// Getter for the [`index` field](MatchComm#structfield.index).
                #[inline]
                pub fn index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "MatchComm", "index")?.unwrap_or(0))
                }

                /// Getter for the [`team` field](MatchComm#structfield.team).
                #[inline]
                pub fn team(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(1, "MatchComm", "team")?.unwrap_or(0))
                }

                /// Getter for the [`team_only` field](MatchComm#structfield.team_only).
                #[inline]
                pub fn team_only(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "MatchComm", "team_only")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`display` field](MatchComm#structfield.display).
                #[inline]
                pub fn display(
                    &self,
                ) -> ::planus::Result<::core::option::Option<&'a ::core::primitive::str>>
                {
                    self.0.access(3, "MatchComm", "display")
                }

                /// Getter for the [`content` field](MatchComm#structfield.content).
                #[inline]
                pub fn content(&self) -> ::planus::Result<&'a [u8]> {
                    self.0.access_required(4, "MatchComm", "content")
                }
            }

            impl<'a> ::core::fmt::Debug for MatchCommRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MatchCommRef");
                    f.field("index", &self.index());
                    f.field("team", &self.team());
                    f.field("team_only", &self.team_only());
                    if let ::core::option::Option::Some(field_display) = self.display().transpose()
                    {
                        f.field("display", &field_display);
                    }
                    f.field("content", &self.content());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MatchCommRef<'a>> for MatchComm {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MatchCommRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        index: ::core::convert::TryInto::try_into(value.index()?)?,
                        team: ::core::convert::TryInto::try_into(value.team()?)?,
                        team_only: ::core::convert::TryInto::try_into(value.team_only()?)?,
                        display: value.display()?.map(::core::convert::Into::into),
                        content: value.content()?.to_vec(),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MatchCommRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MatchCommRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MatchCommRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<MatchComm>> for MatchComm {
                type Value = ::planus::Offset<MatchComm>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<MatchComm>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MatchCommRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[MatchCommRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `Float` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Float` in the file `rlbot/flatbuffers-schema/gamestate.fbs:5`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Float {
                /// The field `val` in the struct `Float`
                pub val: f32,
            }

            impl ::planus::Primitive for Float {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 4;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Float> for Float {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.val.write(cur, buffer_position - 0);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Float> for Float {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Float> {
                    unsafe {
                        builder.write_with(4, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 4]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Float> for Float {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Float> for Float {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Float].
            #[derive(Copy, Clone)]
            pub struct FloatRef<'a>(::planus::ArrayWithStartOffset<'a, 4>);

            impl<'a> FloatRef<'a> {
                /// Getter for the [`val` field](Float#structfield.val).
                pub fn val(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for FloatRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FloatRef");
                    f.field("val", &self.val());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 4>> for FloatRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 4>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<FloatRef<'a>> for Float {
                #[allow(unreachable_code)]
                fn from(value: FloatRef<'a>) -> Self {
                    Self { val: value.val() }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<FloatRef<'a>> for FloatRef<'b> {
                fn eq(&self, other: &FloatRef<'_>) -> bool {
                    self.val() == other.val()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<FloatRef<'a>> for FloatRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &FloatRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    self.val().partial_cmp(&other.val())
                }
            }

            impl<'a> ::planus::TableRead<'a> for FloatRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<4>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for FloatRef<'a> {
                const STRIDE: usize = 4;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Float> for Float {
                const STRIDE: usize = 4;

                type Value = Float;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Float],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (4 * i) as u32,
                        );
                    }
                }
            }

            /// The struct `Bool` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Bool` in the file `rlbot/flatbuffers-schema/gamestate.fbs:9`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Bool {
                /// The field `val` in the struct `Bool`
                pub val: bool,
            }

            impl ::planus::Primitive for Bool {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Bool> for Bool {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<1, 0>();
                    self.val.write(cur, buffer_position - 0);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Bool> for Bool {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Bool> {
                    unsafe {
                        builder.write_with(1, 1, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 1]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Bool> for Bool {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Bool> for Bool {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Bool].
            #[derive(Copy, Clone)]
            pub struct BoolRef<'a>(::planus::ArrayWithStartOffset<'a, 1>);

            impl<'a> BoolRef<'a> {
                /// Getter for the [`val` field](Bool#structfield.val).
                pub fn val(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(0).unwrap();

                    buffer.as_array()[0] != 0
                }
            }

            impl<'a> ::core::fmt::Debug for BoolRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BoolRef");
                    f.field("val", &self.val());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 1>> for BoolRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 1>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<BoolRef<'a>> for Bool {
                #[allow(unreachable_code)]
                fn from(value: BoolRef<'a>) -> Self {
                    Self { val: value.val() }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<BoolRef<'a>> for BoolRef<'b> {
                fn eq(&self, other: &BoolRef<'_>) -> bool {
                    self.val() == other.val()
                }
            }

            impl<'a> ::core::cmp::Eq for BoolRef<'a> {}
            impl<'a, 'b> ::core::cmp::PartialOrd<BoolRef<'a>> for BoolRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &BoolRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::option::Option::Some(::core::cmp::Ord::cmp(self, other))
                }
            }

            impl<'a> ::core::cmp::Ord for BoolRef<'a> {
                fn cmp(&self, other: &BoolRef<'_>) -> ::core::cmp::Ordering {
                    self.val().cmp(&other.val())
                }
            }

            impl<'a> ::core::hash::Hash for BoolRef<'a> {
                fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
                    self.val().hash(state);
                }
            }

            impl<'a> ::planus::TableRead<'a> for BoolRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<1>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for BoolRef<'a> {
                const STRIDE: usize = 1;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Bool> for Bool {
                const STRIDE: usize = 1;

                type Value = Bool;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Bool],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `Vector3Partial` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `Vector3Partial` in the file `rlbot/flatbuffers-schema/gamestate.fbs:14`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Vector3Partial {
                /// The field `x` in the table `Vector3Partial`
                pub x: ::core::option::Option<self::Float>,
                /// The field `y` in the table `Vector3Partial`
                pub y: ::core::option::Option<self::Float>,
                /// The field `z` in the table `Vector3Partial`
                pub z: ::core::option::Option<self::Float>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Vector3Partial {
                fn default() -> Self {
                    Self {
                        x: ::core::default::Default::default(),
                        y: ::core::default::Default::default(),
                        z: ::core::default::Default::default(),
                    }
                }
            }

            impl Vector3Partial {
                /// Creates a [Vector3PartialBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Vector3PartialBuilder<()> {
                    Vector3PartialBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_x: impl ::planus::WriteAsOptional<self::Float>,
                    field_y: impl ::planus::WriteAsOptional<self::Float>,
                    field_z: impl ::planus::WriteAsOptional<self::Float>,
                ) -> ::planus::Offset<Self> {
                    let prepared_x = field_x.prepare(builder);
                    let prepared_y = field_y.prepare(builder);
                    let prepared_z = field_z.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    if prepared_x.is_some() {
                        table_writer.write_entry::<self::Float>(0);
                    }
                    if prepared_y.is_some() {
                        table_writer.write_entry::<self::Float>(1);
                    }
                    if prepared_z.is_some() {
                        table_writer.write_entry::<self::Float>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_x) = prepared_x {
                                object_writer.write::<_, _, 4>(&prepared_x);
                            }
                            if let ::core::option::Option::Some(prepared_y) = prepared_y {
                                object_writer.write::<_, _, 4>(&prepared_y);
                            }
                            if let ::core::option::Option::Some(prepared_z) = prepared_z {
                                object_writer.write::<_, _, 4>(&prepared_z);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Vector3Partial>> for Vector3Partial {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Vector3Partial> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Vector3Partial>> for Vector3Partial {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Vector3Partial>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Vector3Partial> for Vector3Partial {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Vector3Partial> {
                    Vector3Partial::create(builder, self.x, self.y, self.z)
                }
            }

            /// Builder for serializing an instance of the [Vector3Partial] type.
            ///
            /// Can be created using the [Vector3Partial::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Vector3PartialBuilder<State>(State);

            impl Vector3PartialBuilder<()> {
                /// Setter for the [`x` field](Vector3Partial#structfield.x).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x<T0>(self, value: T0) -> Vector3PartialBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<self::Float>,
                {
                    Vector3PartialBuilder((value,))
                }

                /// Sets the [`x` field](Vector3Partial#structfield.x) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x_as_null(self) -> Vector3PartialBuilder<((),)> {
                    self.x(())
                }
            }

            impl<T0> Vector3PartialBuilder<(T0,)> {
                /// Setter for the [`y` field](Vector3Partial#structfield.y).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y<T1>(self, value: T1) -> Vector3PartialBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0,) = self.0;
                    Vector3PartialBuilder((v0, value))
                }

                /// Sets the [`y` field](Vector3Partial#structfield.y) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y_as_null(self) -> Vector3PartialBuilder<(T0, ())> {
                    self.y(())
                }
            }

            impl<T0, T1> Vector3PartialBuilder<(T0, T1)> {
                /// Setter for the [`z` field](Vector3Partial#structfield.z).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn z<T2>(self, value: T2) -> Vector3PartialBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0, v1) = self.0;
                    Vector3PartialBuilder((v0, v1, value))
                }

                /// Sets the [`z` field](Vector3Partial#structfield.z) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn z_as_null(self) -> Vector3PartialBuilder<(T0, T1, ())> {
                    self.z(())
                }
            }

            impl<T0, T1, T2> Vector3PartialBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Vector3Partial].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Vector3Partial>
                where
                    Self: ::planus::WriteAsOffset<Vector3Partial>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAs<::planus::Offset<Vector3Partial>>
                for Vector3PartialBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Vector3Partial>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Vector3Partial> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOptional<::planus::Offset<Vector3Partial>>
                for Vector3PartialBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Vector3Partial>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Vector3Partial>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOffset<Vector3Partial> for Vector3PartialBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<Vector3Partial> {
                    let (v0, v1, v2) = &self.0;
                    Vector3Partial::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [Vector3Partial].
            #[derive(Copy, Clone)]
            pub struct Vector3PartialRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Vector3PartialRef<'a> {
                /// Getter for the [`x` field](Vector3Partial#structfield.x).
                #[inline]
                pub fn x(&self) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(0, "Vector3Partial", "x")
                }

                /// Getter for the [`y` field](Vector3Partial#structfield.y).
                #[inline]
                pub fn y(&self) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(1, "Vector3Partial", "y")
                }

                /// Getter for the [`z` field](Vector3Partial#structfield.z).
                #[inline]
                pub fn z(&self) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(2, "Vector3Partial", "z")
                }
            }

            impl<'a> ::core::fmt::Debug for Vector3PartialRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Vector3PartialRef");
                    if let ::core::option::Option::Some(field_x) = self.x().transpose() {
                        f.field("x", &field_x);
                    }
                    if let ::core::option::Option::Some(field_y) = self.y().transpose() {
                        f.field("y", &field_y);
                    }
                    if let ::core::option::Option::Some(field_z) = self.z().transpose() {
                        f.field("z", &field_z);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Vector3PartialRef<'a>> for Vector3Partial {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Vector3PartialRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        x: value.x()?.map(::core::convert::Into::into),
                        y: value.y()?.map(::core::convert::Into::into),
                        z: value.z()?.map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Vector3PartialRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Vector3PartialRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Vector3PartialRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Vector3Partial>> for Vector3Partial {
                type Value = ::planus::Offset<Vector3Partial>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Vector3Partial>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Vector3PartialRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Vector3PartialRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RotatorPartial` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `RotatorPartial` in the file `rlbot/flatbuffers-schema/gamestate.fbs:21`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RotatorPartial {
                /// The field `pitch` in the table `RotatorPartial`
                pub pitch: ::core::option::Option<self::Float>,
                /// The field `yaw` in the table `RotatorPartial`
                pub yaw: ::core::option::Option<self::Float>,
                /// The field `roll` in the table `RotatorPartial`
                pub roll: ::core::option::Option<self::Float>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RotatorPartial {
                fn default() -> Self {
                    Self {
                        pitch: ::core::default::Default::default(),
                        yaw: ::core::default::Default::default(),
                        roll: ::core::default::Default::default(),
                    }
                }
            }

            impl RotatorPartial {
                /// Creates a [RotatorPartialBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RotatorPartialBuilder<()> {
                    RotatorPartialBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_pitch: impl ::planus::WriteAsOptional<self::Float>,
                    field_yaw: impl ::planus::WriteAsOptional<self::Float>,
                    field_roll: impl ::planus::WriteAsOptional<self::Float>,
                ) -> ::planus::Offset<Self> {
                    let prepared_pitch = field_pitch.prepare(builder);
                    let prepared_yaw = field_yaw.prepare(builder);
                    let prepared_roll = field_roll.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    if prepared_pitch.is_some() {
                        table_writer.write_entry::<self::Float>(0);
                    }
                    if prepared_yaw.is_some() {
                        table_writer.write_entry::<self::Float>(1);
                    }
                    if prepared_roll.is_some() {
                        table_writer.write_entry::<self::Float>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_pitch) = prepared_pitch {
                                object_writer.write::<_, _, 4>(&prepared_pitch);
                            }
                            if let ::core::option::Option::Some(prepared_yaw) = prepared_yaw {
                                object_writer.write::<_, _, 4>(&prepared_yaw);
                            }
                            if let ::core::option::Option::Some(prepared_roll) = prepared_roll {
                                object_writer.write::<_, _, 4>(&prepared_roll);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RotatorPartial>> for RotatorPartial {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RotatorPartial> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RotatorPartial>> for RotatorPartial {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RotatorPartial>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RotatorPartial> for RotatorPartial {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RotatorPartial> {
                    RotatorPartial::create(builder, self.pitch, self.yaw, self.roll)
                }
            }

            /// Builder for serializing an instance of the [RotatorPartial] type.
            ///
            /// Can be created using the [RotatorPartial::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RotatorPartialBuilder<State>(State);

            impl RotatorPartialBuilder<()> {
                /// Setter for the [`pitch` field](RotatorPartial#structfield.pitch).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pitch<T0>(self, value: T0) -> RotatorPartialBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<self::Float>,
                {
                    RotatorPartialBuilder((value,))
                }

                /// Sets the [`pitch` field](RotatorPartial#structfield.pitch) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn pitch_as_null(self) -> RotatorPartialBuilder<((),)> {
                    self.pitch(())
                }
            }

            impl<T0> RotatorPartialBuilder<(T0,)> {
                /// Setter for the [`yaw` field](RotatorPartial#structfield.yaw).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn yaw<T1>(self, value: T1) -> RotatorPartialBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0,) = self.0;
                    RotatorPartialBuilder((v0, value))
                }

                /// Sets the [`yaw` field](RotatorPartial#structfield.yaw) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn yaw_as_null(self) -> RotatorPartialBuilder<(T0, ())> {
                    self.yaw(())
                }
            }

            impl<T0, T1> RotatorPartialBuilder<(T0, T1)> {
                /// Setter for the [`roll` field](RotatorPartial#structfield.roll).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn roll<T2>(self, value: T2) -> RotatorPartialBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0, v1) = self.0;
                    RotatorPartialBuilder((v0, v1, value))
                }

                /// Sets the [`roll` field](RotatorPartial#structfield.roll) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn roll_as_null(self) -> RotatorPartialBuilder<(T0, T1, ())> {
                    self.roll(())
                }
            }

            impl<T0, T1, T2> RotatorPartialBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RotatorPartial].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RotatorPartial>
                where
                    Self: ::planus::WriteAsOffset<RotatorPartial>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAs<::planus::Offset<RotatorPartial>>
                for RotatorPartialBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RotatorPartial>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RotatorPartial> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOptional<::planus::Offset<RotatorPartial>>
                for RotatorPartialBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<RotatorPartial>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RotatorPartial>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOffset<RotatorPartial> for RotatorPartialBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RotatorPartial> {
                    let (v0, v1, v2) = &self.0;
                    RotatorPartial::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [RotatorPartial].
            #[derive(Copy, Clone)]
            pub struct RotatorPartialRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RotatorPartialRef<'a> {
                /// Getter for the [`pitch` field](RotatorPartial#structfield.pitch).
                #[inline]
                pub fn pitch(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(0, "RotatorPartial", "pitch")
                }

                /// Getter for the [`yaw` field](RotatorPartial#structfield.yaw).
                #[inline]
                pub fn yaw(&self) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(1, "RotatorPartial", "yaw")
                }

                /// Getter for the [`roll` field](RotatorPartial#structfield.roll).
                #[inline]
                pub fn roll(&self) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(2, "RotatorPartial", "roll")
                }
            }

            impl<'a> ::core::fmt::Debug for RotatorPartialRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RotatorPartialRef");
                    if let ::core::option::Option::Some(field_pitch) = self.pitch().transpose() {
                        f.field("pitch", &field_pitch);
                    }
                    if let ::core::option::Option::Some(field_yaw) = self.yaw().transpose() {
                        f.field("yaw", &field_yaw);
                    }
                    if let ::core::option::Option::Some(field_roll) = self.roll().transpose() {
                        f.field("roll", &field_roll);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RotatorPartialRef<'a>> for RotatorPartial {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RotatorPartialRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        pitch: value.pitch()?.map(::core::convert::Into::into),
                        yaw: value.yaw()?.map(::core::convert::Into::into),
                        roll: value.roll()?.map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RotatorPartialRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RotatorPartialRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RotatorPartialRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RotatorPartial>> for RotatorPartial {
                type Value = ::planus::Offset<RotatorPartial>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RotatorPartial>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RotatorPartialRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RotatorPartialRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredPhysics` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredPhysics` in the file `rlbot/flatbuffers-schema/gamestate.fbs:27`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredPhysics {
                /// The field `location` in the table `DesiredPhysics`
                pub location:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::Vector3Partial>>,
                /// The field `rotation` in the table `DesiredPhysics`
                pub rotation:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::RotatorPartial>>,
                /// The field `velocity` in the table `DesiredPhysics`
                pub velocity:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::Vector3Partial>>,
                /// The field `angular_velocity` in the table `DesiredPhysics`
                pub angular_velocity:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::Vector3Partial>>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredPhysics {
                fn default() -> Self {
                    Self {
                        location: ::core::default::Default::default(),
                        rotation: ::core::default::Default::default(),
                        velocity: ::core::default::Default::default(),
                        angular_velocity: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredPhysics {
                /// Creates a [DesiredPhysicsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredPhysicsBuilder<()> {
                    DesiredPhysicsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_location: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::Vector3Partial>,
                    >,
                    field_rotation: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::RotatorPartial>,
                    >,
                    field_velocity: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::Vector3Partial>,
                    >,
                    field_angular_velocity: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::Vector3Partial>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_location = field_location.prepare(builder);
                    let prepared_rotation = field_rotation.prepare(builder);
                    let prepared_velocity = field_velocity.prepare(builder);
                    let prepared_angular_velocity = field_angular_velocity.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_location.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Vector3Partial>>(0);
                    }
                    if prepared_rotation.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::RotatorPartial>>(1);
                    }
                    if prepared_velocity.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Vector3Partial>>(2);
                    }
                    if prepared_angular_velocity.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Vector3Partial>>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_location) =
                                prepared_location
                            {
                                object_writer.write::<_, _, 4>(&prepared_location);
                            }
                            if let ::core::option::Option::Some(prepared_rotation) =
                                prepared_rotation
                            {
                                object_writer.write::<_, _, 4>(&prepared_rotation);
                            }
                            if let ::core::option::Option::Some(prepared_velocity) =
                                prepared_velocity
                            {
                                object_writer.write::<_, _, 4>(&prepared_velocity);
                            }
                            if let ::core::option::Option::Some(prepared_angular_velocity) =
                                prepared_angular_velocity
                            {
                                object_writer.write::<_, _, 4>(&prepared_angular_velocity);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredPhysics>> for DesiredPhysics {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredPhysics> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredPhysics>> for DesiredPhysics {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredPhysics>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredPhysics> for DesiredPhysics {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredPhysics> {
                    DesiredPhysics::create(
                        builder,
                        &self.location,
                        &self.rotation,
                        &self.velocity,
                        &self.angular_velocity,
                    )
                }
            }

            /// Builder for serializing an instance of the [DesiredPhysics] type.
            ///
            /// Can be created using the [DesiredPhysics::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredPhysicsBuilder<State>(State);

            impl DesiredPhysicsBuilder<()> {
                /// Setter for the [`location` field](DesiredPhysics#structfield.location).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location<T0>(self, value: T0) -> DesiredPhysicsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                {
                    DesiredPhysicsBuilder((value,))
                }

                /// Sets the [`location` field](DesiredPhysics#structfield.location) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location_as_null(self) -> DesiredPhysicsBuilder<((),)> {
                    self.location(())
                }
            }

            impl<T0> DesiredPhysicsBuilder<(T0,)> {
                /// Setter for the [`rotation` field](DesiredPhysics#structfield.rotation).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rotation<T1>(self, value: T1) -> DesiredPhysicsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<::planus::Offset<self::RotatorPartial>>,
                {
                    let (v0,) = self.0;
                    DesiredPhysicsBuilder((v0, value))
                }

                /// Sets the [`rotation` field](DesiredPhysics#structfield.rotation) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rotation_as_null(self) -> DesiredPhysicsBuilder<(T0, ())> {
                    self.rotation(())
                }
            }

            impl<T0, T1> DesiredPhysicsBuilder<(T0, T1)> {
                /// Setter for the [`velocity` field](DesiredPhysics#structfield.velocity).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn velocity<T2>(self, value: T2) -> DesiredPhysicsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                {
                    let (v0, v1) = self.0;
                    DesiredPhysicsBuilder((v0, v1, value))
                }

                /// Sets the [`velocity` field](DesiredPhysics#structfield.velocity) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn velocity_as_null(self) -> DesiredPhysicsBuilder<(T0, T1, ())> {
                    self.velocity(())
                }
            }

            impl<T0, T1, T2> DesiredPhysicsBuilder<(T0, T1, T2)> {
                /// Setter for the [`angular_velocity` field](DesiredPhysics#structfield.angular_velocity).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn angular_velocity<T3>(
                    self,
                    value: T3,
                ) -> DesiredPhysicsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                {
                    let (v0, v1, v2) = self.0;
                    DesiredPhysicsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`angular_velocity` field](DesiredPhysics#structfield.angular_velocity) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn angular_velocity_as_null(self) -> DesiredPhysicsBuilder<(T0, T1, T2, ())> {
                    self.angular_velocity(())
                }
            }

            impl<T0, T1, T2, T3> DesiredPhysicsBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredPhysics].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredPhysics>
                where
                    Self: ::planus::WriteAsOffset<DesiredPhysics>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<self::RotatorPartial>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                > ::planus::WriteAs<::planus::Offset<DesiredPhysics>>
                for DesiredPhysicsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DesiredPhysics>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredPhysics> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<self::RotatorPartial>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                > ::planus::WriteAsOptional<::planus::Offset<DesiredPhysics>>
                for DesiredPhysicsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DesiredPhysics>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredPhysics>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T1: ::planus::WriteAsOptional<::planus::Offset<self::RotatorPartial>>,
                    T2: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::Vector3Partial>>,
                > ::planus::WriteAsOffset<DesiredPhysics>
                for DesiredPhysicsBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredPhysics> {
                    let (v0, v1, v2, v3) = &self.0;
                    DesiredPhysics::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [DesiredPhysics].
            #[derive(Copy, Clone)]
            pub struct DesiredPhysicsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredPhysicsRef<'a> {
                /// Getter for the [`location` field](DesiredPhysics#structfield.location).
                #[inline]
                pub fn location(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::Vector3PartialRef<'a>>>
                {
                    self.0.access(0, "DesiredPhysics", "location")
                }

                /// Getter for the [`rotation` field](DesiredPhysics#structfield.rotation).
                #[inline]
                pub fn rotation(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::RotatorPartialRef<'a>>>
                {
                    self.0.access(1, "DesiredPhysics", "rotation")
                }

                /// Getter for the [`velocity` field](DesiredPhysics#structfield.velocity).
                #[inline]
                pub fn velocity(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::Vector3PartialRef<'a>>>
                {
                    self.0.access(2, "DesiredPhysics", "velocity")
                }

                /// Getter for the [`angular_velocity` field](DesiredPhysics#structfield.angular_velocity).
                #[inline]
                pub fn angular_velocity(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::Vector3PartialRef<'a>>>
                {
                    self.0.access(3, "DesiredPhysics", "angular_velocity")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredPhysicsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredPhysicsRef");
                    if let ::core::option::Option::Some(field_location) =
                        self.location().transpose()
                    {
                        f.field("location", &field_location);
                    }
                    if let ::core::option::Option::Some(field_rotation) =
                        self.rotation().transpose()
                    {
                        f.field("rotation", &field_rotation);
                    }
                    if let ::core::option::Option::Some(field_velocity) =
                        self.velocity().transpose()
                    {
                        f.field("velocity", &field_velocity);
                    }
                    if let ::core::option::Option::Some(field_angular_velocity) =
                        self.angular_velocity().transpose()
                    {
                        f.field("angular_velocity", &field_angular_velocity);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredPhysicsRef<'a>> for DesiredPhysics {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredPhysicsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        location: if let ::core::option::Option::Some(location) =
                            value.location()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(location)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        rotation: if let ::core::option::Option::Some(rotation) =
                            value.rotation()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(rotation)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        velocity: if let ::core::option::Option::Some(velocity) =
                            value.velocity()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(velocity)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        angular_velocity: if let ::core::option::Option::Some(angular_velocity) =
                            value.angular_velocity()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(angular_velocity)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredPhysicsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredPhysicsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredPhysicsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredPhysics>> for DesiredPhysics {
                type Value = ::planus::Offset<DesiredPhysics>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredPhysics>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredPhysicsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DesiredPhysicsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredBallState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredBallState` in the file `rlbot/flatbuffers-schema/gamestate.fbs:34`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredBallState {
                /// The field `physics` in the table `DesiredBallState`
                pub physics: ::planus::alloc::boxed::Box<self::DesiredPhysics>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredBallState {
                fn default() -> Self {
                    Self {
                        physics: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredBallState {
                /// Creates a [DesiredBallStateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredBallStateBuilder<()> {
                    DesiredBallStateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_physics: impl ::planus::WriteAs<::planus::Offset<self::DesiredPhysics>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_physics = field_physics.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::DesiredPhysics>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_physics);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredBallState>> for DesiredBallState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBallState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredBallState>> for DesiredBallState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredBallState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredBallState> for DesiredBallState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBallState> {
                    DesiredBallState::create(builder, &self.physics)
                }
            }

            /// Builder for serializing an instance of the [DesiredBallState] type.
            ///
            /// Can be created using the [DesiredBallState::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredBallStateBuilder<State>(State);

            impl DesiredBallStateBuilder<()> {
                /// Setter for the [`physics` field](DesiredBallState#structfield.physics).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn physics<T0>(self, value: T0) -> DesiredBallStateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::DesiredPhysics>>,
                {
                    DesiredBallStateBuilder((value,))
                }
            }

            impl<T0> DesiredBallStateBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredBallState].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBallState>
                where
                    Self: ::planus::WriteAsOffset<DesiredBallState>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DesiredPhysics>>>
                ::planus::WriteAs<::planus::Offset<DesiredBallState>>
                for DesiredBallStateBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DesiredBallState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBallState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DesiredPhysics>>>
                ::planus::WriteAsOptional<::planus::Offset<DesiredBallState>>
                for DesiredBallStateBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DesiredBallState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredBallState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<self::DesiredPhysics>>>
                ::planus::WriteAsOffset<DesiredBallState> for DesiredBallStateBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBallState> {
                    let (v0,) = &self.0;
                    DesiredBallState::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DesiredBallState].
            #[derive(Copy, Clone)]
            pub struct DesiredBallStateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredBallStateRef<'a> {
                /// Getter for the [`physics` field](DesiredBallState#structfield.physics).
                #[inline]
                pub fn physics(&self) -> ::planus::Result<self::DesiredPhysicsRef<'a>> {
                    self.0.access_required(0, "DesiredBallState", "physics")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredBallStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredBallStateRef");
                    f.field("physics", &self.physics());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredBallStateRef<'a>> for DesiredBallState {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredBallStateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        physics: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.physics()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredBallStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredBallStateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredBallStateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredBallState>> for DesiredBallState {
                type Value = ::planus::Offset<DesiredBallState>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredBallState>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredBallStateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DesiredBallStateRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredCarState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredCarState` in the file `rlbot/flatbuffers-schema/gamestate.fbs:38`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredCarState {
                /// The field `physics` in the table `DesiredCarState`
                pub physics:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::DesiredPhysics>>,
                /// The field `boost_amount` in the table `DesiredCarState`
                pub boost_amount: ::core::option::Option<self::Float>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredCarState {
                fn default() -> Self {
                    Self {
                        physics: ::core::default::Default::default(),
                        boost_amount: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredCarState {
                /// Creates a [DesiredCarStateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredCarStateBuilder<()> {
                    DesiredCarStateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_physics: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::DesiredPhysics>,
                    >,
                    field_boost_amount: impl ::planus::WriteAsOptional<self::Float>,
                ) -> ::planus::Offset<Self> {
                    let prepared_physics = field_physics.prepare(builder);
                    let prepared_boost_amount = field_boost_amount.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_physics.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::DesiredPhysics>>(0);
                    }
                    if prepared_boost_amount.is_some() {
                        table_writer.write_entry::<self::Float>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_physics) = prepared_physics
                            {
                                object_writer.write::<_, _, 4>(&prepared_physics);
                            }
                            if let ::core::option::Option::Some(prepared_boost_amount) =
                                prepared_boost_amount
                            {
                                object_writer.write::<_, _, 4>(&prepared_boost_amount);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredCarState>> for DesiredCarState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredCarState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredCarState>> for DesiredCarState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredCarState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredCarState> for DesiredCarState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredCarState> {
                    DesiredCarState::create(builder, &self.physics, self.boost_amount)
                }
            }

            /// Builder for serializing an instance of the [DesiredCarState] type.
            ///
            /// Can be created using the [DesiredCarState::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredCarStateBuilder<State>(State);

            impl DesiredCarStateBuilder<()> {
                /// Setter for the [`physics` field](DesiredCarState#structfield.physics).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn physics<T0>(self, value: T0) -> DesiredCarStateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::DesiredPhysics>>,
                {
                    DesiredCarStateBuilder((value,))
                }

                /// Sets the [`physics` field](DesiredCarState#structfield.physics) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn physics_as_null(self) -> DesiredCarStateBuilder<((),)> {
                    self.physics(())
                }
            }

            impl<T0> DesiredCarStateBuilder<(T0,)> {
                /// Setter for the [`boost_amount` field](DesiredCarState#structfield.boost_amount).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_amount<T1>(self, value: T1) -> DesiredCarStateBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0,) = self.0;
                    DesiredCarStateBuilder((v0, value))
                }

                /// Sets the [`boost_amount` field](DesiredCarState#structfield.boost_amount) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_amount_as_null(self) -> DesiredCarStateBuilder<(T0, ())> {
                    self.boost_amount(())
                }
            }

            impl<T0, T1> DesiredCarStateBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredCarState].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredCarState>
                where
                    Self: ::planus::WriteAsOffset<DesiredCarState>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::DesiredPhysics>>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAs<::planus::Offset<DesiredCarState>>
                for DesiredCarStateBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DesiredCarState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredCarState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::DesiredPhysics>>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOptional<::planus::Offset<DesiredCarState>>
                for DesiredCarStateBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<DesiredCarState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredCarState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<::planus::Offset<self::DesiredPhysics>>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                > ::planus::WriteAsOffset<DesiredCarState> for DesiredCarStateBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredCarState> {
                    let (v0, v1) = &self.0;
                    DesiredCarState::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [DesiredCarState].
            #[derive(Copy, Clone)]
            pub struct DesiredCarStateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredCarStateRef<'a> {
                /// Getter for the [`physics` field](DesiredCarState#structfield.physics).
                #[inline]
                pub fn physics(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::DesiredPhysicsRef<'a>>>
                {
                    self.0.access(0, "DesiredCarState", "physics")
                }

                /// Getter for the [`boost_amount` field](DesiredCarState#structfield.boost_amount).
                #[inline]
                pub fn boost_amount(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(1, "DesiredCarState", "boost_amount")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredCarStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredCarStateRef");
                    if let ::core::option::Option::Some(field_physics) = self.physics().transpose()
                    {
                        f.field("physics", &field_physics);
                    }
                    if let ::core::option::Option::Some(field_boost_amount) =
                        self.boost_amount().transpose()
                    {
                        f.field("boost_amount", &field_boost_amount);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredCarStateRef<'a>> for DesiredCarState {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredCarStateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        physics: if let ::core::option::Option::Some(physics) = value.physics()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(physics)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        boost_amount: value.boost_amount()?.map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredCarStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredCarStateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredCarStateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredCarState>> for DesiredCarState {
                type Value = ::planus::Offset<DesiredCarState>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredCarState>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredCarStateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DesiredCarStateRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredBoostState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredBoostState` in the file `rlbot/flatbuffers-schema/gamestate.fbs:43`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredBoostState {
                /// The field `respawn_time` in the table `DesiredBoostState`
                pub respawn_time: ::core::option::Option<self::Float>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredBoostState {
                fn default() -> Self {
                    Self {
                        respawn_time: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredBoostState {
                /// Creates a [DesiredBoostStateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredBoostStateBuilder<()> {
                    DesiredBoostStateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_respawn_time: impl ::planus::WriteAsOptional<self::Float>,
                ) -> ::planus::Offset<Self> {
                    let prepared_respawn_time = field_respawn_time.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_respawn_time.is_some() {
                        table_writer.write_entry::<self::Float>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_respawn_time) =
                                prepared_respawn_time
                            {
                                object_writer.write::<_, _, 4>(&prepared_respawn_time);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredBoostState>> for DesiredBoostState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBoostState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredBoostState>> for DesiredBoostState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredBoostState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredBoostState> for DesiredBoostState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBoostState> {
                    DesiredBoostState::create(builder, self.respawn_time)
                }
            }

            /// Builder for serializing an instance of the [DesiredBoostState] type.
            ///
            /// Can be created using the [DesiredBoostState::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredBoostStateBuilder<State>(State);

            impl DesiredBoostStateBuilder<()> {
                /// Setter for the [`respawn_time` field](DesiredBoostState#structfield.respawn_time).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn respawn_time<T0>(self, value: T0) -> DesiredBoostStateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<self::Float>,
                {
                    DesiredBoostStateBuilder((value,))
                }

                /// Sets the [`respawn_time` field](DesiredBoostState#structfield.respawn_time) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn respawn_time_as_null(self) -> DesiredBoostStateBuilder<((),)> {
                    self.respawn_time(())
                }
            }

            impl<T0> DesiredBoostStateBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredBoostState].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBoostState>
                where
                    Self: ::planus::WriteAsOffset<DesiredBoostState>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<self::Float>>
                ::planus::WriteAs<::planus::Offset<DesiredBoostState>>
                for DesiredBoostStateBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DesiredBoostState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBoostState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsOptional<self::Float>>
                ::planus::WriteAsOptional<::planus::Offset<DesiredBoostState>>
                for DesiredBoostStateBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<DesiredBoostState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredBoostState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsOptional<self::Float>>
                ::planus::WriteAsOffset<DesiredBoostState> for DesiredBoostStateBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredBoostState> {
                    let (v0,) = &self.0;
                    DesiredBoostState::create(builder, v0)
                }
            }

            /// Reference to a deserialized [DesiredBoostState].
            #[derive(Copy, Clone)]
            pub struct DesiredBoostStateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredBoostStateRef<'a> {
                /// Getter for the [`respawn_time` field](DesiredBoostState#structfield.respawn_time).
                #[inline]
                pub fn respawn_time(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(0, "DesiredBoostState", "respawn_time")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredBoostStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredBoostStateRef");
                    if let ::core::option::Option::Some(field_respawn_time) =
                        self.respawn_time().transpose()
                    {
                        f.field("respawn_time", &field_respawn_time);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredBoostStateRef<'a>> for DesiredBoostState {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredBoostStateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        respawn_time: value.respawn_time()?.map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredBoostStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredBoostStateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredBoostStateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredBoostState>> for DesiredBoostState {
                type Value = ::planus::Offset<DesiredBoostState>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredBoostState>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredBoostStateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DesiredBoostStateRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredGameInfoState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredGameInfoState` in the file `rlbot/flatbuffers-schema/gamestate.fbs:47`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredGameInfoState {
                /// The field `world_gravity_z` in the table `DesiredGameInfoState`
                pub world_gravity_z: ::core::option::Option<self::Float>,
                /// The field `game_speed` in the table `DesiredGameInfoState`
                pub game_speed: ::core::option::Option<self::Float>,
                /// The field `paused` in the table `DesiredGameInfoState`
                pub paused: ::core::option::Option<self::Bool>,
                /// The field `end_match` in the table `DesiredGameInfoState`
                pub end_match: ::core::option::Option<self::Bool>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredGameInfoState {
                fn default() -> Self {
                    Self {
                        world_gravity_z: ::core::default::Default::default(),
                        game_speed: ::core::default::Default::default(),
                        paused: ::core::default::Default::default(),
                        end_match: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredGameInfoState {
                /// Creates a [DesiredGameInfoStateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredGameInfoStateBuilder<()> {
                    DesiredGameInfoStateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_world_gravity_z: impl ::planus::WriteAsOptional<self::Float>,
                    field_game_speed: impl ::planus::WriteAsOptional<self::Float>,
                    field_paused: impl ::planus::WriteAsOptional<self::Bool>,
                    field_end_match: impl ::planus::WriteAsOptional<self::Bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_world_gravity_z = field_world_gravity_z.prepare(builder);
                    let prepared_game_speed = field_game_speed.prepare(builder);
                    let prepared_paused = field_paused.prepare(builder);
                    let prepared_end_match = field_end_match.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_world_gravity_z.is_some() {
                        table_writer.write_entry::<self::Float>(0);
                    }
                    if prepared_game_speed.is_some() {
                        table_writer.write_entry::<self::Float>(1);
                    }
                    if prepared_paused.is_some() {
                        table_writer.write_entry::<self::Bool>(2);
                    }
                    if prepared_end_match.is_some() {
                        table_writer.write_entry::<self::Bool>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_world_gravity_z) =
                                prepared_world_gravity_z
                            {
                                object_writer.write::<_, _, 4>(&prepared_world_gravity_z);
                            }
                            if let ::core::option::Option::Some(prepared_game_speed) =
                                prepared_game_speed
                            {
                                object_writer.write::<_, _, 4>(&prepared_game_speed);
                            }
                            if let ::core::option::Option::Some(prepared_paused) = prepared_paused {
                                object_writer.write::<_, _, 1>(&prepared_paused);
                            }
                            if let ::core::option::Option::Some(prepared_end_match) =
                                prepared_end_match
                            {
                                object_writer.write::<_, _, 1>(&prepared_end_match);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredGameInfoState>> for DesiredGameInfoState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameInfoState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredGameInfoState>> for DesiredGameInfoState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredGameInfoState>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredGameInfoState> for DesiredGameInfoState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameInfoState> {
                    DesiredGameInfoState::create(
                        builder,
                        self.world_gravity_z,
                        self.game_speed,
                        self.paused,
                        self.end_match,
                    )
                }
            }

            /// Builder for serializing an instance of the [DesiredGameInfoState] type.
            ///
            /// Can be created using the [DesiredGameInfoState::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredGameInfoStateBuilder<State>(State);

            impl DesiredGameInfoStateBuilder<()> {
                /// Setter for the [`world_gravity_z` field](DesiredGameInfoState#structfield.world_gravity_z).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn world_gravity_z<T0>(self, value: T0) -> DesiredGameInfoStateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsOptional<self::Float>,
                {
                    DesiredGameInfoStateBuilder((value,))
                }

                /// Sets the [`world_gravity_z` field](DesiredGameInfoState#structfield.world_gravity_z) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn world_gravity_z_as_null(self) -> DesiredGameInfoStateBuilder<((),)> {
                    self.world_gravity_z(())
                }
            }

            impl<T0> DesiredGameInfoStateBuilder<(T0,)> {
                /// Setter for the [`game_speed` field](DesiredGameInfoState#structfield.game_speed).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed<T1>(self, value: T1) -> DesiredGameInfoStateBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptional<self::Float>,
                {
                    let (v0,) = self.0;
                    DesiredGameInfoStateBuilder((v0, value))
                }

                /// Sets the [`game_speed` field](DesiredGameInfoState#structfield.game_speed) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed_as_null(self) -> DesiredGameInfoStateBuilder<(T0, ())> {
                    self.game_speed(())
                }
            }

            impl<T0, T1> DesiredGameInfoStateBuilder<(T0, T1)> {
                /// Setter for the [`paused` field](DesiredGameInfoState#structfield.paused).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused<T2>(self, value: T2) -> DesiredGameInfoStateBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsOptional<self::Bool>,
                {
                    let (v0, v1) = self.0;
                    DesiredGameInfoStateBuilder((v0, v1, value))
                }

                /// Sets the [`paused` field](DesiredGameInfoState#structfield.paused) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paused_as_null(self) -> DesiredGameInfoStateBuilder<(T0, T1, ())> {
                    self.paused(())
                }
            }

            impl<T0, T1, T2> DesiredGameInfoStateBuilder<(T0, T1, T2)> {
                /// Setter for the [`end_match` field](DesiredGameInfoState#structfield.end_match).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn end_match<T3>(
                    self,
                    value: T3,
                ) -> DesiredGameInfoStateBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<self::Bool>,
                {
                    let (v0, v1, v2) = self.0;
                    DesiredGameInfoStateBuilder((v0, v1, v2, value))
                }

                /// Sets the [`end_match` field](DesiredGameInfoState#structfield.end_match) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn end_match_as_null(self) -> DesiredGameInfoStateBuilder<(T0, T1, T2, ())> {
                    self.end_match(())
                }
            }

            impl<T0, T1, T2, T3> DesiredGameInfoStateBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredGameInfoState].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameInfoState>
                where
                    Self: ::planus::WriteAsOffset<DesiredGameInfoState>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Bool>,
                    T3: ::planus::WriteAsOptional<self::Bool>,
                > ::planus::WriteAs<::planus::Offset<DesiredGameInfoState>>
                for DesiredGameInfoStateBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DesiredGameInfoState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameInfoState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Bool>,
                    T3: ::planus::WriteAsOptional<self::Bool>,
                > ::planus::WriteAsOptional<::planus::Offset<DesiredGameInfoState>>
                for DesiredGameInfoStateBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<DesiredGameInfoState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredGameInfoState>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsOptional<self::Float>,
                    T1: ::planus::WriteAsOptional<self::Float>,
                    T2: ::planus::WriteAsOptional<self::Bool>,
                    T3: ::planus::WriteAsOptional<self::Bool>,
                > ::planus::WriteAsOffset<DesiredGameInfoState>
                for DesiredGameInfoStateBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameInfoState> {
                    let (v0, v1, v2, v3) = &self.0;
                    DesiredGameInfoState::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [DesiredGameInfoState].
            #[derive(Copy, Clone)]
            pub struct DesiredGameInfoStateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredGameInfoStateRef<'a> {
                /// Getter for the [`world_gravity_z` field](DesiredGameInfoState#structfield.world_gravity_z).
                #[inline]
                pub fn world_gravity_z(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(0, "DesiredGameInfoState", "world_gravity_z")
                }

                /// Getter for the [`game_speed` field](DesiredGameInfoState#structfield.game_speed).
                #[inline]
                pub fn game_speed(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::FloatRef<'a>>> {
                    self.0.access(1, "DesiredGameInfoState", "game_speed")
                }

                /// Getter for the [`paused` field](DesiredGameInfoState#structfield.paused).
                #[inline]
                pub fn paused(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::BoolRef<'a>>> {
                    self.0.access(2, "DesiredGameInfoState", "paused")
                }

                /// Getter for the [`end_match` field](DesiredGameInfoState#structfield.end_match).
                #[inline]
                pub fn end_match(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::BoolRef<'a>>> {
                    self.0.access(3, "DesiredGameInfoState", "end_match")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredGameInfoStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredGameInfoStateRef");
                    if let ::core::option::Option::Some(field_world_gravity_z) =
                        self.world_gravity_z().transpose()
                    {
                        f.field("world_gravity_z", &field_world_gravity_z);
                    }
                    if let ::core::option::Option::Some(field_game_speed) =
                        self.game_speed().transpose()
                    {
                        f.field("game_speed", &field_game_speed);
                    }
                    if let ::core::option::Option::Some(field_paused) = self.paused().transpose() {
                        f.field("paused", &field_paused);
                    }
                    if let ::core::option::Option::Some(field_end_match) =
                        self.end_match().transpose()
                    {
                        f.field("end_match", &field_end_match);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredGameInfoStateRef<'a>> for DesiredGameInfoState {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredGameInfoStateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        world_gravity_z: value.world_gravity_z()?.map(::core::convert::Into::into),
                        game_speed: value.game_speed()?.map(::core::convert::Into::into),
                        paused: value.paused()?.map(::core::convert::Into::into),
                        end_match: value.end_match()?.map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredGameInfoStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredGameInfoStateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredGameInfoStateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredGameInfoState>> for DesiredGameInfoState {
                type Value = ::planus::Offset<DesiredGameInfoState>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredGameInfoState>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredGameInfoStateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredGameInfoStateRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            ///  A console command which we will try to execute inside Rocket League.
            ///  See https://wiki.rlbot.org/framework/console-commands/ for a list of known commands.
            ///
            /// Generated from these locations:
            /// * Table `ConsoleCommand` in the file `rlbot/flatbuffers-schema/gamestate.fbs:56`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConsoleCommand {
                /// The field `command` in the table `ConsoleCommand`
                pub command: ::planus::alloc::string::String,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConsoleCommand {
                fn default() -> Self {
                    Self {
                        command: ::core::default::Default::default(),
                    }
                }
            }

            impl ConsoleCommand {
                /// Creates a [ConsoleCommandBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConsoleCommandBuilder<()> {
                    ConsoleCommandBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_command: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_command = field_command.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_command);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConsoleCommand>> for ConsoleCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsoleCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConsoleCommand>> for ConsoleCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsoleCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConsoleCommand> for ConsoleCommand {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsoleCommand> {
                    ConsoleCommand::create(builder, &self.command)
                }
            }

            /// Builder for serializing an instance of the [ConsoleCommand] type.
            ///
            /// Can be created using the [ConsoleCommand::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConsoleCommandBuilder<State>(State);

            impl ConsoleCommandBuilder<()> {
                /// Setter for the [`command` field](ConsoleCommand#structfield.command).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn command<T0>(self, value: T0) -> ConsoleCommandBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ConsoleCommandBuilder((value,))
                }
            }

            impl<T0> ConsoleCommandBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConsoleCommand].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsoleCommand>
                where
                    Self: ::planus::WriteAsOffset<ConsoleCommand>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<ConsoleCommand>>
                for ConsoleCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConsoleCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsoleCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<ConsoleCommand>>
                for ConsoleCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<ConsoleCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConsoleCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOffset<ConsoleCommand> for ConsoleCommandBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConsoleCommand> {
                    let (v0,) = &self.0;
                    ConsoleCommand::create(builder, v0)
                }
            }

            /// Reference to a deserialized [ConsoleCommand].
            #[derive(Copy, Clone)]
            pub struct ConsoleCommandRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConsoleCommandRef<'a> {
                /// Getter for the [`command` field](ConsoleCommand#structfield.command).
                #[inline]
                pub fn command(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConsoleCommand", "command")
                }
            }

            impl<'a> ::core::fmt::Debug for ConsoleCommandRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConsoleCommandRef");
                    f.field("command", &self.command());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConsoleCommandRef<'a>> for ConsoleCommand {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConsoleCommandRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        command: ::core::convert::Into::into(value.command()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConsoleCommandRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConsoleCommandRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConsoleCommandRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConsoleCommand>> for ConsoleCommand {
                type Value = ::planus::Offset<ConsoleCommand>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConsoleCommand>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConsoleCommandRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConsoleCommandRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `DesiredGameState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `DesiredGameState` in the file `rlbot/flatbuffers-schema/gamestate.fbs:60`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct DesiredGameState {
                /// The field `ball_states` in the table `DesiredGameState`
                pub ball_states: ::planus::alloc::vec::Vec<self::DesiredBallState>,
                /// The field `car_states` in the table `DesiredGameState`
                pub car_states: ::planus::alloc::vec::Vec<self::DesiredCarState>,
                /// The field `boost_states` in the table `DesiredGameState`
                pub boost_states: ::planus::alloc::vec::Vec<self::DesiredBoostState>,
                /// The field `game_info_state` in the table `DesiredGameState`
                pub game_info_state:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::DesiredGameInfoState>>,
                /// The field `console_commands` in the table `DesiredGameState`
                pub console_commands: ::planus::alloc::vec::Vec<self::ConsoleCommand>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for DesiredGameState {
                fn default() -> Self {
                    Self {
                        ball_states: ::core::default::Default::default(),
                        car_states: ::core::default::Default::default(),
                        boost_states: ::core::default::Default::default(),
                        game_info_state: ::core::default::Default::default(),
                        console_commands: ::core::default::Default::default(),
                    }
                }
            }

            impl DesiredGameState {
                /// Creates a [DesiredGameStateBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> DesiredGameStateBuilder<()> {
                    DesiredGameStateBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_ball_states: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBallState>]>,
                    >,
                    field_car_states: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredCarState>]>,
                    >,
                    field_boost_states: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>,
                    >,
                    field_game_info_state: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::DesiredGameInfoState>,
                    >,
                    field_console_commands: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_ball_states = field_ball_states.prepare(builder);
                    let prepared_car_states = field_car_states.prepare(builder);
                    let prepared_boost_states = field_boost_states.prepare(builder);
                    let prepared_game_info_state = field_game_info_state.prepare(builder);
                    let prepared_console_commands = field_console_commands.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::DesiredBallState>]>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::DesiredCarState>]>>(
                            1,
                        );
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>>(2);
                    if prepared_game_info_state.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::DesiredGameInfoState>>(3);
                    }
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>>(
                            4,
                        );

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_ball_states);
                            object_writer.write::<_, _, 4>(&prepared_car_states);
                            object_writer.write::<_, _, 4>(&prepared_boost_states);
                            if let ::core::option::Option::Some(prepared_game_info_state) =
                                prepared_game_info_state
                            {
                                object_writer.write::<_, _, 4>(&prepared_game_info_state);
                            }
                            object_writer.write::<_, _, 4>(&prepared_console_commands);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<DesiredGameState>> for DesiredGameState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<DesiredGameState>> for DesiredGameState {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredGameState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<DesiredGameState> for DesiredGameState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameState> {
                    DesiredGameState::create(
                        builder,
                        &self.ball_states,
                        &self.car_states,
                        &self.boost_states,
                        &self.game_info_state,
                        &self.console_commands,
                    )
                }
            }

            /// Builder for serializing an instance of the [DesiredGameState] type.
            ///
            /// Can be created using the [DesiredGameState::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct DesiredGameStateBuilder<State>(State);

            impl DesiredGameStateBuilder<()> {
                /// Setter for the [`ball_states` field](DesiredGameState#structfield.ball_states).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_states<T0>(self, value: T0) -> DesiredGameStateBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBallState>]>,
                    >,
                {
                    DesiredGameStateBuilder((value,))
                }
            }

            impl<T0> DesiredGameStateBuilder<(T0,)> {
                /// Setter for the [`car_states` field](DesiredGameState#structfield.car_states).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn car_states<T1>(self, value: T1) -> DesiredGameStateBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredCarState>]>,
                    >,
                {
                    let (v0,) = self.0;
                    DesiredGameStateBuilder((v0, value))
                }
            }

            impl<T0, T1> DesiredGameStateBuilder<(T0, T1)> {
                /// Setter for the [`boost_states` field](DesiredGameState#structfield.boost_states).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_states<T2>(self, value: T2) -> DesiredGameStateBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>,
                    >,
                {
                    let (v0, v1) = self.0;
                    DesiredGameStateBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> DesiredGameStateBuilder<(T0, T1, T2)> {
                /// Setter for the [`game_info_state` field](DesiredGameState#structfield.game_info_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_info_state<T3>(
                    self,
                    value: T3,
                ) -> DesiredGameStateBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::DesiredGameInfoState>>,
                {
                    let (v0, v1, v2) = self.0;
                    DesiredGameStateBuilder((v0, v1, v2, value))
                }

                /// Sets the [`game_info_state` field](DesiredGameState#structfield.game_info_state) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_info_state_as_null(self) -> DesiredGameStateBuilder<(T0, T1, T2, ())> {
                    self.game_info_state(())
                }
            }

            impl<T0, T1, T2, T3> DesiredGameStateBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`console_commands` field](DesiredGameState#structfield.console_commands).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn console_commands<T4>(
                    self,
                    value: T4,
                ) -> DesiredGameStateBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    DesiredGameStateBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> DesiredGameStateBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [DesiredGameState].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameState>
                where
                    Self: ::planus::WriteAsOffset<DesiredGameState>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredBallState>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredCarState>]>>,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::DesiredGameInfoState>>,
                    T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>>,
                > ::planus::WriteAs<::planus::Offset<DesiredGameState>>
                for DesiredGameStateBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<DesiredGameState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameState> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredBallState>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredCarState>]>>,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::DesiredGameInfoState>>,
                    T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<DesiredGameState>>
                for DesiredGameStateBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<DesiredGameState>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<DesiredGameState>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredBallState>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::DesiredCarState>]>>,
                    T2: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::DesiredBoostState>]>,
                    >,
                    T3: ::planus::WriteAsOptional<::planus::Offset<self::DesiredGameInfoState>>,
                    T4: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ConsoleCommand>]>>,
                > ::planus::WriteAsOffset<DesiredGameState>
                for DesiredGameStateBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<DesiredGameState> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    DesiredGameState::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [DesiredGameState].
            #[derive(Copy, Clone)]
            pub struct DesiredGameStateRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> DesiredGameStateRef<'a> {
                /// Getter for the [`ball_states` field](DesiredGameState#structfield.ball_states).
                #[inline]
                pub fn ball_states(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::DesiredBallStateRef<'a>>>,
                > {
                    self.0.access_required(0, "DesiredGameState", "ball_states")
                }

                /// Getter for the [`car_states` field](DesiredGameState#structfield.car_states).
                #[inline]
                pub fn car_states(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::DesiredCarStateRef<'a>>>,
                > {
                    self.0.access_required(1, "DesiredGameState", "car_states")
                }

                /// Getter for the [`boost_states` field](DesiredGameState#structfield.boost_states).
                #[inline]
                pub fn boost_states(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::DesiredBoostStateRef<'a>>>,
                > {
                    self.0
                        .access_required(2, "DesiredGameState", "boost_states")
                }

                /// Getter for the [`game_info_state` field](DesiredGameState#structfield.game_info_state).
                #[inline]
                pub fn game_info_state(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::DesiredGameInfoStateRef<'a>>>
                {
                    self.0.access(3, "DesiredGameState", "game_info_state")
                }

                /// Getter for the [`console_commands` field](DesiredGameState#structfield.console_commands).
                #[inline]
                pub fn console_commands(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::ConsoleCommandRef<'a>>>,
                > {
                    self.0
                        .access_required(4, "DesiredGameState", "console_commands")
                }
            }

            impl<'a> ::core::fmt::Debug for DesiredGameStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("DesiredGameStateRef");
                    f.field("ball_states", &self.ball_states());
                    f.field("car_states", &self.car_states());
                    f.field("boost_states", &self.boost_states());
                    if let ::core::option::Option::Some(field_game_info_state) =
                        self.game_info_state().transpose()
                    {
                        f.field("game_info_state", &field_game_info_state);
                    }
                    f.field("console_commands", &self.console_commands());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<DesiredGameStateRef<'a>> for DesiredGameState {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: DesiredGameStateRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        ball_states: value.ball_states()?.to_vec_result()?,
                        car_states: value.car_states()?.to_vec_result()?,
                        boost_states: value.boost_states()?.to_vec_result()?,
                        game_info_state: if let ::core::option::Option::Some(game_info_state) =
                            value.game_info_state()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(game_info_state)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        console_commands: value.console_commands()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for DesiredGameStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for DesiredGameStateRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[DesiredGameStateRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<DesiredGameState>> for DesiredGameState {
                type Value = ::planus::Offset<DesiredGameState>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<DesiredGameState>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for DesiredGameStateRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[DesiredGameStateRef]", "read_as_root", 0)
                    })
                }
            }

            ///  A bot controlled by the RLBot framework
            ///
            /// Generated from these locations:
            /// * Table `RLBot` in the file `rlbot/flatbuffers-schema/matchstart.fbs:4`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RLBot {}

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RLBot {
                fn default() -> Self {
                    Self {}
                }
            }

            impl RLBot {
                /// Creates a [RLBotBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RLBotBuilder<()> {
                    RLBotBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                    let table_writer: ::planus::table_writer::TableWriter<4> =
                        ::core::default::Default::default();
                    unsafe {
                        table_writer.finish(builder, |_table_writer| {});
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RLBot>> for RLBot {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RLBot> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RLBot>> for RLBot {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RLBot>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RLBot> for RLBot {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RLBot> {
                    RLBot::create(builder)
                }
            }

            /// Builder for serializing an instance of the [RLBot] type.
            ///
            /// Can be created using the [RLBot::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RLBotBuilder<State>(State);

            impl RLBotBuilder<()> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RLBot].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<RLBot>
                where
                    Self: ::planus::WriteAsOffset<RLBot>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RLBot>> for RLBotBuilder<()> {
                type Prepared = ::planus::Offset<RLBot>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RLBot> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RLBot>> for RLBotBuilder<()> {
                type Prepared = ::planus::Offset<RLBot>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RLBot>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RLBot> for RLBotBuilder<()> {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<RLBot> {
                    RLBot::create(builder)
                }
            }

            /// Reference to a deserialized [RLBot].
            #[derive(Copy, Clone)]
            pub struct RLBotRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RLBotRef<'a> {}

            impl<'a> ::core::fmt::Debug for RLBotRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RLBotRef");

                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RLBotRef<'a>> for RLBot {
                type Error = ::planus::Error;

                fn try_from(_value: RLBotRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {})
                }
            }

            impl<'a> ::planus::TableRead<'a> for RLBotRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RLBotRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RLBotRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RLBot>> for RLBot {
                type Value = ::planus::Offset<RLBot>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RLBot>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RLBotRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RLBotRef]", "read_as_root", 0)
                    })
                }
            }

            ///  A normal human player
            ///
            /// Generated from these locations:
            /// * Table `Human` in the file `rlbot/flatbuffers-schema/matchstart.fbs:7`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Human {}

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Human {
                fn default() -> Self {
                    Self {}
                }
            }

            impl Human {
                /// Creates a [HumanBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> HumanBuilder<()> {
                    HumanBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                    let table_writer: ::planus::table_writer::TableWriter<4> =
                        ::core::default::Default::default();
                    unsafe {
                        table_writer.finish(builder, |_table_writer| {});
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Human>> for Human {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Human> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Human>> for Human {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Human>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Human> for Human {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Human> {
                    Human::create(builder)
                }
            }

            /// Builder for serializing an instance of the [Human] type.
            ///
            /// Can be created using the [Human::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct HumanBuilder<State>(State);

            impl HumanBuilder<()> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Human].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Human>
                where
                    Self: ::planus::WriteAsOffset<Human>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Human>> for HumanBuilder<()> {
                type Prepared = ::planus::Offset<Human>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Human> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Human>> for HumanBuilder<()> {
                type Prepared = ::planus::Offset<Human>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Human>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Human> for HumanBuilder<()> {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Human> {
                    Human::create(builder)
                }
            }

            /// Reference to a deserialized [Human].
            #[derive(Copy, Clone)]
            pub struct HumanRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> HumanRef<'a> {}

            impl<'a> ::core::fmt::Debug for HumanRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("HumanRef");

                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<HumanRef<'a>> for Human {
                type Error = ::planus::Error;

                fn try_from(_value: HumanRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {})
                }
            }

            impl<'a> ::planus::TableRead<'a> for HumanRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for HumanRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[HumanRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Human>> for Human {
                type Value = ::planus::Offset<Human>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Human>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for HumanRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[HumanRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `PsyonixSkill` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `PsyonixSkill` in the file `rlbot/flatbuffers-schema/matchstart.fbs:9`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum PsyonixSkill {
                /// The variant `Beginner` in the enum `PsyonixSkill`
                Beginner = 0,

                /// The variant `Rookie` in the enum `PsyonixSkill`
                Rookie = 1,

                /// The variant `Pro` in the enum `PsyonixSkill`
                Pro = 2,

                /// The variant `AllStar` in the enum `PsyonixSkill`
                AllStar = 3,
            }

            impl PsyonixSkill {
                /// Array containing all valid variants of PsyonixSkill
                pub const ENUM_VALUES: [Self; 4] =
                    [Self::Beginner, Self::Rookie, Self::Pro, Self::AllStar];
            }

            impl ::core::convert::TryFrom<u8> for PsyonixSkill {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(PsyonixSkill::Beginner),
                        1 => ::core::result::Result::Ok(PsyonixSkill::Rookie),
                        2 => ::core::result::Result::Ok(PsyonixSkill::Pro),
                        3 => ::core::result::Result::Ok(PsyonixSkill::AllStar),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<PsyonixSkill> for u8 {
                #[inline]
                fn from(value: PsyonixSkill) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for PsyonixSkill {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<PsyonixSkill> for PsyonixSkill {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<PsyonixSkill> for PsyonixSkill {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> PsyonixSkill {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<PsyonixSkill, PsyonixSkill> for PsyonixSkill {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &PsyonixSkill,
                ) -> ::core::option::Option<PsyonixSkill> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<PsyonixSkill> for PsyonixSkill {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<PsyonixSkill> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for PsyonixSkill {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for PsyonixSkill {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "PsyonixSkill",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<PsyonixSkill> for PsyonixSkill {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            ///  A psyonix bot, e.g. All Star bot
            ///
            /// Generated from these locations:
            /// * Table `Psyonix` in the file `rlbot/flatbuffers-schema/matchstart.fbs:17`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Psyonix {
                /// The field `bot_skill` in the table `Psyonix`
                pub bot_skill: self::PsyonixSkill,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Psyonix {
                fn default() -> Self {
                    Self {
                        bot_skill: self::PsyonixSkill::Beginner,
                    }
                }
            }

            impl Psyonix {
                /// Creates a [PsyonixBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PsyonixBuilder<()> {
                    PsyonixBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_bot_skill: impl ::planus::WriteAsDefault<
                        self::PsyonixSkill,
                        self::PsyonixSkill,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_bot_skill =
                        field_bot_skill.prepare(builder, &self::PsyonixSkill::Beginner);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_bot_skill.is_some() {
                        table_writer.write_entry::<self::PsyonixSkill>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_bot_skill) =
                                prepared_bot_skill
                            {
                                object_writer.write::<_, _, 1>(&prepared_bot_skill);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Psyonix>> for Psyonix {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Psyonix> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Psyonix>> for Psyonix {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Psyonix>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Psyonix> for Psyonix {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Psyonix> {
                    Psyonix::create(builder, self.bot_skill)
                }
            }

            /// Builder for serializing an instance of the [Psyonix] type.
            ///
            /// Can be created using the [Psyonix::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PsyonixBuilder<State>(State);

            impl PsyonixBuilder<()> {
                /// Setter for the [`bot_skill` field](Psyonix#structfield.bot_skill).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bot_skill<T0>(self, value: T0) -> PsyonixBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::PsyonixSkill, self::PsyonixSkill>,
                {
                    PsyonixBuilder((value,))
                }

                /// Sets the [`bot_skill` field](Psyonix#structfield.bot_skill) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn bot_skill_as_default(self) -> PsyonixBuilder<(::planus::DefaultValue,)> {
                    self.bot_skill(::planus::DefaultValue)
                }
            }

            impl<T0> PsyonixBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Psyonix].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Psyonix>
                where
                    Self: ::planus::WriteAsOffset<Psyonix>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::PsyonixSkill, self::PsyonixSkill>>
                ::planus::WriteAs<::planus::Offset<Psyonix>> for PsyonixBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Psyonix>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Psyonix> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::PsyonixSkill, self::PsyonixSkill>>
                ::planus::WriteAsOptional<::planus::Offset<Psyonix>> for PsyonixBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<Psyonix>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Psyonix>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<self::PsyonixSkill, self::PsyonixSkill>>
                ::planus::WriteAsOffset<Psyonix> for PsyonixBuilder<(T0,)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Psyonix> {
                    let (v0,) = &self.0;
                    Psyonix::create(builder, v0)
                }
            }

            /// Reference to a deserialized [Psyonix].
            #[derive(Copy, Clone)]
            pub struct PsyonixRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PsyonixRef<'a> {
                /// Getter for the [`bot_skill` field](Psyonix#structfield.bot_skill).
                #[inline]
                pub fn bot_skill(&self) -> ::planus::Result<self::PsyonixSkill> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "Psyonix", "bot_skill")?
                            .unwrap_or(self::PsyonixSkill::Beginner),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PsyonixRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PsyonixRef");
                    f.field("bot_skill", &self.bot_skill());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PsyonixRef<'a>> for Psyonix {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PsyonixRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        bot_skill: ::core::convert::TryInto::try_into(value.bot_skill()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PsyonixRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PsyonixRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PsyonixRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Psyonix>> for Psyonix {
                type Value = ::planus::Offset<Psyonix>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Psyonix>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PsyonixRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PsyonixRef]", "read_as_root", 0)
                    })
                }
            }

            ///  A player that Rocket League treats as human, e.g. has a dedicated camera and can do training mode,
            ///  but is actually controlled by a bot.
            ///
            /// Generated from these locations:
            /// * Table `PartyMember` in the file `rlbot/flatbuffers-schema/matchstart.fbs:23`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PartyMember {}

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PartyMember {
                fn default() -> Self {
                    Self {}
                }
            }

            impl PartyMember {
                /// Creates a [PartyMemberBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PartyMemberBuilder<()> {
                    PartyMemberBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(builder: &mut ::planus::Builder) -> ::planus::Offset<Self> {
                    let table_writer: ::planus::table_writer::TableWriter<4> =
                        ::core::default::Default::default();
                    unsafe {
                        table_writer.finish(builder, |_table_writer| {});
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PartyMember>> for PartyMember {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PartyMember> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PartyMember>> for PartyMember {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PartyMember>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PartyMember> for PartyMember {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PartyMember> {
                    PartyMember::create(builder)
                }
            }

            /// Builder for serializing an instance of the [PartyMember] type.
            ///
            /// Can be created using the [PartyMember::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PartyMemberBuilder<State>(State);

            impl PartyMemberBuilder<()> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PartyMember].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PartyMember>
                where
                    Self: ::planus::WriteAsOffset<PartyMember>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PartyMember>> for PartyMemberBuilder<()> {
                type Prepared = ::planus::Offset<PartyMember>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PartyMember> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PartyMember>> for PartyMemberBuilder<()> {
                type Prepared = ::planus::Offset<PartyMember>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PartyMember>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PartyMember> for PartyMemberBuilder<()> {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PartyMember> {
                    PartyMember::create(builder)
                }
            }

            /// Reference to a deserialized [PartyMember].
            #[derive(Copy, Clone)]
            pub struct PartyMemberRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PartyMemberRef<'a> {}

            impl<'a> ::core::fmt::Debug for PartyMemberRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PartyMemberRef");

                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PartyMemberRef<'a>> for PartyMember {
                type Error = ::planus::Error;

                fn try_from(_value: PartyMemberRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {})
                }
            }

            impl<'a> ::planus::TableRead<'a> for PartyMemberRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PartyMemberRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PartyMemberRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PartyMember>> for PartyMember {
                type Value = ::planus::Offset<PartyMember>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PartyMember>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PartyMemberRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PartyMemberRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `PlayerClass` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Union `PlayerClass` in the file `rlbot/flatbuffers-schema/matchstart.fbs:25`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub enum PlayerClass {
                /// The variant of type `RLBot` in the union `PlayerClass`
                RLBot(::planus::alloc::boxed::Box<self::RLBot>),

                /// The variant of type `Human` in the union `PlayerClass`
                Human(::planus::alloc::boxed::Box<self::Human>),

                /// The variant of type `Psyonix` in the union `PlayerClass`
                Psyonix(::planus::alloc::boxed::Box<self::Psyonix>),

                /// The variant of type `PartyMember` in the union `PlayerClass`
                PartyMember(::planus::alloc::boxed::Box<self::PartyMember>),
            }

            impl PlayerClass {
                /// Creates a [PlayerClassBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlayerClassBuilder<::planus::Uninitialized> {
                    PlayerClassBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_rl_bot(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::RLBot>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_human(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Human>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_psyonix(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Psyonix>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_party_member(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PartyMember>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<PlayerClass> for PlayerClass {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::RLBot(value) => Self::create_rl_bot(builder, value),
                        Self::Human(value) => Self::create_human(builder, value),
                        Self::Psyonix(value) => Self::create_psyonix(builder, value),
                        Self::PartyMember(value) => Self::create_party_member(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<PlayerClass> for PlayerClass {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [PlayerClass] type.
            ///
            /// Can be created using the [PlayerClass::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlayerClassBuilder<T>(T);

            impl PlayerClassBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`RLBot` variant](PlayerClass#variant.RLBot).
                #[inline]
                pub fn rl_bot<T>(self, value: T) -> PlayerClassBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::RLBot>,
                {
                    PlayerClassBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Human` variant](PlayerClass#variant.Human).
                #[inline]
                pub fn human<T>(self, value: T) -> PlayerClassBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::Human>,
                {
                    PlayerClassBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Psyonix` variant](PlayerClass#variant.Psyonix).
                #[inline]
                pub fn psyonix<T>(self, value: T) -> PlayerClassBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::Psyonix>,
                {
                    PlayerClassBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PartyMember` variant](PlayerClass#variant.PartyMember).
                #[inline]
                pub fn party_member<T>(
                    self,
                    value: T,
                ) -> PlayerClassBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<self::PartyMember>,
                {
                    PlayerClassBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> PlayerClassBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [PlayerClass].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<PlayerClass>
                where
                    Self: ::planus::WriteAsUnion<PlayerClass>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<PlayerClass> for PlayerClassBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::RLBot>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<PlayerClass> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<PlayerClass>
                for PlayerClassBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::RLBot>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<PlayerClass>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<PlayerClass> for PlayerClassBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::Human>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<PlayerClass> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<PlayerClass>
                for PlayerClassBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::Human>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<PlayerClass>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<PlayerClass> for PlayerClassBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::Psyonix>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<PlayerClass> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<PlayerClass>
                for PlayerClassBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::Psyonix>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<PlayerClass>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<PlayerClass> for PlayerClassBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::PartyMember>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<PlayerClass> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<PlayerClass>
                for PlayerClassBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::PartyMember>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<PlayerClass>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [PlayerClass].
            #[derive(Copy, Clone, Debug)]
            pub enum PlayerClassRef<'a> {
                RLBot(self::RLBotRef<'a>),
                Human(self::HumanRef<'a>),
                Psyonix(self::PsyonixRef<'a>),
                PartyMember(self::PartyMemberRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<PlayerClassRef<'a>> for PlayerClass {
                type Error = ::planus::Error;

                fn try_from(value: PlayerClassRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        PlayerClassRef::RLBot(value) => {
                            Self::RLBot(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        PlayerClassRef::Human(value) => {
                            Self::Human(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        PlayerClassRef::Psyonix(value) => {
                            Self::Psyonix(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        PlayerClassRef::PartyMember(value) => {
                            Self::PartyMember(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for PlayerClassRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::RLBot(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::Human(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::Psyonix(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::PartyMember(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            ///  The car type, color, and other aspects of the player's appearance.
            ///  See https://wiki.rlbot.org/botmaking/bot-customization/
            ///
            /// Generated from these locations:
            /// * Table `PlayerLoadout` in the file `rlbot/flatbuffers-schema/matchstart.fbs:29`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PlayerLoadout {
                /// The field `team_color_id` in the table `PlayerLoadout`
                pub team_color_id: u32,
                /// The field `custom_color_id` in the table `PlayerLoadout`
                pub custom_color_id: u32,
                /// The field `car_id` in the table `PlayerLoadout`
                pub car_id: u32,
                /// The field `decal_id` in the table `PlayerLoadout`
                pub decal_id: u32,
                /// The field `wheels_id` in the table `PlayerLoadout`
                pub wheels_id: u32,
                /// The field `boost_id` in the table `PlayerLoadout`
                pub boost_id: u32,
                /// The field `antenna_id` in the table `PlayerLoadout`
                pub antenna_id: u32,
                /// The field `hat_id` in the table `PlayerLoadout`
                pub hat_id: u32,
                /// The field `paint_finish_id` in the table `PlayerLoadout`
                pub paint_finish_id: u32,
                /// The field `custom_finish_id` in the table `PlayerLoadout`
                pub custom_finish_id: u32,
                /// The field `engine_audio_id` in the table `PlayerLoadout`
                pub engine_audio_id: u32,
                /// The field `trails_id` in the table `PlayerLoadout`
                pub trails_id: u32,
                /// The field `goal_explosion_id` in the table `PlayerLoadout`
                pub goal_explosion_id: u32,
                /// The field `loadout_paint` in the table `PlayerLoadout`
                pub loadout_paint:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::LoadoutPaint>>,
                ///  Sets the primary color of the car to the swatch that most closely matches the provided
                ///  RGB color value. If set, this overrides teamColorId.
                pub primary_color_lookup: ::core::option::Option<self::Color>,
                ///  Sets the secondary color of the car to the swatch that most closely matches the provided
                ///  RGB color value. If set, this overrides customColorId.
                pub secondary_color_lookup: ::core::option::Option<self::Color>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PlayerLoadout {
                fn default() -> Self {
                    Self {
                        team_color_id: 0,
                        custom_color_id: 0,
                        car_id: 0,
                        decal_id: 0,
                        wheels_id: 0,
                        boost_id: 0,
                        antenna_id: 0,
                        hat_id: 0,
                        paint_finish_id: 0,
                        custom_finish_id: 0,
                        engine_audio_id: 0,
                        trails_id: 0,
                        goal_explosion_id: 0,
                        loadout_paint: ::core::default::Default::default(),
                        primary_color_lookup: ::core::default::Default::default(),
                        secondary_color_lookup: ::core::default::Default::default(),
                    }
                }
            }

            impl PlayerLoadout {
                /// Creates a [PlayerLoadoutBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlayerLoadoutBuilder<()> {
                    PlayerLoadoutBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_team_color_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_custom_color_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_car_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_decal_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_wheels_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_boost_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_antenna_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_hat_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_paint_finish_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_custom_finish_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_engine_audio_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_trails_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_goal_explosion_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_loadout_paint: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::LoadoutPaint>,
                    >,
                    field_primary_color_lookup: impl ::planus::WriteAsOptional<self::Color>,
                    field_secondary_color_lookup: impl ::planus::WriteAsOptional<self::Color>,
                ) -> ::planus::Offset<Self> {
                    let prepared_team_color_id = field_team_color_id.prepare(builder, &0);
                    let prepared_custom_color_id = field_custom_color_id.prepare(builder, &0);
                    let prepared_car_id = field_car_id.prepare(builder, &0);
                    let prepared_decal_id = field_decal_id.prepare(builder, &0);
                    let prepared_wheels_id = field_wheels_id.prepare(builder, &0);
                    let prepared_boost_id = field_boost_id.prepare(builder, &0);
                    let prepared_antenna_id = field_antenna_id.prepare(builder, &0);
                    let prepared_hat_id = field_hat_id.prepare(builder, &0);
                    let prepared_paint_finish_id = field_paint_finish_id.prepare(builder, &0);
                    let prepared_custom_finish_id = field_custom_finish_id.prepare(builder, &0);
                    let prepared_engine_audio_id = field_engine_audio_id.prepare(builder, &0);
                    let prepared_trails_id = field_trails_id.prepare(builder, &0);
                    let prepared_goal_explosion_id = field_goal_explosion_id.prepare(builder, &0);
                    let prepared_loadout_paint = field_loadout_paint.prepare(builder);
                    let prepared_primary_color_lookup = field_primary_color_lookup.prepare(builder);
                    let prepared_secondary_color_lookup =
                        field_secondary_color_lookup.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<36> =
                        ::core::default::Default::default();
                    if prepared_team_color_id.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_custom_color_id.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_car_id.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_decal_id.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    if prepared_wheels_id.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_boost_id.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_antenna_id.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_hat_id.is_some() {
                        table_writer.write_entry::<u32>(7);
                    }
                    if prepared_paint_finish_id.is_some() {
                        table_writer.write_entry::<u32>(8);
                    }
                    if prepared_custom_finish_id.is_some() {
                        table_writer.write_entry::<u32>(9);
                    }
                    if prepared_engine_audio_id.is_some() {
                        table_writer.write_entry::<u32>(10);
                    }
                    if prepared_trails_id.is_some() {
                        table_writer.write_entry::<u32>(11);
                    }
                    if prepared_goal_explosion_id.is_some() {
                        table_writer.write_entry::<u32>(12);
                    }
                    if prepared_loadout_paint.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::LoadoutPaint>>(13);
                    }
                    if prepared_primary_color_lookup.is_some() {
                        table_writer.write_entry::<self::Color>(14);
                    }
                    if prepared_secondary_color_lookup.is_some() {
                        table_writer.write_entry::<self::Color>(15);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_team_color_id) =
                                prepared_team_color_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_team_color_id);
                            }
                            if let ::core::option::Option::Some(prepared_custom_color_id) =
                                prepared_custom_color_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_custom_color_id);
                            }
                            if let ::core::option::Option::Some(prepared_car_id) = prepared_car_id {
                                object_writer.write::<_, _, 4>(&prepared_car_id);
                            }
                            if let ::core::option::Option::Some(prepared_decal_id) =
                                prepared_decal_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_decal_id);
                            }
                            if let ::core::option::Option::Some(prepared_wheels_id) =
                                prepared_wheels_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_wheels_id);
                            }
                            if let ::core::option::Option::Some(prepared_boost_id) =
                                prepared_boost_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_boost_id);
                            }
                            if let ::core::option::Option::Some(prepared_antenna_id) =
                                prepared_antenna_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_antenna_id);
                            }
                            if let ::core::option::Option::Some(prepared_hat_id) = prepared_hat_id {
                                object_writer.write::<_, _, 4>(&prepared_hat_id);
                            }
                            if let ::core::option::Option::Some(prepared_paint_finish_id) =
                                prepared_paint_finish_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_paint_finish_id);
                            }
                            if let ::core::option::Option::Some(prepared_custom_finish_id) =
                                prepared_custom_finish_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_custom_finish_id);
                            }
                            if let ::core::option::Option::Some(prepared_engine_audio_id) =
                                prepared_engine_audio_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_engine_audio_id);
                            }
                            if let ::core::option::Option::Some(prepared_trails_id) =
                                prepared_trails_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_trails_id);
                            }
                            if let ::core::option::Option::Some(prepared_goal_explosion_id) =
                                prepared_goal_explosion_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_goal_explosion_id);
                            }
                            if let ::core::option::Option::Some(prepared_loadout_paint) =
                                prepared_loadout_paint
                            {
                                object_writer.write::<_, _, 4>(&prepared_loadout_paint);
                            }
                            if let ::core::option::Option::Some(prepared_primary_color_lookup) =
                                prepared_primary_color_lookup
                            {
                                object_writer.write::<_, _, 4>(&prepared_primary_color_lookup);
                            }
                            if let ::core::option::Option::Some(prepared_secondary_color_lookup) =
                                prepared_secondary_color_lookup
                            {
                                object_writer.write::<_, _, 4>(&prepared_secondary_color_lookup);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlayerLoadout>> for PlayerLoadout {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerLoadout> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlayerLoadout>> for PlayerLoadout {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerLoadout>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlayerLoadout> for PlayerLoadout {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerLoadout> {
                    PlayerLoadout::create(
                        builder,
                        self.team_color_id,
                        self.custom_color_id,
                        self.car_id,
                        self.decal_id,
                        self.wheels_id,
                        self.boost_id,
                        self.antenna_id,
                        self.hat_id,
                        self.paint_finish_id,
                        self.custom_finish_id,
                        self.engine_audio_id,
                        self.trails_id,
                        self.goal_explosion_id,
                        &self.loadout_paint,
                        self.primary_color_lookup,
                        self.secondary_color_lookup,
                    )
                }
            }

            /// Builder for serializing an instance of the [PlayerLoadout] type.
            ///
            /// Can be created using the [PlayerLoadout::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlayerLoadoutBuilder<State>(State);

            impl PlayerLoadoutBuilder<()> {
                /// Setter for the [`team_color_id` field](PlayerLoadout#structfield.team_color_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_color_id<T0>(self, value: T0) -> PlayerLoadoutBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    PlayerLoadoutBuilder((value,))
                }

                /// Sets the [`team_color_id` field](PlayerLoadout#structfield.team_color_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_color_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(::planus::DefaultValue,)> {
                    self.team_color_id(::planus::DefaultValue)
                }
            }

            impl<T0> PlayerLoadoutBuilder<(T0,)> {
                /// Setter for the [`custom_color_id` field](PlayerLoadout#structfield.custom_color_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn custom_color_id<T1>(self, value: T1) -> PlayerLoadoutBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    PlayerLoadoutBuilder((v0, value))
                }

                /// Sets the [`custom_color_id` field](PlayerLoadout#structfield.custom_color_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn custom_color_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, ::planus::DefaultValue)> {
                    self.custom_color_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1> PlayerLoadoutBuilder<(T0, T1)> {
                /// Setter for the [`car_id` field](PlayerLoadout#structfield.car_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn car_id<T2>(self, value: T2) -> PlayerLoadoutBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    PlayerLoadoutBuilder((v0, v1, value))
                }

                /// Sets the [`car_id` field](PlayerLoadout#structfield.car_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn car_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.car_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> PlayerLoadoutBuilder<(T0, T1, T2)> {
                /// Setter for the [`decal_id` field](PlayerLoadout#structfield.decal_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn decal_id<T3>(self, value: T3) -> PlayerLoadoutBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, value))
                }

                /// Sets the [`decal_id` field](PlayerLoadout#structfield.decal_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn decal_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.decal_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> PlayerLoadoutBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`wheels_id` field](PlayerLoadout#structfield.wheels_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wheels_id<T4>(self, value: T4) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`wheels_id` field](PlayerLoadout#structfield.wheels_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wheels_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.wheels_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`boost_id` field](PlayerLoadout#structfield.boost_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_id<T5>(
                    self,
                    value: T5,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`boost_id` field](PlayerLoadout#structfield.boost_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.boost_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`antenna_id` field](PlayerLoadout#structfield.antenna_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn antenna_id<T6>(
                    self,
                    value: T6,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`antenna_id` field](PlayerLoadout#structfield.antenna_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn antenna_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.antenna_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`hat_id` field](PlayerLoadout#structfield.hat_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hat_id<T7>(
                    self,
                    value: T7,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`hat_id` field](PlayerLoadout#structfield.hat_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hat_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.hat_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`paint_finish_id` field](PlayerLoadout#structfield.paint_finish_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paint_finish_id<T8>(
                    self,
                    value: T8,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`paint_finish_id` field](PlayerLoadout#structfield.paint_finish_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn paint_finish_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.paint_finish_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Setter for the [`custom_finish_id` field](PlayerLoadout#structfield.custom_finish_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn custom_finish_id<T9>(
                    self,
                    value: T9,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`custom_finish_id` field](PlayerLoadout#structfield.custom_finish_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn custom_finish_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    ::planus::DefaultValue,
                )> {
                    self.custom_finish_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`engine_audio_id` field](PlayerLoadout#structfield.engine_audio_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn engine_audio_id<T10>(
                    self,
                    value: T10,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`engine_audio_id` field](PlayerLoadout#structfield.engine_audio_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn engine_audio_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.engine_audio_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`trails_id` field](PlayerLoadout#structfield.trails_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trails_id<T11>(
                    self,
                    value: T11,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`trails_id` field](PlayerLoadout#structfield.trails_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trails_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.trails_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`goal_explosion_id` field](PlayerLoadout#structfield.goal_explosion_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn goal_explosion_id<T12>(
                    self,
                    value: T12,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    PlayerLoadoutBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`goal_explosion_id` field](PlayerLoadout#structfield.goal_explosion_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn goal_explosion_id_as_default(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.goal_explosion_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`loadout_paint` field](PlayerLoadout#structfield.loadout_paint).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn loadout_paint<T13>(
                    self,
                    value: T13,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                )>
                where
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::LoadoutPaint>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    PlayerLoadoutBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value,
                    ))
                }

                /// Sets the [`loadout_paint` field](PlayerLoadout#structfield.loadout_paint) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn loadout_paint_as_null(
                    self,
                ) -> PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, ())>
                {
                    self.loadout_paint(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                PlayerLoadoutBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`primary_color_lookup` field](PlayerLoadout#structfield.primary_color_lookup).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn primary_color_lookup<T14>(
                    self,
                    value: T14,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsOptional<self::Color>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    PlayerLoadoutBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`primary_color_lookup` field](PlayerLoadout#structfield.primary_color_lookup) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn primary_color_lookup_as_null(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    (),
                )> {
                    self.primary_color_lookup(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`secondary_color_lookup` field](PlayerLoadout#structfield.secondary_color_lookup).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn secondary_color_lookup<T15>(
                    self,
                    value: T15,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsOptional<self::Color>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    PlayerLoadoutBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`secondary_color_lookup` field](PlayerLoadout#structfield.secondary_color_lookup) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn secondary_color_lookup_as_null(
                    self,
                ) -> PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    (),
                )> {
                    self.secondary_color_lookup(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlayerLoadout].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerLoadout>
                where
                    Self: ::planus::WriteAsOffset<PlayerLoadout>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u32, u32>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::LoadoutPaint>>,
                    T14: ::planus::WriteAsOptional<self::Color>,
                    T15: ::planus::WriteAsOptional<self::Color>,
                > ::planus::WriteAs<::planus::Offset<PlayerLoadout>>
                for PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<PlayerLoadout>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerLoadout> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u32, u32>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::LoadoutPaint>>,
                    T14: ::planus::WriteAsOptional<self::Color>,
                    T15: ::planus::WriteAsOptional<self::Color>,
                > ::planus::WriteAsOptional<::planus::Offset<PlayerLoadout>>
                for PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                type Prepared = ::planus::Offset<PlayerLoadout>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerLoadout>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                    T8: ::planus::WriteAsDefault<u32, u32>,
                    T9: ::planus::WriteAsDefault<u32, u32>,
                    T10: ::planus::WriteAsDefault<u32, u32>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsOptional<::planus::Offset<self::LoadoutPaint>>,
                    T14: ::planus::WriteAsOptional<self::Color>,
                    T15: ::planus::WriteAsOptional<self::Color>,
                > ::planus::WriteAsOffset<PlayerLoadout>
                for PlayerLoadoutBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerLoadout> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        &self.0;
                    PlayerLoadout::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15,
                    )
                }
            }

            /// Reference to a deserialized [PlayerLoadout].
            #[derive(Copy, Clone)]
            pub struct PlayerLoadoutRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlayerLoadoutRef<'a> {
                /// Getter for the [`team_color_id` field](PlayerLoadout#structfield.team_color_id).
                #[inline]
                pub fn team_color_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "PlayerLoadout", "team_color_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`custom_color_id` field](PlayerLoadout#structfield.custom_color_id).
                #[inline]
                pub fn custom_color_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "PlayerLoadout", "custom_color_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`car_id` field](PlayerLoadout#structfield.car_id).
                #[inline]
                pub fn car_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "PlayerLoadout", "car_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`decal_id` field](PlayerLoadout#structfield.decal_id).
                #[inline]
                pub fn decal_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "PlayerLoadout", "decal_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`wheels_id` field](PlayerLoadout#structfield.wheels_id).
                #[inline]
                pub fn wheels_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "PlayerLoadout", "wheels_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`boost_id` field](PlayerLoadout#structfield.boost_id).
                #[inline]
                pub fn boost_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "PlayerLoadout", "boost_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`antenna_id` field](PlayerLoadout#structfield.antenna_id).
                #[inline]
                pub fn antenna_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "PlayerLoadout", "antenna_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`hat_id` field](PlayerLoadout#structfield.hat_id).
                #[inline]
                pub fn hat_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "PlayerLoadout", "hat_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`paint_finish_id` field](PlayerLoadout#structfield.paint_finish_id).
                #[inline]
                pub fn paint_finish_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "PlayerLoadout", "paint_finish_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`custom_finish_id` field](PlayerLoadout#structfield.custom_finish_id).
                #[inline]
                pub fn custom_finish_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "PlayerLoadout", "custom_finish_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`engine_audio_id` field](PlayerLoadout#structfield.engine_audio_id).
                #[inline]
                pub fn engine_audio_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "PlayerLoadout", "engine_audio_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`trails_id` field](PlayerLoadout#structfield.trails_id).
                #[inline]
                pub fn trails_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "PlayerLoadout", "trails_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`goal_explosion_id` field](PlayerLoadout#structfield.goal_explosion_id).
                #[inline]
                pub fn goal_explosion_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "PlayerLoadout", "goal_explosion_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`loadout_paint` field](PlayerLoadout#structfield.loadout_paint).
                #[inline]
                pub fn loadout_paint(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::LoadoutPaintRef<'a>>>
                {
                    self.0.access(13, "PlayerLoadout", "loadout_paint")
                }

                /// Getter for the [`primary_color_lookup` field](PlayerLoadout#structfield.primary_color_lookup).
                #[inline]
                pub fn primary_color_lookup(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ColorRef<'a>>> {
                    self.0.access(14, "PlayerLoadout", "primary_color_lookup")
                }

                /// Getter for the [`secondary_color_lookup` field](PlayerLoadout#structfield.secondary_color_lookup).
                #[inline]
                pub fn secondary_color_lookup(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::ColorRef<'a>>> {
                    self.0.access(15, "PlayerLoadout", "secondary_color_lookup")
                }
            }

            impl<'a> ::core::fmt::Debug for PlayerLoadoutRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlayerLoadoutRef");
                    f.field("team_color_id", &self.team_color_id());
                    f.field("custom_color_id", &self.custom_color_id());
                    f.field("car_id", &self.car_id());
                    f.field("decal_id", &self.decal_id());
                    f.field("wheels_id", &self.wheels_id());
                    f.field("boost_id", &self.boost_id());
                    f.field("antenna_id", &self.antenna_id());
                    f.field("hat_id", &self.hat_id());
                    f.field("paint_finish_id", &self.paint_finish_id());
                    f.field("custom_finish_id", &self.custom_finish_id());
                    f.field("engine_audio_id", &self.engine_audio_id());
                    f.field("trails_id", &self.trails_id());
                    f.field("goal_explosion_id", &self.goal_explosion_id());
                    if let ::core::option::Option::Some(field_loadout_paint) =
                        self.loadout_paint().transpose()
                    {
                        f.field("loadout_paint", &field_loadout_paint);
                    }
                    if let ::core::option::Option::Some(field_primary_color_lookup) =
                        self.primary_color_lookup().transpose()
                    {
                        f.field("primary_color_lookup", &field_primary_color_lookup);
                    }
                    if let ::core::option::Option::Some(field_secondary_color_lookup) =
                        self.secondary_color_lookup().transpose()
                    {
                        f.field("secondary_color_lookup", &field_secondary_color_lookup);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlayerLoadoutRef<'a>> for PlayerLoadout {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlayerLoadoutRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        team_color_id: ::core::convert::TryInto::try_into(value.team_color_id()?)?,
                        custom_color_id: ::core::convert::TryInto::try_into(
                            value.custom_color_id()?,
                        )?,
                        car_id: ::core::convert::TryInto::try_into(value.car_id()?)?,
                        decal_id: ::core::convert::TryInto::try_into(value.decal_id()?)?,
                        wheels_id: ::core::convert::TryInto::try_into(value.wheels_id()?)?,
                        boost_id: ::core::convert::TryInto::try_into(value.boost_id()?)?,
                        antenna_id: ::core::convert::TryInto::try_into(value.antenna_id()?)?,
                        hat_id: ::core::convert::TryInto::try_into(value.hat_id()?)?,
                        paint_finish_id: ::core::convert::TryInto::try_into(
                            value.paint_finish_id()?,
                        )?,
                        custom_finish_id: ::core::convert::TryInto::try_into(
                            value.custom_finish_id()?,
                        )?,
                        engine_audio_id: ::core::convert::TryInto::try_into(
                            value.engine_audio_id()?,
                        )?,
                        trails_id: ::core::convert::TryInto::try_into(value.trails_id()?)?,
                        goal_explosion_id: ::core::convert::TryInto::try_into(
                            value.goal_explosion_id()?,
                        )?,
                        loadout_paint: if let ::core::option::Option::Some(loadout_paint) =
                            value.loadout_paint()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(loadout_paint)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        primary_color_lookup: value
                            .primary_color_lookup()?
                            .map(::core::convert::Into::into),
                        secondary_color_lookup: value
                            .secondary_color_lookup()?
                            .map(::core::convert::Into::into),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlayerLoadoutRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlayerLoadoutRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlayerLoadoutRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlayerLoadout>> for PlayerLoadout {
                type Value = ::planus::Offset<PlayerLoadout>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlayerLoadout>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlayerLoadoutRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PlayerLoadoutRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SetLoadout` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `SetLoadout` in the file `rlbot/flatbuffers-schema/matchstart.fbs:52`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct SetLoadout {
                /// The field `index` in the table `SetLoadout`
                pub index: u32,
                /// The field `loadout` in the table `SetLoadout`
                pub loadout: ::planus::alloc::boxed::Box<self::PlayerLoadout>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SetLoadout {
                fn default() -> Self {
                    Self {
                        index: 0,
                        loadout: ::core::default::Default::default(),
                    }
                }
            }

            impl SetLoadout {
                /// Creates a [SetLoadoutBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SetLoadoutBuilder<()> {
                    SetLoadoutBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_loadout: impl ::planus::WriteAs<::planus::Offset<self::PlayerLoadout>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_index = field_index.prepare(builder, &0);
                    let prepared_loadout = field_loadout.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<self::PlayerLoadout>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_index) = prepared_index {
                                object_writer.write::<_, _, 4>(&prepared_index);
                            }
                            object_writer.write::<_, _, 4>(&prepared_loadout);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SetLoadout>> for SetLoadout {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SetLoadout> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SetLoadout>> for SetLoadout {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetLoadout>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SetLoadout> for SetLoadout {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SetLoadout> {
                    SetLoadout::create(builder, self.index, &self.loadout)
                }
            }

            /// Builder for serializing an instance of the [SetLoadout] type.
            ///
            /// Can be created using the [SetLoadout::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SetLoadoutBuilder<State>(State);

            impl SetLoadoutBuilder<()> {
                /// Setter for the [`index` field](SetLoadout#structfield.index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index<T0>(self, value: T0) -> SetLoadoutBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    SetLoadoutBuilder((value,))
                }

                /// Sets the [`index` field](SetLoadout#structfield.index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index_as_default(self) -> SetLoadoutBuilder<(::planus::DefaultValue,)> {
                    self.index(::planus::DefaultValue)
                }
            }

            impl<T0> SetLoadoutBuilder<(T0,)> {
                /// Setter for the [`loadout` field](SetLoadout#structfield.loadout).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn loadout<T1>(self, value: T1) -> SetLoadoutBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<self::PlayerLoadout>>,
                {
                    let (v0,) = self.0;
                    SetLoadoutBuilder((v0, value))
                }
            }

            impl<T0, T1> SetLoadoutBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SetLoadout].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<SetLoadout>
                where
                    Self: ::planus::WriteAsOffset<SetLoadout>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<self::PlayerLoadout>>,
                > ::planus::WriteAs<::planus::Offset<SetLoadout>> for SetLoadoutBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SetLoadout>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SetLoadout> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<self::PlayerLoadout>>,
                > ::planus::WriteAsOptional<::planus::Offset<SetLoadout>>
                for SetLoadoutBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<SetLoadout>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SetLoadout>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<self::PlayerLoadout>>,
                > ::planus::WriteAsOffset<SetLoadout> for SetLoadoutBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<SetLoadout> {
                    let (v0, v1) = &self.0;
                    SetLoadout::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [SetLoadout].
            #[derive(Copy, Clone)]
            pub struct SetLoadoutRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SetLoadoutRef<'a> {
                /// Getter for the [`index` field](SetLoadout#structfield.index).
                #[inline]
                pub fn index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SetLoadout", "index")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`loadout` field](SetLoadout#structfield.loadout).
                #[inline]
                pub fn loadout(&self) -> ::planus::Result<self::PlayerLoadoutRef<'a>> {
                    self.0.access_required(1, "SetLoadout", "loadout")
                }
            }

            impl<'a> ::core::fmt::Debug for SetLoadoutRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SetLoadoutRef");
                    f.field("index", &self.index());
                    f.field("loadout", &self.loadout());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SetLoadoutRef<'a>> for SetLoadout {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SetLoadoutRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        index: ::core::convert::TryInto::try_into(value.index()?)?,
                        loadout: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.loadout()?)?,
                        ),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SetLoadoutRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SetLoadoutRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SetLoadoutRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SetLoadout>> for SetLoadout {
                type Value = ::planus::Offset<SetLoadout>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SetLoadout>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SetLoadoutRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SetLoadoutRef]", "read_as_root", 0)
                    })
                }
            }

            ///  Specification for 'painted' items. See https://wiki.rlbot.org/botmaking/bot-customization/
            ///
            /// Generated from these locations:
            /// * Table `LoadoutPaint` in the file `rlbot/flatbuffers-schema/matchstart.fbs:58`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct LoadoutPaint {
                /// The field `car_paint_id` in the table `LoadoutPaint`
                pub car_paint_id: u32,
                /// The field `decal_paint_id` in the table `LoadoutPaint`
                pub decal_paint_id: u32,
                /// The field `wheels_paint_id` in the table `LoadoutPaint`
                pub wheels_paint_id: u32,
                /// The field `boost_paint_id` in the table `LoadoutPaint`
                pub boost_paint_id: u32,
                /// The field `antenna_paint_id` in the table `LoadoutPaint`
                pub antenna_paint_id: u32,
                /// The field `hat_paint_id` in the table `LoadoutPaint`
                pub hat_paint_id: u32,
                /// The field `trails_paint_id` in the table `LoadoutPaint`
                pub trails_paint_id: u32,
                /// The field `goal_explosion_paint_id` in the table `LoadoutPaint`
                pub goal_explosion_paint_id: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for LoadoutPaint {
                fn default() -> Self {
                    Self {
                        car_paint_id: 0,
                        decal_paint_id: 0,
                        wheels_paint_id: 0,
                        boost_paint_id: 0,
                        antenna_paint_id: 0,
                        hat_paint_id: 0,
                        trails_paint_id: 0,
                        goal_explosion_paint_id: 0,
                    }
                }
            }

            impl LoadoutPaint {
                /// Creates a [LoadoutPaintBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> LoadoutPaintBuilder<()> {
                    LoadoutPaintBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_car_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_decal_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_wheels_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_boost_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_antenna_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_hat_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_trails_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                    field_goal_explosion_paint_id: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_car_paint_id = field_car_paint_id.prepare(builder, &0);
                    let prepared_decal_paint_id = field_decal_paint_id.prepare(builder, &0);
                    let prepared_wheels_paint_id = field_wheels_paint_id.prepare(builder, &0);
                    let prepared_boost_paint_id = field_boost_paint_id.prepare(builder, &0);
                    let prepared_antenna_paint_id = field_antenna_paint_id.prepare(builder, &0);
                    let prepared_hat_paint_id = field_hat_paint_id.prepare(builder, &0);
                    let prepared_trails_paint_id = field_trails_paint_id.prepare(builder, &0);
                    let prepared_goal_explosion_paint_id =
                        field_goal_explosion_paint_id.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    if prepared_car_paint_id.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_decal_paint_id.is_some() {
                        table_writer.write_entry::<u32>(1);
                    }
                    if prepared_wheels_paint_id.is_some() {
                        table_writer.write_entry::<u32>(2);
                    }
                    if prepared_boost_paint_id.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    if prepared_antenna_paint_id.is_some() {
                        table_writer.write_entry::<u32>(4);
                    }
                    if prepared_hat_paint_id.is_some() {
                        table_writer.write_entry::<u32>(5);
                    }
                    if prepared_trails_paint_id.is_some() {
                        table_writer.write_entry::<u32>(6);
                    }
                    if prepared_goal_explosion_paint_id.is_some() {
                        table_writer.write_entry::<u32>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_car_paint_id) =
                                prepared_car_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_car_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_decal_paint_id) =
                                prepared_decal_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_decal_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_wheels_paint_id) =
                                prepared_wheels_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_wheels_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_boost_paint_id) =
                                prepared_boost_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_boost_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_antenna_paint_id) =
                                prepared_antenna_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_antenna_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_hat_paint_id) =
                                prepared_hat_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_hat_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_trails_paint_id) =
                                prepared_trails_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_trails_paint_id);
                            }
                            if let ::core::option::Option::Some(prepared_goal_explosion_paint_id) =
                                prepared_goal_explosion_paint_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_goal_explosion_paint_id);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<LoadoutPaint>> for LoadoutPaint {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LoadoutPaint> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<LoadoutPaint>> for LoadoutPaint {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<LoadoutPaint>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<LoadoutPaint> for LoadoutPaint {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LoadoutPaint> {
                    LoadoutPaint::create(
                        builder,
                        self.car_paint_id,
                        self.decal_paint_id,
                        self.wheels_paint_id,
                        self.boost_paint_id,
                        self.antenna_paint_id,
                        self.hat_paint_id,
                        self.trails_paint_id,
                        self.goal_explosion_paint_id,
                    )
                }
            }

            /// Builder for serializing an instance of the [LoadoutPaint] type.
            ///
            /// Can be created using the [LoadoutPaint::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct LoadoutPaintBuilder<State>(State);

            impl LoadoutPaintBuilder<()> {
                /// Setter for the [`car_paint_id` field](LoadoutPaint#structfield.car_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn car_paint_id<T0>(self, value: T0) -> LoadoutPaintBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    LoadoutPaintBuilder((value,))
                }

                /// Sets the [`car_paint_id` field](LoadoutPaint#structfield.car_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn car_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(::planus::DefaultValue,)> {
                    self.car_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0> LoadoutPaintBuilder<(T0,)> {
                /// Setter for the [`decal_paint_id` field](LoadoutPaint#structfield.decal_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn decal_paint_id<T1>(self, value: T1) -> LoadoutPaintBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0,) = self.0;
                    LoadoutPaintBuilder((v0, value))
                }

                /// Sets the [`decal_paint_id` field](LoadoutPaint#structfield.decal_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn decal_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, ::planus::DefaultValue)> {
                    self.decal_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1> LoadoutPaintBuilder<(T0, T1)> {
                /// Setter for the [`wheels_paint_id` field](LoadoutPaint#structfield.wheels_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wheels_paint_id<T2>(self, value: T2) -> LoadoutPaintBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    LoadoutPaintBuilder((v0, v1, value))
                }

                /// Sets the [`wheels_paint_id` field](LoadoutPaint#structfield.wheels_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wheels_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.wheels_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> LoadoutPaintBuilder<(T0, T1, T2)> {
                /// Setter for the [`boost_paint_id` field](LoadoutPaint#structfield.boost_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_paint_id<T3>(self, value: T3) -> LoadoutPaintBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    LoadoutPaintBuilder((v0, v1, v2, value))
                }

                /// Sets the [`boost_paint_id` field](LoadoutPaint#structfield.boost_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.boost_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> LoadoutPaintBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`antenna_paint_id` field](LoadoutPaint#structfield.antenna_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn antenna_paint_id<T4>(
                    self,
                    value: T4,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    LoadoutPaintBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`antenna_paint_id` field](LoadoutPaint#structfield.antenna_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn antenna_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.antenna_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> LoadoutPaintBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`hat_paint_id` field](LoadoutPaint#structfield.hat_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hat_paint_id<T5>(
                    self,
                    value: T5,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    LoadoutPaintBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`hat_paint_id` field](LoadoutPaint#structfield.hat_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hat_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.hat_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`trails_paint_id` field](LoadoutPaint#structfield.trails_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trails_paint_id<T6>(
                    self,
                    value: T6,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    LoadoutPaintBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`trails_paint_id` field](LoadoutPaint#structfield.trails_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn trails_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.trails_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`goal_explosion_paint_id` field](LoadoutPaint#structfield.goal_explosion_paint_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn goal_explosion_paint_id<T7>(
                    self,
                    value: T7,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    LoadoutPaintBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`goal_explosion_paint_id` field](LoadoutPaint#structfield.goal_explosion_paint_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn goal_explosion_paint_id_as_default(
                    self,
                ) -> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.goal_explosion_paint_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [LoadoutPaint].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LoadoutPaint>
                where
                    Self: ::planus::WriteAsOffset<LoadoutPaint>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<LoadoutPaint>>
                for LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<LoadoutPaint>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LoadoutPaint> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<LoadoutPaint>>
                for LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<LoadoutPaint>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<LoadoutPaint>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<u32, u32>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                    T4: ::planus::WriteAsDefault<u32, u32>,
                    T5: ::planus::WriteAsDefault<u32, u32>,
                    T6: ::planus::WriteAsDefault<u32, u32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<LoadoutPaint>
                for LoadoutPaintBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<LoadoutPaint> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    LoadoutPaint::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [LoadoutPaint].
            #[derive(Copy, Clone)]
            pub struct LoadoutPaintRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> LoadoutPaintRef<'a> {
                /// Getter for the [`car_paint_id` field](LoadoutPaint#structfield.car_paint_id).
                #[inline]
                pub fn car_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "LoadoutPaint", "car_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`decal_paint_id` field](LoadoutPaint#structfield.decal_paint_id).
                #[inline]
                pub fn decal_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "LoadoutPaint", "decal_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`wheels_paint_id` field](LoadoutPaint#structfield.wheels_paint_id).
                #[inline]
                pub fn wheels_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "LoadoutPaint", "wheels_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`boost_paint_id` field](LoadoutPaint#structfield.boost_paint_id).
                #[inline]
                pub fn boost_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "LoadoutPaint", "boost_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`antenna_paint_id` field](LoadoutPaint#structfield.antenna_paint_id).
                #[inline]
                pub fn antenna_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "LoadoutPaint", "antenna_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`hat_paint_id` field](LoadoutPaint#structfield.hat_paint_id).
                #[inline]
                pub fn hat_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "LoadoutPaint", "hat_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`trails_paint_id` field](LoadoutPaint#structfield.trails_paint_id).
                #[inline]
                pub fn trails_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "LoadoutPaint", "trails_paint_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`goal_explosion_paint_id` field](LoadoutPaint#structfield.goal_explosion_paint_id).
                #[inline]
                pub fn goal_explosion_paint_id(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "LoadoutPaint", "goal_explosion_paint_id")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for LoadoutPaintRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("LoadoutPaintRef");
                    f.field("car_paint_id", &self.car_paint_id());
                    f.field("decal_paint_id", &self.decal_paint_id());
                    f.field("wheels_paint_id", &self.wheels_paint_id());
                    f.field("boost_paint_id", &self.boost_paint_id());
                    f.field("antenna_paint_id", &self.antenna_paint_id());
                    f.field("hat_paint_id", &self.hat_paint_id());
                    f.field("trails_paint_id", &self.trails_paint_id());
                    f.field("goal_explosion_paint_id", &self.goal_explosion_paint_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<LoadoutPaintRef<'a>> for LoadoutPaint {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: LoadoutPaintRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        car_paint_id: ::core::convert::TryInto::try_into(value.car_paint_id()?)?,
                        decal_paint_id: ::core::convert::TryInto::try_into(
                            value.decal_paint_id()?,
                        )?,
                        wheels_paint_id: ::core::convert::TryInto::try_into(
                            value.wheels_paint_id()?,
                        )?,
                        boost_paint_id: ::core::convert::TryInto::try_into(
                            value.boost_paint_id()?,
                        )?,
                        antenna_paint_id: ::core::convert::TryInto::try_into(
                            value.antenna_paint_id()?,
                        )?,
                        hat_paint_id: ::core::convert::TryInto::try_into(value.hat_paint_id()?)?,
                        trails_paint_id: ::core::convert::TryInto::try_into(
                            value.trails_paint_id()?,
                        )?,
                        goal_explosion_paint_id: ::core::convert::TryInto::try_into(
                            value.goal_explosion_paint_id()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for LoadoutPaintRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for LoadoutPaintRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[LoadoutPaintRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<LoadoutPaint>> for LoadoutPaint {
                type Value = ::planus::Offset<LoadoutPaint>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<LoadoutPaint>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for LoadoutPaintRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[LoadoutPaintRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `PlayerConfiguration` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `PlayerConfiguration` in the file `rlbot/flatbuffers-schema/matchstart.fbs:69`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PlayerConfiguration {
                /// The field `variety` in the table `PlayerConfiguration`
                pub variety: self::PlayerClass,
                /// The field `name` in the table `PlayerConfiguration`
                pub name: ::planus::alloc::string::String,
                /// The field `team` in the table `PlayerConfiguration`
                pub team: u32,
                /// The field `root_dir` in the table `PlayerConfiguration`
                pub root_dir: ::planus::alloc::string::String,
                /// The field `run_command` in the table `PlayerConfiguration`
                pub run_command: ::planus::alloc::string::String,
                /// The field `loadout` in the table `PlayerConfiguration`
                pub loadout:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::PlayerLoadout>>,
                /// The field `spawn_id` in the table `PlayerConfiguration`
                pub spawn_id: i32,
                /// The field `agent_id` in the table `PlayerConfiguration`
                pub agent_id: ::planus::alloc::string::String,
                /// The field `hivemind` in the table `PlayerConfiguration`
                pub hivemind: bool,
            }

            impl PlayerConfiguration {
                /// Creates a [PlayerConfigurationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlayerConfigurationBuilder<()> {
                    PlayerConfigurationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_variety: impl ::planus::WriteAsUnion<self::PlayerClass>,
                    field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_team: impl ::planus::WriteAsDefault<u32, u32>,
                    field_root_dir: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_run_command: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_loadout: impl ::planus::WriteAsOptional<::planus::Offset<self::PlayerLoadout>>,
                    field_spawn_id: impl ::planus::WriteAsDefault<i32, i32>,
                    field_agent_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_hivemind: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_variety = field_variety.prepare(builder);
                    let prepared_name = field_name.prepare(builder);
                    let prepared_team = field_team.prepare(builder, &0);
                    let prepared_root_dir = field_root_dir.prepare(builder);
                    let prepared_run_command = field_run_command.prepare(builder);
                    let prepared_loadout = field_loadout.prepare(builder);
                    let prepared_spawn_id = field_spawn_id.prepare(builder, &0);
                    let prepared_agent_id = field_agent_id.prepare(builder);
                    let prepared_hivemind = field_hivemind.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<24> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::PlayerClass>>(1);
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_team.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(4);
                    table_writer.write_entry::<::planus::Offset<str>>(5);
                    if prepared_loadout.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::PlayerLoadout>>(6);
                    }
                    if prepared_spawn_id.is_some() {
                        table_writer.write_entry::<i32>(7);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(8);
                    table_writer.write_entry::<u8>(0);
                    if prepared_hivemind.is_some() {
                        table_writer.write_entry::<bool>(9);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_variety.offset());
                            object_writer.write::<_, _, 4>(&prepared_name);
                            if let ::core::option::Option::Some(prepared_team) = prepared_team {
                                object_writer.write::<_, _, 4>(&prepared_team);
                            }
                            object_writer.write::<_, _, 4>(&prepared_root_dir);
                            object_writer.write::<_, _, 4>(&prepared_run_command);
                            if let ::core::option::Option::Some(prepared_loadout) = prepared_loadout
                            {
                                object_writer.write::<_, _, 4>(&prepared_loadout);
                            }
                            if let ::core::option::Option::Some(prepared_spawn_id) =
                                prepared_spawn_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_spawn_id);
                            }
                            object_writer.write::<_, _, 4>(&prepared_agent_id);
                            object_writer.write::<_, _, 1>(&prepared_variety.tag());
                            if let ::core::option::Option::Some(prepared_hivemind) =
                                prepared_hivemind
                            {
                                object_writer.write::<_, _, 1>(&prepared_hivemind);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlayerConfiguration>> for PlayerConfiguration {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerConfiguration> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlayerConfiguration>> for PlayerConfiguration {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerConfiguration>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlayerConfiguration> for PlayerConfiguration {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerConfiguration> {
                    PlayerConfiguration::create(
                        builder,
                        &self.variety,
                        &self.name,
                        self.team,
                        &self.root_dir,
                        &self.run_command,
                        &self.loadout,
                        self.spawn_id,
                        &self.agent_id,
                        self.hivemind,
                    )
                }
            }

            /// Builder for serializing an instance of the [PlayerConfiguration] type.
            ///
            /// Can be created using the [PlayerConfiguration::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlayerConfigurationBuilder<State>(State);

            impl PlayerConfigurationBuilder<()> {
                /// Setter for the [`variety` field](PlayerConfiguration#structfield.variety).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn variety<T0>(self, value: T0) -> PlayerConfigurationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsUnion<self::PlayerClass>,
                {
                    PlayerConfigurationBuilder((value,))
                }
            }

            impl<T0> PlayerConfigurationBuilder<(T0,)> {
                /// Setter for the [`name` field](PlayerConfiguration#structfield.name).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn name<T1>(self, value: T1) -> PlayerConfigurationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    PlayerConfigurationBuilder((v0, value))
                }
            }

            impl<T0, T1> PlayerConfigurationBuilder<(T0, T1)> {
                /// Setter for the [`team` field](PlayerConfiguration#structfield.team).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team<T2>(self, value: T2) -> PlayerConfigurationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1) = self.0;
                    PlayerConfigurationBuilder((v0, v1, value))
                }

                /// Sets the [`team` field](PlayerConfiguration#structfield.team) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_as_default(
                    self,
                ) -> PlayerConfigurationBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.team(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> PlayerConfigurationBuilder<(T0, T1, T2)> {
                /// Setter for the [`root_dir` field](PlayerConfiguration#structfield.root_dir).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn root_dir<T3>(self, value: T3) -> PlayerConfigurationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> PlayerConfigurationBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`run_command` field](PlayerConfiguration#structfield.run_command).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn run_command<T4>(
                    self,
                    value: T4,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`loadout` field](PlayerConfiguration#structfield.loadout).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn loadout<T5>(
                    self,
                    value: T5,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsOptional<::planus::Offset<self::PlayerLoadout>>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`loadout` field](PlayerConfiguration#structfield.loadout) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn loadout_as_null(
                    self,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, ())> {
                    self.loadout(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`spawn_id` field](PlayerConfiguration#structfield.spawn_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id<T6>(
                    self,
                    value: T6,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<i32, i32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`spawn_id` field](PlayerConfiguration#structfield.spawn_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id_as_default(
                    self,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.spawn_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`agent_id` field](PlayerConfiguration#structfield.agent_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn agent_id<T7>(
                    self,
                    value: T7,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`hivemind` field](PlayerConfiguration#structfield.hivemind).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hivemind<T8>(
                    self,
                    value: T8,
                ) -> PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    PlayerConfigurationBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`hivemind` field](PlayerConfiguration#structfield.hivemind) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hivemind_as_default(
                    self,
                ) -> PlayerConfigurationBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    ::planus::DefaultValue,
                )> {
                    self.hivemind(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlayerConfiguration].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerConfiguration>
                where
                    Self: ::planus::WriteAsOffset<PlayerConfiguration>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsUnion<self::PlayerClass>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<self::PlayerLoadout>>,
                    T6: ::planus::WriteAsDefault<i32, i32>,
                    T7: ::planus::WriteAs<::planus::Offset<str>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<PlayerConfiguration>>
                for PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                type Prepared = ::planus::Offset<PlayerConfiguration>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerConfiguration> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsUnion<self::PlayerClass>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<self::PlayerLoadout>>,
                    T6: ::planus::WriteAsDefault<i32, i32>,
                    T7: ::planus::WriteAs<::planus::Offset<str>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<PlayerConfiguration>>
                for PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                type Prepared = ::planus::Offset<PlayerConfiguration>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerConfiguration>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsUnion<self::PlayerClass>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<u32, u32>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                    T5: ::planus::WriteAsOptional<::planus::Offset<self::PlayerLoadout>>,
                    T6: ::planus::WriteAsDefault<i32, i32>,
                    T7: ::planus::WriteAs<::planus::Offset<str>>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<PlayerConfiguration>
                for PlayerConfigurationBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerConfiguration> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = &self.0;
                    PlayerConfiguration::create(builder, v0, v1, v2, v3, v4, v5, v6, v7, v8)
                }
            }

            /// Reference to a deserialized [PlayerConfiguration].
            #[derive(Copy, Clone)]
            pub struct PlayerConfigurationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlayerConfigurationRef<'a> {
                /// Getter for the [`variety` field](PlayerConfiguration#structfield.variety).
                #[inline]
                pub fn variety(&self) -> ::planus::Result<self::PlayerClassRef<'a>> {
                    self.0
                        .access_union_required(0, "PlayerConfiguration", "variety")
                }

                /// Getter for the [`name` field](PlayerConfiguration#structfield.name).
                #[inline]
                pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(2, "PlayerConfiguration", "name")
                }

                /// Getter for the [`team` field](PlayerConfiguration#structfield.team).
                #[inline]
                pub fn team(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "PlayerConfiguration", "team")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`root_dir` field](PlayerConfiguration#structfield.root_dir).
                #[inline]
                pub fn root_dir(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "PlayerConfiguration", "root_dir")
                }

                /// Getter for the [`run_command` field](PlayerConfiguration#structfield.run_command).
                #[inline]
                pub fn run_command(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(5, "PlayerConfiguration", "run_command")
                }

                /// Getter for the [`loadout` field](PlayerConfiguration#structfield.loadout).
                #[inline]
                pub fn loadout(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::PlayerLoadoutRef<'a>>>
                {
                    self.0.access(6, "PlayerConfiguration", "loadout")
                }

                /// Getter for the [`spawn_id` field](PlayerConfiguration#structfield.spawn_id).
                #[inline]
                pub fn spawn_id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "PlayerConfiguration", "spawn_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`agent_id` field](PlayerConfiguration#structfield.agent_id).
                #[inline]
                pub fn agent_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(8, "PlayerConfiguration", "agent_id")
                }

                /// Getter for the [`hivemind` field](PlayerConfiguration#structfield.hivemind).
                #[inline]
                pub fn hivemind(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "PlayerConfiguration", "hivemind")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for PlayerConfigurationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlayerConfigurationRef");
                    f.field("variety", &self.variety());
                    f.field("name", &self.name());
                    f.field("team", &self.team());
                    f.field("root_dir", &self.root_dir());
                    f.field("run_command", &self.run_command());
                    if let ::core::option::Option::Some(field_loadout) = self.loadout().transpose()
                    {
                        f.field("loadout", &field_loadout);
                    }
                    f.field("spawn_id", &self.spawn_id());
                    f.field("agent_id", &self.agent_id());
                    f.field("hivemind", &self.hivemind());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlayerConfigurationRef<'a>> for PlayerConfiguration {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlayerConfigurationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        variety: ::core::convert::TryInto::try_into(value.variety()?)?,
                        name: ::core::convert::Into::into(value.name()?),
                        team: ::core::convert::TryInto::try_into(value.team()?)?,
                        root_dir: ::core::convert::Into::into(value.root_dir()?),
                        run_command: ::core::convert::Into::into(value.run_command()?),
                        loadout: if let ::core::option::Option::Some(loadout) = value.loadout()? {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(loadout)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        spawn_id: ::core::convert::TryInto::try_into(value.spawn_id()?)?,
                        agent_id: ::core::convert::Into::into(value.agent_id()?),
                        hivemind: ::core::convert::TryInto::try_into(value.hivemind()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlayerConfigurationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlayerConfigurationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlayerConfigurationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlayerConfiguration>> for PlayerConfiguration {
                type Value = ::planus::Offset<PlayerConfiguration>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlayerConfiguration>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlayerConfigurationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlayerConfigurationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The enum `GameMode` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `GameMode` in the file `rlbot/flatbuffers-schema/matchstart.fbs:83`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum GameMode {
                /// The variant `Soccer` in the enum `GameMode`
                Soccer = 0,

                /// The variant `Hoops` in the enum `GameMode`
                Hoops = 1,

                /// The variant `Dropshot` in the enum `GameMode`
                Dropshot = 2,

                /// The variant `Hockey` in the enum `GameMode`
                Hockey = 3,

                /// The variant `Rumble` in the enum `GameMode`
                Rumble = 4,

                /// The variant `Heatseeker` in the enum `GameMode`
                Heatseeker = 5,

                /// The variant `Gridiron` in the enum `GameMode`
                Gridiron = 6,

                /// The variant `Knockout` in the enum `GameMode`
                Knockout = 7,
            }

            impl GameMode {
                /// Array containing all valid variants of GameMode
                pub const ENUM_VALUES: [Self; 8] = [
                    Self::Soccer,
                    Self::Hoops,
                    Self::Dropshot,
                    Self::Hockey,
                    Self::Rumble,
                    Self::Heatseeker,
                    Self::Gridiron,
                    Self::Knockout,
                ];
            }

            impl ::core::convert::TryFrom<u8> for GameMode {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(GameMode::Soccer),
                        1 => ::core::result::Result::Ok(GameMode::Hoops),
                        2 => ::core::result::Result::Ok(GameMode::Dropshot),
                        3 => ::core::result::Result::Ok(GameMode::Hockey),
                        4 => ::core::result::Result::Ok(GameMode::Rumble),
                        5 => ::core::result::Result::Ok(GameMode::Heatseeker),
                        6 => ::core::result::Result::Ok(GameMode::Gridiron),
                        7 => ::core::result::Result::Ok(GameMode::Knockout),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<GameMode> for u8 {
                #[inline]
                fn from(value: GameMode) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for GameMode {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<GameMode> for GameMode {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<GameMode> for GameMode {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> GameMode {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<GameMode, GameMode> for GameMode {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &GameMode,
                ) -> ::core::option::Option<GameMode> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<GameMode> for GameMode {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<GameMode> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for GameMode {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for GameMode {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "GameMode",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<GameMode> for GameMode {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `MatchLength` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `MatchLength` in the file `rlbot/flatbuffers-schema/matchstart.fbs:94`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MatchLength {
                /// The variant `Five_Minutes` in the enum `MatchLength`
                FiveMinutes = 0,

                /// The variant `Ten_Minutes` in the enum `MatchLength`
                TenMinutes = 1,

                /// The variant `Twenty_Minutes` in the enum `MatchLength`
                TwentyMinutes = 2,

                /// The variant `Unlimited` in the enum `MatchLength`
                Unlimited = 3,
            }

            impl MatchLength {
                /// Array containing all valid variants of MatchLength
                pub const ENUM_VALUES: [Self; 4] = [
                    Self::FiveMinutes,
                    Self::TenMinutes,
                    Self::TwentyMinutes,
                    Self::Unlimited,
                ];
            }

            impl ::core::convert::TryFrom<u8> for MatchLength {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MatchLength::FiveMinutes),
                        1 => ::core::result::Result::Ok(MatchLength::TenMinutes),
                        2 => ::core::result::Result::Ok(MatchLength::TwentyMinutes),
                        3 => ::core::result::Result::Ok(MatchLength::Unlimited),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MatchLength> for u8 {
                #[inline]
                fn from(value: MatchLength) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MatchLength {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MatchLength> for MatchLength {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MatchLength> for MatchLength {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MatchLength {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MatchLength, MatchLength> for MatchLength {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MatchLength,
                ) -> ::core::option::Option<MatchLength> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MatchLength> for MatchLength {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MatchLength> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MatchLength {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MatchLength {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MatchLength",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MatchLength> for MatchLength {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `MaxScore` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `MaxScore` in the file `rlbot/flatbuffers-schema/matchstart.fbs:101`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MaxScore {
                /// The variant `Default` in the enum `MaxScore`
                Default = 0,

                /// The variant `One_Goal` in the enum `MaxScore`
                OneGoal = 1,

                /// The variant `Three_Goals` in the enum `MaxScore`
                ThreeGoals = 2,

                /// The variant `Five_Goals` in the enum `MaxScore`
                FiveGoals = 3,

                /// The variant `Seven_Goals` in the enum `MaxScore`
                SevenGoals = 4,

                /// The variant `Unlimited` in the enum `MaxScore`
                Unlimited = 5,
            }

            impl MaxScore {
                /// Array containing all valid variants of MaxScore
                pub const ENUM_VALUES: [Self; 6] = [
                    Self::Default,
                    Self::OneGoal,
                    Self::ThreeGoals,
                    Self::FiveGoals,
                    Self::SevenGoals,
                    Self::Unlimited,
                ];
            }

            impl ::core::convert::TryFrom<u8> for MaxScore {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MaxScore::Default),
                        1 => ::core::result::Result::Ok(MaxScore::OneGoal),
                        2 => ::core::result::Result::Ok(MaxScore::ThreeGoals),
                        3 => ::core::result::Result::Ok(MaxScore::FiveGoals),
                        4 => ::core::result::Result::Ok(MaxScore::SevenGoals),
                        5 => ::core::result::Result::Ok(MaxScore::Unlimited),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MaxScore> for u8 {
                #[inline]
                fn from(value: MaxScore) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MaxScore {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MaxScore> for MaxScore {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MaxScore> for MaxScore {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MaxScore {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MaxScore, MaxScore> for MaxScore {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MaxScore,
                ) -> ::core::option::Option<MaxScore> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MaxScore> for MaxScore {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MaxScore> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MaxScore {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MaxScore {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MaxScore",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MaxScore> for MaxScore {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `MultiBall` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `MultiBall` in the file `rlbot/flatbuffers-schema/matchstart.fbs:110`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MultiBall {
                /// The variant `One` in the enum `MultiBall`
                One = 0,

                /// The variant `Two` in the enum `MultiBall`
                Two = 1,

                /// The variant `Four` in the enum `MultiBall`
                Four = 2,

                /// The variant `Six` in the enum `MultiBall`
                Six = 3,
            }

            impl MultiBall {
                /// Array containing all valid variants of MultiBall
                pub const ENUM_VALUES: [Self; 4] = [Self::One, Self::Two, Self::Four, Self::Six];
            }

            impl ::core::convert::TryFrom<u8> for MultiBall {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MultiBall::One),
                        1 => ::core::result::Result::Ok(MultiBall::Two),
                        2 => ::core::result::Result::Ok(MultiBall::Four),
                        3 => ::core::result::Result::Ok(MultiBall::Six),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MultiBall> for u8 {
                #[inline]
                fn from(value: MultiBall) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MultiBall {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MultiBall> for MultiBall {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MultiBall> for MultiBall {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MultiBall {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MultiBall, MultiBall> for MultiBall {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MultiBall,
                ) -> ::core::option::Option<MultiBall> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MultiBall> for MultiBall {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MultiBall> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MultiBall {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MultiBall {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MultiBall",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MultiBall> for MultiBall {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `OvertimeOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `OvertimeOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:117`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum OvertimeOption {
                /// The variant `Unlimited` in the enum `OvertimeOption`
                Unlimited = 0,

                /// The variant `Five_Max_First_Score` in the enum `OvertimeOption`
                FiveMaxFirstScore = 1,

                /// The variant `Five_Max_Random_Team` in the enum `OvertimeOption`
                FiveMaxRandomTeam = 2,
            }

            impl OvertimeOption {
                /// Array containing all valid variants of OvertimeOption
                pub const ENUM_VALUES: [Self; 3] = [
                    Self::Unlimited,
                    Self::FiveMaxFirstScore,
                    Self::FiveMaxRandomTeam,
                ];
            }

            impl ::core::convert::TryFrom<u8> for OvertimeOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(OvertimeOption::Unlimited),
                        1 => ::core::result::Result::Ok(OvertimeOption::FiveMaxFirstScore),
                        2 => ::core::result::Result::Ok(OvertimeOption::FiveMaxRandomTeam),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<OvertimeOption> for u8 {
                #[inline]
                fn from(value: OvertimeOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for OvertimeOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<OvertimeOption> for OvertimeOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<OvertimeOption> for OvertimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> OvertimeOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<OvertimeOption, OvertimeOption> for OvertimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &OvertimeOption,
                ) -> ::core::option::Option<OvertimeOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<OvertimeOption> for OvertimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<OvertimeOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for OvertimeOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for OvertimeOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "OvertimeOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<OvertimeOption> for OvertimeOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `SeriesLengthOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `SeriesLengthOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:123`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum SeriesLengthOption {
                /// The variant `Unlimited` in the enum `SeriesLengthOption`
                Unlimited = 0,

                /// The variant `Three_Games` in the enum `SeriesLengthOption`
                ThreeGames = 1,

                /// The variant `Five_Games` in the enum `SeriesLengthOption`
                FiveGames = 2,

                /// The variant `Seven_Games` in the enum `SeriesLengthOption`
                SevenGames = 3,
            }

            impl SeriesLengthOption {
                /// Array containing all valid variants of SeriesLengthOption
                pub const ENUM_VALUES: [Self; 4] = [
                    Self::Unlimited,
                    Self::ThreeGames,
                    Self::FiveGames,
                    Self::SevenGames,
                ];
            }

            impl ::core::convert::TryFrom<u8> for SeriesLengthOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(SeriesLengthOption::Unlimited),
                        1 => ::core::result::Result::Ok(SeriesLengthOption::ThreeGames),
                        2 => ::core::result::Result::Ok(SeriesLengthOption::FiveGames),
                        3 => ::core::result::Result::Ok(SeriesLengthOption::SevenGames),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<SeriesLengthOption> for u8 {
                #[inline]
                fn from(value: SeriesLengthOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for SeriesLengthOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<SeriesLengthOption> for SeriesLengthOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<SeriesLengthOption> for SeriesLengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> SeriesLengthOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<SeriesLengthOption, SeriesLengthOption> for SeriesLengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &SeriesLengthOption,
                ) -> ::core::option::Option<SeriesLengthOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<SeriesLengthOption> for SeriesLengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<SeriesLengthOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for SeriesLengthOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for SeriesLengthOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "SeriesLengthOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<SeriesLengthOption> for SeriesLengthOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `GameSpeedOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `GameSpeedOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:130`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum GameSpeedOption {
                /// The variant `Default` in the enum `GameSpeedOption`
                Default = 0,

                /// The variant `Slo_Mo` in the enum `GameSpeedOption`
                SloMo = 1,

                /// The variant `Time_Warp` in the enum `GameSpeedOption`
                TimeWarp = 2,
            }

            impl GameSpeedOption {
                /// Array containing all valid variants of GameSpeedOption
                pub const ENUM_VALUES: [Self; 3] = [Self::Default, Self::SloMo, Self::TimeWarp];
            }

            impl ::core::convert::TryFrom<u8> for GameSpeedOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(GameSpeedOption::Default),
                        1 => ::core::result::Result::Ok(GameSpeedOption::SloMo),
                        2 => ::core::result::Result::Ok(GameSpeedOption::TimeWarp),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<GameSpeedOption> for u8 {
                #[inline]
                fn from(value: GameSpeedOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for GameSpeedOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<GameSpeedOption> for GameSpeedOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<GameSpeedOption> for GameSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> GameSpeedOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<GameSpeedOption, GameSpeedOption> for GameSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &GameSpeedOption,
                ) -> ::core::option::Option<GameSpeedOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<GameSpeedOption> for GameSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<GameSpeedOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for GameSpeedOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for GameSpeedOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "GameSpeedOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<GameSpeedOption> for GameSpeedOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BallMaxSpeedOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BallMaxSpeedOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:136`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BallMaxSpeedOption {
                /// The variant `Default` in the enum `BallMaxSpeedOption`
                Default = 0,

                /// The variant `Slow` in the enum `BallMaxSpeedOption`
                Slow = 1,

                /// The variant `Fast` in the enum `BallMaxSpeedOption`
                Fast = 2,

                /// The variant `Super_Fast` in the enum `BallMaxSpeedOption`
                SuperFast = 3,
            }

            impl BallMaxSpeedOption {
                /// Array containing all valid variants of BallMaxSpeedOption
                pub const ENUM_VALUES: [Self; 4] =
                    [Self::Default, Self::Slow, Self::Fast, Self::SuperFast];
            }

            impl ::core::convert::TryFrom<u8> for BallMaxSpeedOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BallMaxSpeedOption::Default),
                        1 => ::core::result::Result::Ok(BallMaxSpeedOption::Slow),
                        2 => ::core::result::Result::Ok(BallMaxSpeedOption::Fast),
                        3 => ::core::result::Result::Ok(BallMaxSpeedOption::SuperFast),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BallMaxSpeedOption> for u8 {
                #[inline]
                fn from(value: BallMaxSpeedOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BallMaxSpeedOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BallMaxSpeedOption> for BallMaxSpeedOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BallMaxSpeedOption> for BallMaxSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BallMaxSpeedOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BallMaxSpeedOption, BallMaxSpeedOption> for BallMaxSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BallMaxSpeedOption,
                ) -> ::core::option::Option<BallMaxSpeedOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BallMaxSpeedOption> for BallMaxSpeedOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BallMaxSpeedOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BallMaxSpeedOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BallMaxSpeedOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BallMaxSpeedOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BallMaxSpeedOption> for BallMaxSpeedOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BallTypeOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BallTypeOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:143`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BallTypeOption {
                /// The variant `Default` in the enum `BallTypeOption`
                Default = 0,

                /// The variant `Cube` in the enum `BallTypeOption`
                Cube = 1,

                /// The variant `Puck` in the enum `BallTypeOption`
                Puck = 2,

                /// The variant `Basketball` in the enum `BallTypeOption`
                Basketball = 3,

                /// The variant `Beachball` in the enum `BallTypeOption`
                Beachball = 4,

                /// The variant `Anniversary` in the enum `BallTypeOption`
                Anniversary = 5,

                /// The variant `Haunted` in the enum `BallTypeOption`
                Haunted = 6,

                /// The variant `Ekin` in the enum `BallTypeOption`
                Ekin = 7,

                /// The variant `SpookyCube` in the enum `BallTypeOption`
                SpookyCube = 8,
            }

            impl BallTypeOption {
                /// Array containing all valid variants of BallTypeOption
                pub const ENUM_VALUES: [Self; 9] = [
                    Self::Default,
                    Self::Cube,
                    Self::Puck,
                    Self::Basketball,
                    Self::Beachball,
                    Self::Anniversary,
                    Self::Haunted,
                    Self::Ekin,
                    Self::SpookyCube,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BallTypeOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BallTypeOption::Default),
                        1 => ::core::result::Result::Ok(BallTypeOption::Cube),
                        2 => ::core::result::Result::Ok(BallTypeOption::Puck),
                        3 => ::core::result::Result::Ok(BallTypeOption::Basketball),
                        4 => ::core::result::Result::Ok(BallTypeOption::Beachball),
                        5 => ::core::result::Result::Ok(BallTypeOption::Anniversary),
                        6 => ::core::result::Result::Ok(BallTypeOption::Haunted),
                        7 => ::core::result::Result::Ok(BallTypeOption::Ekin),
                        8 => ::core::result::Result::Ok(BallTypeOption::SpookyCube),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BallTypeOption> for u8 {
                #[inline]
                fn from(value: BallTypeOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BallTypeOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BallTypeOption> for BallTypeOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BallTypeOption> for BallTypeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BallTypeOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BallTypeOption, BallTypeOption> for BallTypeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BallTypeOption,
                ) -> ::core::option::Option<BallTypeOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BallTypeOption> for BallTypeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BallTypeOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BallTypeOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BallTypeOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BallTypeOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BallTypeOption> for BallTypeOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BallWeightOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BallWeightOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:155`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BallWeightOption {
                /// The variant `Default` in the enum `BallWeightOption`
                Default = 0,

                /// The variant `Light` in the enum `BallWeightOption`
                Light = 1,

                /// The variant `Heavy` in the enum `BallWeightOption`
                Heavy = 2,

                /// The variant `Super_Light` in the enum `BallWeightOption`
                SuperLight = 3,

                /// The variant `Curve_Ball` in the enum `BallWeightOption`
                CurveBall = 4,

                /// The variant `Beach_Ball_Curve` in the enum `BallWeightOption`
                BeachBallCurve = 5,

                /// The variant `Magnus_FutBall` in the enum `BallWeightOption`
                MagnusFutBall = 6,
            }

            impl BallWeightOption {
                /// Array containing all valid variants of BallWeightOption
                pub const ENUM_VALUES: [Self; 7] = [
                    Self::Default,
                    Self::Light,
                    Self::Heavy,
                    Self::SuperLight,
                    Self::CurveBall,
                    Self::BeachBallCurve,
                    Self::MagnusFutBall,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BallWeightOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BallWeightOption::Default),
                        1 => ::core::result::Result::Ok(BallWeightOption::Light),
                        2 => ::core::result::Result::Ok(BallWeightOption::Heavy),
                        3 => ::core::result::Result::Ok(BallWeightOption::SuperLight),
                        4 => ::core::result::Result::Ok(BallWeightOption::CurveBall),
                        5 => ::core::result::Result::Ok(BallWeightOption::BeachBallCurve),
                        6 => ::core::result::Result::Ok(BallWeightOption::MagnusFutBall),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BallWeightOption> for u8 {
                #[inline]
                fn from(value: BallWeightOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BallWeightOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BallWeightOption> for BallWeightOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BallWeightOption> for BallWeightOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BallWeightOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BallWeightOption, BallWeightOption> for BallWeightOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BallWeightOption,
                ) -> ::core::option::Option<BallWeightOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BallWeightOption> for BallWeightOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BallWeightOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BallWeightOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BallWeightOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BallWeightOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BallWeightOption> for BallWeightOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BallSizeOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BallSizeOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:165`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BallSizeOption {
                /// The variant `Default` in the enum `BallSizeOption`
                Default = 0,

                /// The variant `Small` in the enum `BallSizeOption`
                Small = 1,

                /// The variant `Medium` in the enum `BallSizeOption`
                Medium = 2,

                /// The variant `Large` in the enum `BallSizeOption`
                Large = 3,

                /// The variant `Gigantic` in the enum `BallSizeOption`
                Gigantic = 4,
            }

            impl BallSizeOption {
                /// Array containing all valid variants of BallSizeOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::Default,
                    Self::Small,
                    Self::Medium,
                    Self::Large,
                    Self::Gigantic,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BallSizeOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BallSizeOption::Default),
                        1 => ::core::result::Result::Ok(BallSizeOption::Small),
                        2 => ::core::result::Result::Ok(BallSizeOption::Medium),
                        3 => ::core::result::Result::Ok(BallSizeOption::Large),
                        4 => ::core::result::Result::Ok(BallSizeOption::Gigantic),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BallSizeOption> for u8 {
                #[inline]
                fn from(value: BallSizeOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BallSizeOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BallSizeOption> for BallSizeOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BallSizeOption> for BallSizeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BallSizeOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BallSizeOption, BallSizeOption> for BallSizeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BallSizeOption,
                ) -> ::core::option::Option<BallSizeOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BallSizeOption> for BallSizeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BallSizeOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BallSizeOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BallSizeOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BallSizeOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BallSizeOption> for BallSizeOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BallBouncinessOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BallBouncinessOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:173`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BallBouncinessOption {
                /// The variant `Default` in the enum `BallBouncinessOption`
                Default = 0,

                /// The variant `Low` in the enum `BallBouncinessOption`
                Low = 1,

                /// The variant `High` in the enum `BallBouncinessOption`
                High = 2,

                /// The variant `Super_High` in the enum `BallBouncinessOption`
                SuperHigh = 3,

                /// The variant `LowishBounciness` in the enum `BallBouncinessOption`
                LowishBounciness = 4,
            }

            impl BallBouncinessOption {
                /// Array containing all valid variants of BallBouncinessOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::Default,
                    Self::Low,
                    Self::High,
                    Self::SuperHigh,
                    Self::LowishBounciness,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BallBouncinessOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BallBouncinessOption::Default),
                        1 => ::core::result::Result::Ok(BallBouncinessOption::Low),
                        2 => ::core::result::Result::Ok(BallBouncinessOption::High),
                        3 => ::core::result::Result::Ok(BallBouncinessOption::SuperHigh),
                        4 => ::core::result::Result::Ok(BallBouncinessOption::LowishBounciness),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BallBouncinessOption> for u8 {
                #[inline]
                fn from(value: BallBouncinessOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BallBouncinessOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BallBouncinessOption> for BallBouncinessOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BallBouncinessOption> for BallBouncinessOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BallBouncinessOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BallBouncinessOption, BallBouncinessOption> for BallBouncinessOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BallBouncinessOption,
                ) -> ::core::option::Option<BallBouncinessOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BallBouncinessOption> for BallBouncinessOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BallBouncinessOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BallBouncinessOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BallBouncinessOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BallBouncinessOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BallBouncinessOption> for BallBouncinessOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BoostOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BoostOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:181`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BoostOption {
                /// The variant `Normal_Boost` in the enum `BoostOption`
                NormalBoost = 0,

                /// The variant `Unlimited_Boost` in the enum `BoostOption`
                UnlimitedBoost = 1,

                /// The variant `Slow_Recharge` in the enum `BoostOption`
                SlowRecharge = 2,

                /// The variant `Rapid_Recharge` in the enum `BoostOption`
                RapidRecharge = 3,

                /// The variant `No_Boost` in the enum `BoostOption`
                NoBoost = 4,
            }

            impl BoostOption {
                /// Array containing all valid variants of BoostOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::NormalBoost,
                    Self::UnlimitedBoost,
                    Self::SlowRecharge,
                    Self::RapidRecharge,
                    Self::NoBoost,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BoostOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BoostOption::NormalBoost),
                        1 => ::core::result::Result::Ok(BoostOption::UnlimitedBoost),
                        2 => ::core::result::Result::Ok(BoostOption::SlowRecharge),
                        3 => ::core::result::Result::Ok(BoostOption::RapidRecharge),
                        4 => ::core::result::Result::Ok(BoostOption::NoBoost),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BoostOption> for u8 {
                #[inline]
                fn from(value: BoostOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BoostOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BoostOption> for BoostOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BoostOption> for BoostOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BoostOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BoostOption, BoostOption> for BoostOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BoostOption,
                ) -> ::core::option::Option<BoostOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BoostOption> for BoostOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BoostOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BoostOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BoostOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BoostOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BoostOption> for BoostOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `RumbleOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `RumbleOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:189`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum RumbleOption {
                /// The variant `No_Rumble` in the enum `RumbleOption`
                NoRumble = 0,

                /// The variant `Default` in the enum `RumbleOption`
                Default = 1,

                /// The variant `Slow` in the enum `RumbleOption`
                Slow = 2,

                /// The variant `Civilized` in the enum `RumbleOption`
                Civilized = 3,

                /// The variant `Destruction_Derby` in the enum `RumbleOption`
                DestructionDerby = 4,

                /// The variant `Spring_Loaded` in the enum `RumbleOption`
                SpringLoaded = 5,

                /// The variant `Spikes_Only` in the enum `RumbleOption`
                SpikesOnly = 6,

                /// The variant `Spike_Rush` in the enum `RumbleOption`
                SpikeRush = 7,

                /// The variant `Haunted_Ball_Beam` in the enum `RumbleOption`
                HauntedBallBeam = 8,

                /// The variant `Tactical` in the enum `RumbleOption`
                Tactical = 9,

                /// The variant `BatmanRumble` in the enum `RumbleOption`
                BatmanRumble = 10,
            }

            impl RumbleOption {
                /// Array containing all valid variants of RumbleOption
                pub const ENUM_VALUES: [Self; 11] = [
                    Self::NoRumble,
                    Self::Default,
                    Self::Slow,
                    Self::Civilized,
                    Self::DestructionDerby,
                    Self::SpringLoaded,
                    Self::SpikesOnly,
                    Self::SpikeRush,
                    Self::HauntedBallBeam,
                    Self::Tactical,
                    Self::BatmanRumble,
                ];
            }

            impl ::core::convert::TryFrom<u8> for RumbleOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(RumbleOption::NoRumble),
                        1 => ::core::result::Result::Ok(RumbleOption::Default),
                        2 => ::core::result::Result::Ok(RumbleOption::Slow),
                        3 => ::core::result::Result::Ok(RumbleOption::Civilized),
                        4 => ::core::result::Result::Ok(RumbleOption::DestructionDerby),
                        5 => ::core::result::Result::Ok(RumbleOption::SpringLoaded),
                        6 => ::core::result::Result::Ok(RumbleOption::SpikesOnly),
                        7 => ::core::result::Result::Ok(RumbleOption::SpikeRush),
                        8 => ::core::result::Result::Ok(RumbleOption::HauntedBallBeam),
                        9 => ::core::result::Result::Ok(RumbleOption::Tactical),
                        10 => ::core::result::Result::Ok(RumbleOption::BatmanRumble),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<RumbleOption> for u8 {
                #[inline]
                fn from(value: RumbleOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for RumbleOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<RumbleOption> for RumbleOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<RumbleOption> for RumbleOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> RumbleOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<RumbleOption, RumbleOption> for RumbleOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &RumbleOption,
                ) -> ::core::option::Option<RumbleOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<RumbleOption> for RumbleOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<RumbleOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for RumbleOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for RumbleOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "RumbleOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<RumbleOption> for RumbleOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `BoostStrengthOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `BoostStrengthOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:203`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum BoostStrengthOption {
                /// The variant `One` in the enum `BoostStrengthOption`
                One = 0,

                /// The variant `OneAndAHalf` in the enum `BoostStrengthOption`
                OneAndAHalf = 1,

                /// The variant `Two` in the enum `BoostStrengthOption`
                Two = 2,

                /// The variant `Five` in the enum `BoostStrengthOption`
                Five = 3,

                /// The variant `Ten` in the enum `BoostStrengthOption`
                Ten = 4,
            }

            impl BoostStrengthOption {
                /// Array containing all valid variants of BoostStrengthOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::One,
                    Self::OneAndAHalf,
                    Self::Two,
                    Self::Five,
                    Self::Ten,
                ];
            }

            impl ::core::convert::TryFrom<u8> for BoostStrengthOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(BoostStrengthOption::One),
                        1 => ::core::result::Result::Ok(BoostStrengthOption::OneAndAHalf),
                        2 => ::core::result::Result::Ok(BoostStrengthOption::Two),
                        3 => ::core::result::Result::Ok(BoostStrengthOption::Five),
                        4 => ::core::result::Result::Ok(BoostStrengthOption::Ten),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<BoostStrengthOption> for u8 {
                #[inline]
                fn from(value: BoostStrengthOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for BoostStrengthOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<BoostStrengthOption> for BoostStrengthOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<BoostStrengthOption> for BoostStrengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> BoostStrengthOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<BoostStrengthOption, BoostStrengthOption> for BoostStrengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &BoostStrengthOption,
                ) -> ::core::option::Option<BoostStrengthOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<BoostStrengthOption> for BoostStrengthOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<BoostStrengthOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for BoostStrengthOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for BoostStrengthOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "BoostStrengthOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<BoostStrengthOption> for BoostStrengthOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `GravityOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `GravityOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:211`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum GravityOption {
                /// The variant `Default` in the enum `GravityOption`
                Default = 0,

                /// The variant `Low` in the enum `GravityOption`
                Low = 1,

                /// The variant `High` in the enum `GravityOption`
                High = 2,

                /// The variant `Super_High` in the enum `GravityOption`
                SuperHigh = 3,

                /// The variant `Reverse` in the enum `GravityOption`
                Reverse = 4,
            }

            impl GravityOption {
                /// Array containing all valid variants of GravityOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::Default,
                    Self::Low,
                    Self::High,
                    Self::SuperHigh,
                    Self::Reverse,
                ];
            }

            impl ::core::convert::TryFrom<u8> for GravityOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(GravityOption::Default),
                        1 => ::core::result::Result::Ok(GravityOption::Low),
                        2 => ::core::result::Result::Ok(GravityOption::High),
                        3 => ::core::result::Result::Ok(GravityOption::SuperHigh),
                        4 => ::core::result::Result::Ok(GravityOption::Reverse),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<GravityOption> for u8 {
                #[inline]
                fn from(value: GravityOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for GravityOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<GravityOption> for GravityOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<GravityOption> for GravityOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> GravityOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<GravityOption, GravityOption> for GravityOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &GravityOption,
                ) -> ::core::option::Option<GravityOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<GravityOption> for GravityOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<GravityOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for GravityOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for GravityOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "GravityOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<GravityOption> for GravityOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `DemolishOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `DemolishOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:219`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum DemolishOption {
                /// The variant `Default` in the enum `DemolishOption`
                Default = 0,

                /// The variant `Disabled` in the enum `DemolishOption`
                Disabled = 1,

                /// The variant `Friendly_Fire` in the enum `DemolishOption`
                FriendlyFire = 2,

                /// The variant `On_Contact` in the enum `DemolishOption`
                OnContact = 3,

                /// The variant `On_Contact_FF` in the enum `DemolishOption`
                OnContactFf = 4,
            }

            impl DemolishOption {
                /// Array containing all valid variants of DemolishOption
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::Default,
                    Self::Disabled,
                    Self::FriendlyFire,
                    Self::OnContact,
                    Self::OnContactFf,
                ];
            }

            impl ::core::convert::TryFrom<u8> for DemolishOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(DemolishOption::Default),
                        1 => ::core::result::Result::Ok(DemolishOption::Disabled),
                        2 => ::core::result::Result::Ok(DemolishOption::FriendlyFire),
                        3 => ::core::result::Result::Ok(DemolishOption::OnContact),
                        4 => ::core::result::Result::Ok(DemolishOption::OnContactFf),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<DemolishOption> for u8 {
                #[inline]
                fn from(value: DemolishOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for DemolishOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<DemolishOption> for DemolishOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<DemolishOption> for DemolishOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> DemolishOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<DemolishOption, DemolishOption> for DemolishOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &DemolishOption,
                ) -> ::core::option::Option<DemolishOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<DemolishOption> for DemolishOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<DemolishOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for DemolishOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for DemolishOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "DemolishOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<DemolishOption> for DemolishOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `RespawnTimeOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `RespawnTimeOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:227`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum RespawnTimeOption {
                /// The variant `Three_Seconds` in the enum `RespawnTimeOption`
                ThreeSeconds = 0,

                /// The variant `Two_Seconds` in the enum `RespawnTimeOption`
                TwoSeconds = 1,

                /// The variant `One_Second` in the enum `RespawnTimeOption`
                OneSecond = 2,

                /// The variant `Disable_Goal_Reset` in the enum `RespawnTimeOption`
                DisableGoalReset = 3,
            }

            impl RespawnTimeOption {
                /// Array containing all valid variants of RespawnTimeOption
                pub const ENUM_VALUES: [Self; 4] = [
                    Self::ThreeSeconds,
                    Self::TwoSeconds,
                    Self::OneSecond,
                    Self::DisableGoalReset,
                ];
            }

            impl ::core::convert::TryFrom<u8> for RespawnTimeOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(RespawnTimeOption::ThreeSeconds),
                        1 => ::core::result::Result::Ok(RespawnTimeOption::TwoSeconds),
                        2 => ::core::result::Result::Ok(RespawnTimeOption::OneSecond),
                        3 => ::core::result::Result::Ok(RespawnTimeOption::DisableGoalReset),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<RespawnTimeOption> for u8 {
                #[inline]
                fn from(value: RespawnTimeOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for RespawnTimeOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<RespawnTimeOption> for RespawnTimeOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<RespawnTimeOption> for RespawnTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> RespawnTimeOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<RespawnTimeOption, RespawnTimeOption> for RespawnTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &RespawnTimeOption,
                ) -> ::core::option::Option<RespawnTimeOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<RespawnTimeOption> for RespawnTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<RespawnTimeOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for RespawnTimeOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for RespawnTimeOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "RespawnTimeOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<RespawnTimeOption> for RespawnTimeOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `MaxTimeOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `MaxTimeOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:234`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum MaxTimeOption {
                /// The variant `Default` in the enum `MaxTimeOption`
                Default = 0,

                /// The variant `Eleven_Minutes` in the enum `MaxTimeOption`
                ElevenMinutes = 1,
            }

            impl MaxTimeOption {
                /// Array containing all valid variants of MaxTimeOption
                pub const ENUM_VALUES: [Self; 2] = [Self::Default, Self::ElevenMinutes];
            }

            impl ::core::convert::TryFrom<u8> for MaxTimeOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(MaxTimeOption::Default),
                        1 => ::core::result::Result::Ok(MaxTimeOption::ElevenMinutes),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<MaxTimeOption> for u8 {
                #[inline]
                fn from(value: MaxTimeOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for MaxTimeOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<MaxTimeOption> for MaxTimeOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<MaxTimeOption> for MaxTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> MaxTimeOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<MaxTimeOption, MaxTimeOption> for MaxTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &MaxTimeOption,
                ) -> ::core::option::Option<MaxTimeOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<MaxTimeOption> for MaxTimeOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<MaxTimeOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for MaxTimeOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for MaxTimeOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "MaxTimeOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<MaxTimeOption> for MaxTimeOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `GameEventOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `GameEventOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:239`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum GameEventOption {
                /// The variant `Default` in the enum `GameEventOption`
                Default = 0,

                /// The variant `Haunted` in the enum `GameEventOption`
                Haunted = 1,

                /// The variant `Rugby` in the enum `GameEventOption`
                Rugby = 2,
            }

            impl GameEventOption {
                /// Array containing all valid variants of GameEventOption
                pub const ENUM_VALUES: [Self; 3] = [Self::Default, Self::Haunted, Self::Rugby];
            }

            impl ::core::convert::TryFrom<u8> for GameEventOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(GameEventOption::Default),
                        1 => ::core::result::Result::Ok(GameEventOption::Haunted),
                        2 => ::core::result::Result::Ok(GameEventOption::Rugby),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<GameEventOption> for u8 {
                #[inline]
                fn from(value: GameEventOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for GameEventOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<GameEventOption> for GameEventOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<GameEventOption> for GameEventOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> GameEventOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<GameEventOption, GameEventOption> for GameEventOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &GameEventOption,
                ) -> ::core::option::Option<GameEventOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<GameEventOption> for GameEventOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<GameEventOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for GameEventOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for GameEventOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "GameEventOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<GameEventOption> for GameEventOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `AudioOption` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `AudioOption` in the file `rlbot/flatbuffers-schema/matchstart.fbs:245`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum AudioOption {
                /// The variant `Default` in the enum `AudioOption`
                Default = 0,

                /// The variant `Haunted` in the enum `AudioOption`
                Haunted = 1,
            }

            impl AudioOption {
                /// Array containing all valid variants of AudioOption
                pub const ENUM_VALUES: [Self; 2] = [Self::Default, Self::Haunted];
            }

            impl ::core::convert::TryFrom<u8> for AudioOption {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(AudioOption::Default),
                        1 => ::core::result::Result::Ok(AudioOption::Haunted),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<AudioOption> for u8 {
                #[inline]
                fn from(value: AudioOption) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for AudioOption {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<AudioOption> for AudioOption {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<AudioOption> for AudioOption {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> AudioOption {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<AudioOption, AudioOption> for AudioOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &AudioOption,
                ) -> ::core::option::Option<AudioOption> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<AudioOption> for AudioOption {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<AudioOption> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for AudioOption {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for AudioOption {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "AudioOption",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<AudioOption> for AudioOption {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `MutatorSettings` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `MutatorSettings` in the file `rlbot/flatbuffers-schema/matchstart.fbs:250`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct MutatorSettings {
                /// The field `match_length` in the table `MutatorSettings`
                pub match_length: self::MatchLength,
                /// The field `max_score` in the table `MutatorSettings`
                pub max_score: self::MaxScore,
                /// The field `multi_ball` in the table `MutatorSettings`
                pub multi_ball: self::MultiBall,
                /// The field `overtime_option` in the table `MutatorSettings`
                pub overtime_option: self::OvertimeOption,
                /// The field `series_length_option` in the table `MutatorSettings`
                pub series_length_option: self::SeriesLengthOption,
                /// The field `game_speed_option` in the table `MutatorSettings`
                pub game_speed_option: self::GameSpeedOption,
                /// The field `ball_max_speed_option` in the table `MutatorSettings`
                pub ball_max_speed_option: self::BallMaxSpeedOption,
                /// The field `ball_type_option` in the table `MutatorSettings`
                pub ball_type_option: self::BallTypeOption,
                /// The field `ball_weight_option` in the table `MutatorSettings`
                pub ball_weight_option: self::BallWeightOption,
                /// The field `ball_size_option` in the table `MutatorSettings`
                pub ball_size_option: self::BallSizeOption,
                /// The field `ball_bounciness_option` in the table `MutatorSettings`
                pub ball_bounciness_option: self::BallBouncinessOption,
                /// The field `boost_option` in the table `MutatorSettings`
                pub boost_option: self::BoostOption,
                /// The field `rumble_option` in the table `MutatorSettings`
                pub rumble_option: self::RumbleOption,
                /// The field `boost_strength_option` in the table `MutatorSettings`
                pub boost_strength_option: self::BoostStrengthOption,
                /// The field `gravity_option` in the table `MutatorSettings`
                pub gravity_option: self::GravityOption,
                /// The field `demolish_option` in the table `MutatorSettings`
                pub demolish_option: self::DemolishOption,
                /// The field `respawn_time_option` in the table `MutatorSettings`
                pub respawn_time_option: self::RespawnTimeOption,
                /// The field `max_time_option` in the table `MutatorSettings`
                pub max_time_option: self::MaxTimeOption,
                /// The field `game_event_option` in the table `MutatorSettings`
                pub game_event_option: self::GameEventOption,
                /// The field `audio_option` in the table `MutatorSettings`
                pub audio_option: self::AudioOption,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for MutatorSettings {
                fn default() -> Self {
                    Self {
                        match_length: self::MatchLength::FiveMinutes,
                        max_score: self::MaxScore::Default,
                        multi_ball: self::MultiBall::One,
                        overtime_option: self::OvertimeOption::Unlimited,
                        series_length_option: self::SeriesLengthOption::Unlimited,
                        game_speed_option: self::GameSpeedOption::Default,
                        ball_max_speed_option: self::BallMaxSpeedOption::Default,
                        ball_type_option: self::BallTypeOption::Default,
                        ball_weight_option: self::BallWeightOption::Default,
                        ball_size_option: self::BallSizeOption::Default,
                        ball_bounciness_option: self::BallBouncinessOption::Default,
                        boost_option: self::BoostOption::NormalBoost,
                        rumble_option: self::RumbleOption::NoRumble,
                        boost_strength_option: self::BoostStrengthOption::One,
                        gravity_option: self::GravityOption::Default,
                        demolish_option: self::DemolishOption::Default,
                        respawn_time_option: self::RespawnTimeOption::ThreeSeconds,
                        max_time_option: self::MaxTimeOption::Default,
                        game_event_option: self::GameEventOption::Default,
                        audio_option: self::AudioOption::Default,
                    }
                }
            }

            impl MutatorSettings {
                /// Creates a [MutatorSettingsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> MutatorSettingsBuilder<()> {
                    MutatorSettingsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_match_length: impl ::planus::WriteAsDefault<
                        self::MatchLength,
                        self::MatchLength,
                    >,
                    field_max_score: impl ::planus::WriteAsDefault<self::MaxScore, self::MaxScore>,
                    field_multi_ball: impl ::planus::WriteAsDefault<self::MultiBall, self::MultiBall>,
                    field_overtime_option: impl ::planus::WriteAsDefault<
                        self::OvertimeOption,
                        self::OvertimeOption,
                    >,
                    field_series_length_option: impl ::planus::WriteAsDefault<
                        self::SeriesLengthOption,
                        self::SeriesLengthOption,
                    >,
                    field_game_speed_option: impl ::planus::WriteAsDefault<
                        self::GameSpeedOption,
                        self::GameSpeedOption,
                    >,
                    field_ball_max_speed_option: impl ::planus::WriteAsDefault<
                        self::BallMaxSpeedOption,
                        self::BallMaxSpeedOption,
                    >,
                    field_ball_type_option: impl ::planus::WriteAsDefault<
                        self::BallTypeOption,
                        self::BallTypeOption,
                    >,
                    field_ball_weight_option: impl ::planus::WriteAsDefault<
                        self::BallWeightOption,
                        self::BallWeightOption,
                    >,
                    field_ball_size_option: impl ::planus::WriteAsDefault<
                        self::BallSizeOption,
                        self::BallSizeOption,
                    >,
                    field_ball_bounciness_option: impl ::planus::WriteAsDefault<
                        self::BallBouncinessOption,
                        self::BallBouncinessOption,
                    >,
                    field_boost_option: impl ::planus::WriteAsDefault<
                        self::BoostOption,
                        self::BoostOption,
                    >,
                    field_rumble_option: impl ::planus::WriteAsDefault<
                        self::RumbleOption,
                        self::RumbleOption,
                    >,
                    field_boost_strength_option: impl ::planus::WriteAsDefault<
                        self::BoostStrengthOption,
                        self::BoostStrengthOption,
                    >,
                    field_gravity_option: impl ::planus::WriteAsDefault<
                        self::GravityOption,
                        self::GravityOption,
                    >,
                    field_demolish_option: impl ::planus::WriteAsDefault<
                        self::DemolishOption,
                        self::DemolishOption,
                    >,
                    field_respawn_time_option: impl ::planus::WriteAsDefault<
                        self::RespawnTimeOption,
                        self::RespawnTimeOption,
                    >,
                    field_max_time_option: impl ::planus::WriteAsDefault<
                        self::MaxTimeOption,
                        self::MaxTimeOption,
                    >,
                    field_game_event_option: impl ::planus::WriteAsDefault<
                        self::GameEventOption,
                        self::GameEventOption,
                    >,
                    field_audio_option: impl ::planus::WriteAsDefault<
                        self::AudioOption,
                        self::AudioOption,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_match_length =
                        field_match_length.prepare(builder, &self::MatchLength::FiveMinutes);
                    let prepared_max_score =
                        field_max_score.prepare(builder, &self::MaxScore::Default);
                    let prepared_multi_ball =
                        field_multi_ball.prepare(builder, &self::MultiBall::One);
                    let prepared_overtime_option =
                        field_overtime_option.prepare(builder, &self::OvertimeOption::Unlimited);
                    let prepared_series_length_option = field_series_length_option
                        .prepare(builder, &self::SeriesLengthOption::Unlimited);
                    let prepared_game_speed_option =
                        field_game_speed_option.prepare(builder, &self::GameSpeedOption::Default);
                    let prepared_ball_max_speed_option = field_ball_max_speed_option
                        .prepare(builder, &self::BallMaxSpeedOption::Default);
                    let prepared_ball_type_option =
                        field_ball_type_option.prepare(builder, &self::BallTypeOption::Default);
                    let prepared_ball_weight_option =
                        field_ball_weight_option.prepare(builder, &self::BallWeightOption::Default);
                    let prepared_ball_size_option =
                        field_ball_size_option.prepare(builder, &self::BallSizeOption::Default);
                    let prepared_ball_bounciness_option = field_ball_bounciness_option
                        .prepare(builder, &self::BallBouncinessOption::Default);
                    let prepared_boost_option =
                        field_boost_option.prepare(builder, &self::BoostOption::NormalBoost);
                    let prepared_rumble_option =
                        field_rumble_option.prepare(builder, &self::RumbleOption::NoRumble);
                    let prepared_boost_strength_option = field_boost_strength_option
                        .prepare(builder, &self::BoostStrengthOption::One);
                    let prepared_gravity_option =
                        field_gravity_option.prepare(builder, &self::GravityOption::Default);
                    let prepared_demolish_option =
                        field_demolish_option.prepare(builder, &self::DemolishOption::Default);
                    let prepared_respawn_time_option = field_respawn_time_option
                        .prepare(builder, &self::RespawnTimeOption::ThreeSeconds);
                    let prepared_max_time_option =
                        field_max_time_option.prepare(builder, &self::MaxTimeOption::Default);
                    let prepared_game_event_option =
                        field_game_event_option.prepare(builder, &self::GameEventOption::Default);
                    let prepared_audio_option =
                        field_audio_option.prepare(builder, &self::AudioOption::Default);

                    let mut table_writer: ::planus::table_writer::TableWriter<44> =
                        ::core::default::Default::default();
                    if prepared_match_length.is_some() {
                        table_writer.write_entry::<self::MatchLength>(0);
                    }
                    if prepared_max_score.is_some() {
                        table_writer.write_entry::<self::MaxScore>(1);
                    }
                    if prepared_multi_ball.is_some() {
                        table_writer.write_entry::<self::MultiBall>(2);
                    }
                    if prepared_overtime_option.is_some() {
                        table_writer.write_entry::<self::OvertimeOption>(3);
                    }
                    if prepared_series_length_option.is_some() {
                        table_writer.write_entry::<self::SeriesLengthOption>(4);
                    }
                    if prepared_game_speed_option.is_some() {
                        table_writer.write_entry::<self::GameSpeedOption>(5);
                    }
                    if prepared_ball_max_speed_option.is_some() {
                        table_writer.write_entry::<self::BallMaxSpeedOption>(6);
                    }
                    if prepared_ball_type_option.is_some() {
                        table_writer.write_entry::<self::BallTypeOption>(7);
                    }
                    if prepared_ball_weight_option.is_some() {
                        table_writer.write_entry::<self::BallWeightOption>(8);
                    }
                    if prepared_ball_size_option.is_some() {
                        table_writer.write_entry::<self::BallSizeOption>(9);
                    }
                    if prepared_ball_bounciness_option.is_some() {
                        table_writer.write_entry::<self::BallBouncinessOption>(10);
                    }
                    if prepared_boost_option.is_some() {
                        table_writer.write_entry::<self::BoostOption>(11);
                    }
                    if prepared_rumble_option.is_some() {
                        table_writer.write_entry::<self::RumbleOption>(12);
                    }
                    if prepared_boost_strength_option.is_some() {
                        table_writer.write_entry::<self::BoostStrengthOption>(13);
                    }
                    if prepared_gravity_option.is_some() {
                        table_writer.write_entry::<self::GravityOption>(14);
                    }
                    if prepared_demolish_option.is_some() {
                        table_writer.write_entry::<self::DemolishOption>(15);
                    }
                    if prepared_respawn_time_option.is_some() {
                        table_writer.write_entry::<self::RespawnTimeOption>(16);
                    }
                    if prepared_max_time_option.is_some() {
                        table_writer.write_entry::<self::MaxTimeOption>(17);
                    }
                    if prepared_game_event_option.is_some() {
                        table_writer.write_entry::<self::GameEventOption>(18);
                    }
                    if prepared_audio_option.is_some() {
                        table_writer.write_entry::<self::AudioOption>(19);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_match_length) =
                                prepared_match_length
                            {
                                object_writer.write::<_, _, 1>(&prepared_match_length);
                            }
                            if let ::core::option::Option::Some(prepared_max_score) =
                                prepared_max_score
                            {
                                object_writer.write::<_, _, 1>(&prepared_max_score);
                            }
                            if let ::core::option::Option::Some(prepared_multi_ball) =
                                prepared_multi_ball
                            {
                                object_writer.write::<_, _, 1>(&prepared_multi_ball);
                            }
                            if let ::core::option::Option::Some(prepared_overtime_option) =
                                prepared_overtime_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_overtime_option);
                            }
                            if let ::core::option::Option::Some(prepared_series_length_option) =
                                prepared_series_length_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_series_length_option);
                            }
                            if let ::core::option::Option::Some(prepared_game_speed_option) =
                                prepared_game_speed_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_game_speed_option);
                            }
                            if let ::core::option::Option::Some(prepared_ball_max_speed_option) =
                                prepared_ball_max_speed_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_ball_max_speed_option);
                            }
                            if let ::core::option::Option::Some(prepared_ball_type_option) =
                                prepared_ball_type_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_ball_type_option);
                            }
                            if let ::core::option::Option::Some(prepared_ball_weight_option) =
                                prepared_ball_weight_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_ball_weight_option);
                            }
                            if let ::core::option::Option::Some(prepared_ball_size_option) =
                                prepared_ball_size_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_ball_size_option);
                            }
                            if let ::core::option::Option::Some(prepared_ball_bounciness_option) =
                                prepared_ball_bounciness_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_ball_bounciness_option);
                            }
                            if let ::core::option::Option::Some(prepared_boost_option) =
                                prepared_boost_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_boost_option);
                            }
                            if let ::core::option::Option::Some(prepared_rumble_option) =
                                prepared_rumble_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_rumble_option);
                            }
                            if let ::core::option::Option::Some(prepared_boost_strength_option) =
                                prepared_boost_strength_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_boost_strength_option);
                            }
                            if let ::core::option::Option::Some(prepared_gravity_option) =
                                prepared_gravity_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_gravity_option);
                            }
                            if let ::core::option::Option::Some(prepared_demolish_option) =
                                prepared_demolish_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_demolish_option);
                            }
                            if let ::core::option::Option::Some(prepared_respawn_time_option) =
                                prepared_respawn_time_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_respawn_time_option);
                            }
                            if let ::core::option::Option::Some(prepared_max_time_option) =
                                prepared_max_time_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_max_time_option);
                            }
                            if let ::core::option::Option::Some(prepared_game_event_option) =
                                prepared_game_event_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_game_event_option);
                            }
                            if let ::core::option::Option::Some(prepared_audio_option) =
                                prepared_audio_option
                            {
                                object_writer.write::<_, _, 1>(&prepared_audio_option);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<MutatorSettings>> for MutatorSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MutatorSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<MutatorSettings>> for MutatorSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MutatorSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<MutatorSettings> for MutatorSettings {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MutatorSettings> {
                    MutatorSettings::create(
                        builder,
                        self.match_length,
                        self.max_score,
                        self.multi_ball,
                        self.overtime_option,
                        self.series_length_option,
                        self.game_speed_option,
                        self.ball_max_speed_option,
                        self.ball_type_option,
                        self.ball_weight_option,
                        self.ball_size_option,
                        self.ball_bounciness_option,
                        self.boost_option,
                        self.rumble_option,
                        self.boost_strength_option,
                        self.gravity_option,
                        self.demolish_option,
                        self.respawn_time_option,
                        self.max_time_option,
                        self.game_event_option,
                        self.audio_option,
                    )
                }
            }

            /// Builder for serializing an instance of the [MutatorSettings] type.
            ///
            /// Can be created using the [MutatorSettings::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct MutatorSettingsBuilder<State>(State);

            impl MutatorSettingsBuilder<()> {
                /// Setter for the [`match_length` field](MutatorSettings#structfield.match_length).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn match_length<T0>(self, value: T0) -> MutatorSettingsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::MatchLength, self::MatchLength>,
                {
                    MutatorSettingsBuilder((value,))
                }

                /// Sets the [`match_length` field](MutatorSettings#structfield.match_length) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn match_length_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(::planus::DefaultValue,)> {
                    self.match_length(::planus::DefaultValue)
                }
            }

            impl<T0> MutatorSettingsBuilder<(T0,)> {
                /// Setter for the [`max_score` field](MutatorSettings#structfield.max_score).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_score<T1>(self, value: T1) -> MutatorSettingsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<self::MaxScore, self::MaxScore>,
                {
                    let (v0,) = self.0;
                    MutatorSettingsBuilder((v0, value))
                }

                /// Sets the [`max_score` field](MutatorSettings#structfield.max_score) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_score_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, ::planus::DefaultValue)> {
                    self.max_score(::planus::DefaultValue)
                }
            }

            impl<T0, T1> MutatorSettingsBuilder<(T0, T1)> {
                /// Setter for the [`multi_ball` field](MutatorSettings#structfield.multi_ball).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn multi_ball<T2>(self, value: T2) -> MutatorSettingsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<self::MultiBall, self::MultiBall>,
                {
                    let (v0, v1) = self.0;
                    MutatorSettingsBuilder((v0, v1, value))
                }

                /// Sets the [`multi_ball` field](MutatorSettings#structfield.multi_ball) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn multi_ball_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.multi_ball(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> MutatorSettingsBuilder<(T0, T1, T2)> {
                /// Setter for the [`overtime_option` field](MutatorSettings#structfield.overtime_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn overtime_option<T3>(
                    self,
                    value: T3,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<self::OvertimeOption, self::OvertimeOption>,
                {
                    let (v0, v1, v2) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`overtime_option` field](MutatorSettings#structfield.overtime_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn overtime_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.overtime_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> MutatorSettingsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`series_length_option` field](MutatorSettings#structfield.series_length_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn series_length_option<T4>(
                    self,
                    value: T4,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<
                        self::SeriesLengthOption,
                        self::SeriesLengthOption,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`series_length_option` field](MutatorSettings#structfield.series_length_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn series_length_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)>
                {
                    self.series_length_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> MutatorSettingsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`game_speed_option` field](MutatorSettings#structfield.game_speed_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed_option<T5>(
                    self,
                    value: T5,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<self::GameSpeedOption, self::GameSpeedOption>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`game_speed_option` field](MutatorSettings#structfield.game_speed_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.game_speed_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`ball_max_speed_option` field](MutatorSettings#structfield.ball_max_speed_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_max_speed_option<T6>(
                    self,
                    value: T6,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<
                        self::BallMaxSpeedOption,
                        self::BallMaxSpeedOption,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`ball_max_speed_option` field](MutatorSettings#structfield.ball_max_speed_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_max_speed_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.ball_max_speed_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`ball_type_option` field](MutatorSettings#structfield.ball_type_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_type_option<T7>(
                    self,
                    value: T7,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<self::BallTypeOption, self::BallTypeOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`ball_type_option` field](MutatorSettings#structfield.ball_type_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_type_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.ball_type_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`ball_weight_option` field](MutatorSettings#structfield.ball_weight_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_weight_option<T8>(
                    self,
                    value: T8,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<self::BallWeightOption, self::BallWeightOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`ball_weight_option` field](MutatorSettings#structfield.ball_weight_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_weight_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.ball_weight_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Setter for the [`ball_size_option` field](MutatorSettings#structfield.ball_size_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_size_option<T9>(
                    self,
                    value: T9,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<self::BallSizeOption, self::BallSizeOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`ball_size_option` field](MutatorSettings#structfield.ball_size_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_size_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    ::planus::DefaultValue,
                )> {
                    self.ball_size_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`ball_bounciness_option` field](MutatorSettings#structfield.ball_bounciness_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_bounciness_option<T10>(
                    self,
                    value: T10,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<
                        self::BallBouncinessOption,
                        self::BallBouncinessOption,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`ball_bounciness_option` field](MutatorSettings#structfield.ball_bounciness_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_bounciness_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.ball_bounciness_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`boost_option` field](MutatorSettings#structfield.boost_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_option<T11>(
                    self,
                    value: T11,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<self::BoostOption, self::BoostOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    MutatorSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`boost_option` field](MutatorSettings#structfield.boost_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.boost_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`rumble_option` field](MutatorSettings#structfield.rumble_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rumble_option<T12>(
                    self,
                    value: T12,
                ) -> MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<self::RumbleOption, self::RumbleOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value,
                    ))
                }

                /// Sets the [`rumble_option` field](MutatorSettings#structfield.rumble_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn rumble_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.rumble_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`boost_strength_option` field](MutatorSettings#structfield.boost_strength_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_strength_option<T13>(
                    self,
                    value: T13,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                )>
                where
                    T13: ::planus::WriteAsDefault<
                        self::BoostStrengthOption,
                        self::BoostStrengthOption,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value,
                    ))
                }

                /// Sets the [`boost_strength_option` field](MutatorSettings#structfield.boost_strength_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_strength_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.boost_strength_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                MutatorSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`gravity_option` field](MutatorSettings#structfield.gravity_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn gravity_option<T14>(
                    self,
                    value: T14,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsDefault<self::GravityOption, self::GravityOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`gravity_option` field](MutatorSettings#structfield.gravity_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn gravity_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    ::planus::DefaultValue,
                )> {
                    self.gravity_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`demolish_option` field](MutatorSettings#structfield.demolish_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn demolish_option<T15>(
                    self,
                    value: T15,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAsDefault<self::DemolishOption, self::DemolishOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }

                /// Sets the [`demolish_option` field](MutatorSettings#structfield.demolish_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn demolish_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    ::planus::DefaultValue,
                )> {
                    self.demolish_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Setter for the [`respawn_time_option` field](MutatorSettings#structfield.respawn_time_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn respawn_time_option<T16>(
                    self,
                    value: T16,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
                where
                    T16: ::planus::WriteAsDefault<self::RespawnTimeOption, self::RespawnTimeOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, value,
                    ))
                }

                /// Sets the [`respawn_time_option` field](MutatorSettings#structfield.respawn_time_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn respawn_time_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    ::planus::DefaultValue,
                )> {
                    self.respawn_time_option(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
            {
                /// Setter for the [`max_time_option` field](MutatorSettings#structfield.max_time_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_time_option<T17>(
                    self,
                    value: T17,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
                where
                    T17: ::planus::WriteAsDefault<self::MaxTimeOption, self::MaxTimeOption>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) =
                        self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        value,
                    ))
                }

                /// Sets the [`max_time_option` field](MutatorSettings#structfield.max_time_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn max_time_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    ::planus::DefaultValue,
                )> {
                    self.max_time_option(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                >
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                /// Setter for the [`game_event_option` field](MutatorSettings#structfield.game_event_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_event_option<T18>(
                    self,
                    value: T18,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
                where
                    T18: ::planus::WriteAsDefault<self::GameEventOption, self::GameEventOption>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                    ) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, value,
                    ))
                }

                /// Sets the [`game_event_option` field](MutatorSettings#structfield.game_event_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_event_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    ::planus::DefaultValue,
                )> {
                    self.game_event_option(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                >
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
            {
                /// Setter for the [`audio_option` field](MutatorSettings#structfield.audio_option).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn audio_option<T19>(
                    self,
                    value: T19,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
                where
                    T19: ::planus::WriteAsDefault<self::AudioOption, self::AudioOption>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                    ) = self.0;
                    MutatorSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, value,
                    ))
                }

                /// Sets the [`audio_option` field](MutatorSettings#structfield.audio_option) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn audio_option_as_default(
                    self,
                ) -> MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    ::planus::DefaultValue,
                )> {
                    self.audio_option(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                >
                MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [MutatorSettings].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MutatorSettings>
                where
                    Self: ::planus::WriteAsOffset<MutatorSettings>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::MatchLength, self::MatchLength>,
                    T1: ::planus::WriteAsDefault<self::MaxScore, self::MaxScore>,
                    T2: ::planus::WriteAsDefault<self::MultiBall, self::MultiBall>,
                    T3: ::planus::WriteAsDefault<self::OvertimeOption, self::OvertimeOption>,
                    T4: ::planus::WriteAsDefault<self::SeriesLengthOption, self::SeriesLengthOption>,
                    T5: ::planus::WriteAsDefault<self::GameSpeedOption, self::GameSpeedOption>,
                    T6: ::planus::WriteAsDefault<self::BallMaxSpeedOption, self::BallMaxSpeedOption>,
                    T7: ::planus::WriteAsDefault<self::BallTypeOption, self::BallTypeOption>,
                    T8: ::planus::WriteAsDefault<self::BallWeightOption, self::BallWeightOption>,
                    T9: ::planus::WriteAsDefault<self::BallSizeOption, self::BallSizeOption>,
                    T10: ::planus::WriteAsDefault<
                        self::BallBouncinessOption,
                        self::BallBouncinessOption,
                    >,
                    T11: ::planus::WriteAsDefault<self::BoostOption, self::BoostOption>,
                    T12: ::planus::WriteAsDefault<self::RumbleOption, self::RumbleOption>,
                    T13: ::planus::WriteAsDefault<self::BoostStrengthOption, self::BoostStrengthOption>,
                    T14: ::planus::WriteAsDefault<self::GravityOption, self::GravityOption>,
                    T15: ::planus::WriteAsDefault<self::DemolishOption, self::DemolishOption>,
                    T16: ::planus::WriteAsDefault<self::RespawnTimeOption, self::RespawnTimeOption>,
                    T17: ::planus::WriteAsDefault<self::MaxTimeOption, self::MaxTimeOption>,
                    T18: ::planus::WriteAsDefault<self::GameEventOption, self::GameEventOption>,
                    T19: ::planus::WriteAsDefault<self::AudioOption, self::AudioOption>,
                > ::planus::WriteAs<::planus::Offset<MutatorSettings>>
                for MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                type Prepared = ::planus::Offset<MutatorSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MutatorSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::MatchLength, self::MatchLength>,
                    T1: ::planus::WriteAsDefault<self::MaxScore, self::MaxScore>,
                    T2: ::planus::WriteAsDefault<self::MultiBall, self::MultiBall>,
                    T3: ::planus::WriteAsDefault<self::OvertimeOption, self::OvertimeOption>,
                    T4: ::planus::WriteAsDefault<self::SeriesLengthOption, self::SeriesLengthOption>,
                    T5: ::planus::WriteAsDefault<self::GameSpeedOption, self::GameSpeedOption>,
                    T6: ::planus::WriteAsDefault<self::BallMaxSpeedOption, self::BallMaxSpeedOption>,
                    T7: ::planus::WriteAsDefault<self::BallTypeOption, self::BallTypeOption>,
                    T8: ::planus::WriteAsDefault<self::BallWeightOption, self::BallWeightOption>,
                    T9: ::planus::WriteAsDefault<self::BallSizeOption, self::BallSizeOption>,
                    T10: ::planus::WriteAsDefault<
                        self::BallBouncinessOption,
                        self::BallBouncinessOption,
                    >,
                    T11: ::planus::WriteAsDefault<self::BoostOption, self::BoostOption>,
                    T12: ::planus::WriteAsDefault<self::RumbleOption, self::RumbleOption>,
                    T13: ::planus::WriteAsDefault<self::BoostStrengthOption, self::BoostStrengthOption>,
                    T14: ::planus::WriteAsDefault<self::GravityOption, self::GravityOption>,
                    T15: ::planus::WriteAsDefault<self::DemolishOption, self::DemolishOption>,
                    T16: ::planus::WriteAsDefault<self::RespawnTimeOption, self::RespawnTimeOption>,
                    T17: ::planus::WriteAsDefault<self::MaxTimeOption, self::MaxTimeOption>,
                    T18: ::planus::WriteAsDefault<self::GameEventOption, self::GameEventOption>,
                    T19: ::planus::WriteAsDefault<self::AudioOption, self::AudioOption>,
                > ::planus::WriteAsOptional<::planus::Offset<MutatorSettings>>
                for MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                type Prepared = ::planus::Offset<MutatorSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MutatorSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::MatchLength, self::MatchLength>,
                    T1: ::planus::WriteAsDefault<self::MaxScore, self::MaxScore>,
                    T2: ::planus::WriteAsDefault<self::MultiBall, self::MultiBall>,
                    T3: ::planus::WriteAsDefault<self::OvertimeOption, self::OvertimeOption>,
                    T4: ::planus::WriteAsDefault<self::SeriesLengthOption, self::SeriesLengthOption>,
                    T5: ::planus::WriteAsDefault<self::GameSpeedOption, self::GameSpeedOption>,
                    T6: ::planus::WriteAsDefault<self::BallMaxSpeedOption, self::BallMaxSpeedOption>,
                    T7: ::planus::WriteAsDefault<self::BallTypeOption, self::BallTypeOption>,
                    T8: ::planus::WriteAsDefault<self::BallWeightOption, self::BallWeightOption>,
                    T9: ::planus::WriteAsDefault<self::BallSizeOption, self::BallSizeOption>,
                    T10: ::planus::WriteAsDefault<
                        self::BallBouncinessOption,
                        self::BallBouncinessOption,
                    >,
                    T11: ::planus::WriteAsDefault<self::BoostOption, self::BoostOption>,
                    T12: ::planus::WriteAsDefault<self::RumbleOption, self::RumbleOption>,
                    T13: ::planus::WriteAsDefault<self::BoostStrengthOption, self::BoostStrengthOption>,
                    T14: ::planus::WriteAsDefault<self::GravityOption, self::GravityOption>,
                    T15: ::planus::WriteAsDefault<self::DemolishOption, self::DemolishOption>,
                    T16: ::planus::WriteAsDefault<self::RespawnTimeOption, self::RespawnTimeOption>,
                    T17: ::planus::WriteAsDefault<self::MaxTimeOption, self::MaxTimeOption>,
                    T18: ::planus::WriteAsDefault<self::GameEventOption, self::GameEventOption>,
                    T19: ::planus::WriteAsDefault<self::AudioOption, self::AudioOption>,
                > ::planus::WriteAsOffset<MutatorSettings>
                for MutatorSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MutatorSettings> {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                    ) = &self.0;
                    MutatorSettings::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15, v16, v17, v18, v19,
                    )
                }
            }

            /// Reference to a deserialized [MutatorSettings].
            #[derive(Copy, Clone)]
            pub struct MutatorSettingsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MutatorSettingsRef<'a> {
                /// Getter for the [`match_length` field](MutatorSettings#structfield.match_length).
                #[inline]
                pub fn match_length(&self) -> ::planus::Result<self::MatchLength> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "MutatorSettings", "match_length")?
                            .unwrap_or(self::MatchLength::FiveMinutes),
                    )
                }

                /// Getter for the [`max_score` field](MutatorSettings#structfield.max_score).
                #[inline]
                pub fn max_score(&self) -> ::planus::Result<self::MaxScore> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "MutatorSettings", "max_score")?
                            .unwrap_or(self::MaxScore::Default),
                    )
                }

                /// Getter for the [`multi_ball` field](MutatorSettings#structfield.multi_ball).
                #[inline]
                pub fn multi_ball(&self) -> ::planus::Result<self::MultiBall> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "MutatorSettings", "multi_ball")?
                            .unwrap_or(self::MultiBall::One),
                    )
                }

                /// Getter for the [`overtime_option` field](MutatorSettings#structfield.overtime_option).
                #[inline]
                pub fn overtime_option(&self) -> ::planus::Result<self::OvertimeOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "MutatorSettings", "overtime_option")?
                            .unwrap_or(self::OvertimeOption::Unlimited),
                    )
                }

                /// Getter for the [`series_length_option` field](MutatorSettings#structfield.series_length_option).
                #[inline]
                pub fn series_length_option(&self) -> ::planus::Result<self::SeriesLengthOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "MutatorSettings", "series_length_option")?
                            .unwrap_or(self::SeriesLengthOption::Unlimited),
                    )
                }

                /// Getter for the [`game_speed_option` field](MutatorSettings#structfield.game_speed_option).
                #[inline]
                pub fn game_speed_option(&self) -> ::planus::Result<self::GameSpeedOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "MutatorSettings", "game_speed_option")?
                            .unwrap_or(self::GameSpeedOption::Default),
                    )
                }

                /// Getter for the [`ball_max_speed_option` field](MutatorSettings#structfield.ball_max_speed_option).
                #[inline]
                pub fn ball_max_speed_option(&self) -> ::planus::Result<self::BallMaxSpeedOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "MutatorSettings", "ball_max_speed_option")?
                            .unwrap_or(self::BallMaxSpeedOption::Default),
                    )
                }

                /// Getter for the [`ball_type_option` field](MutatorSettings#structfield.ball_type_option).
                #[inline]
                pub fn ball_type_option(&self) -> ::planus::Result<self::BallTypeOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "MutatorSettings", "ball_type_option")?
                            .unwrap_or(self::BallTypeOption::Default),
                    )
                }

                /// Getter for the [`ball_weight_option` field](MutatorSettings#structfield.ball_weight_option).
                #[inline]
                pub fn ball_weight_option(&self) -> ::planus::Result<self::BallWeightOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "MutatorSettings", "ball_weight_option")?
                            .unwrap_or(self::BallWeightOption::Default),
                    )
                }

                /// Getter for the [`ball_size_option` field](MutatorSettings#structfield.ball_size_option).
                #[inline]
                pub fn ball_size_option(&self) -> ::planus::Result<self::BallSizeOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(9, "MutatorSettings", "ball_size_option")?
                            .unwrap_or(self::BallSizeOption::Default),
                    )
                }

                /// Getter for the [`ball_bounciness_option` field](MutatorSettings#structfield.ball_bounciness_option).
                #[inline]
                pub fn ball_bounciness_option(
                    &self,
                ) -> ::planus::Result<self::BallBouncinessOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "MutatorSettings", "ball_bounciness_option")?
                            .unwrap_or(self::BallBouncinessOption::Default),
                    )
                }

                /// Getter for the [`boost_option` field](MutatorSettings#structfield.boost_option).
                #[inline]
                pub fn boost_option(&self) -> ::planus::Result<self::BoostOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "MutatorSettings", "boost_option")?
                            .unwrap_or(self::BoostOption::NormalBoost),
                    )
                }

                /// Getter for the [`rumble_option` field](MutatorSettings#structfield.rumble_option).
                #[inline]
                pub fn rumble_option(&self) -> ::planus::Result<self::RumbleOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "MutatorSettings", "rumble_option")?
                            .unwrap_or(self::RumbleOption::NoRumble),
                    )
                }

                /// Getter for the [`boost_strength_option` field](MutatorSettings#structfield.boost_strength_option).
                #[inline]
                pub fn boost_strength_option(&self) -> ::planus::Result<self::BoostStrengthOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(13, "MutatorSettings", "boost_strength_option")?
                            .unwrap_or(self::BoostStrengthOption::One),
                    )
                }

                /// Getter for the [`gravity_option` field](MutatorSettings#structfield.gravity_option).
                #[inline]
                pub fn gravity_option(&self) -> ::planus::Result<self::GravityOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(14, "MutatorSettings", "gravity_option")?
                            .unwrap_or(self::GravityOption::Default),
                    )
                }

                /// Getter for the [`demolish_option` field](MutatorSettings#structfield.demolish_option).
                #[inline]
                pub fn demolish_option(&self) -> ::planus::Result<self::DemolishOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(15, "MutatorSettings", "demolish_option")?
                            .unwrap_or(self::DemolishOption::Default),
                    )
                }

                /// Getter for the [`respawn_time_option` field](MutatorSettings#structfield.respawn_time_option).
                #[inline]
                pub fn respawn_time_option(&self) -> ::planus::Result<self::RespawnTimeOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "MutatorSettings", "respawn_time_option")?
                            .unwrap_or(self::RespawnTimeOption::ThreeSeconds),
                    )
                }

                /// Getter for the [`max_time_option` field](MutatorSettings#structfield.max_time_option).
                #[inline]
                pub fn max_time_option(&self) -> ::planus::Result<self::MaxTimeOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(17, "MutatorSettings", "max_time_option")?
                            .unwrap_or(self::MaxTimeOption::Default),
                    )
                }

                /// Getter for the [`game_event_option` field](MutatorSettings#structfield.game_event_option).
                #[inline]
                pub fn game_event_option(&self) -> ::planus::Result<self::GameEventOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(18, "MutatorSettings", "game_event_option")?
                            .unwrap_or(self::GameEventOption::Default),
                    )
                }

                /// Getter for the [`audio_option` field](MutatorSettings#structfield.audio_option).
                #[inline]
                pub fn audio_option(&self) -> ::planus::Result<self::AudioOption> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(19, "MutatorSettings", "audio_option")?
                            .unwrap_or(self::AudioOption::Default),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for MutatorSettingsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MutatorSettingsRef");
                    f.field("match_length", &self.match_length());
                    f.field("max_score", &self.max_score());
                    f.field("multi_ball", &self.multi_ball());
                    f.field("overtime_option", &self.overtime_option());
                    f.field("series_length_option", &self.series_length_option());
                    f.field("game_speed_option", &self.game_speed_option());
                    f.field("ball_max_speed_option", &self.ball_max_speed_option());
                    f.field("ball_type_option", &self.ball_type_option());
                    f.field("ball_weight_option", &self.ball_weight_option());
                    f.field("ball_size_option", &self.ball_size_option());
                    f.field("ball_bounciness_option", &self.ball_bounciness_option());
                    f.field("boost_option", &self.boost_option());
                    f.field("rumble_option", &self.rumble_option());
                    f.field("boost_strength_option", &self.boost_strength_option());
                    f.field("gravity_option", &self.gravity_option());
                    f.field("demolish_option", &self.demolish_option());
                    f.field("respawn_time_option", &self.respawn_time_option());
                    f.field("max_time_option", &self.max_time_option());
                    f.field("game_event_option", &self.game_event_option());
                    f.field("audio_option", &self.audio_option());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MutatorSettingsRef<'a>> for MutatorSettings {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MutatorSettingsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        match_length: ::core::convert::TryInto::try_into(value.match_length()?)?,
                        max_score: ::core::convert::TryInto::try_into(value.max_score()?)?,
                        multi_ball: ::core::convert::TryInto::try_into(value.multi_ball()?)?,
                        overtime_option: ::core::convert::TryInto::try_into(
                            value.overtime_option()?,
                        )?,
                        series_length_option: ::core::convert::TryInto::try_into(
                            value.series_length_option()?,
                        )?,
                        game_speed_option: ::core::convert::TryInto::try_into(
                            value.game_speed_option()?,
                        )?,
                        ball_max_speed_option: ::core::convert::TryInto::try_into(
                            value.ball_max_speed_option()?,
                        )?,
                        ball_type_option: ::core::convert::TryInto::try_into(
                            value.ball_type_option()?,
                        )?,
                        ball_weight_option: ::core::convert::TryInto::try_into(
                            value.ball_weight_option()?,
                        )?,
                        ball_size_option: ::core::convert::TryInto::try_into(
                            value.ball_size_option()?,
                        )?,
                        ball_bounciness_option: ::core::convert::TryInto::try_into(
                            value.ball_bounciness_option()?,
                        )?,
                        boost_option: ::core::convert::TryInto::try_into(value.boost_option()?)?,
                        rumble_option: ::core::convert::TryInto::try_into(value.rumble_option()?)?,
                        boost_strength_option: ::core::convert::TryInto::try_into(
                            value.boost_strength_option()?,
                        )?,
                        gravity_option: ::core::convert::TryInto::try_into(
                            value.gravity_option()?,
                        )?,
                        demolish_option: ::core::convert::TryInto::try_into(
                            value.demolish_option()?,
                        )?,
                        respawn_time_option: ::core::convert::TryInto::try_into(
                            value.respawn_time_option()?,
                        )?,
                        max_time_option: ::core::convert::TryInto::try_into(
                            value.max_time_option()?,
                        )?,
                        game_event_option: ::core::convert::TryInto::try_into(
                            value.game_event_option()?,
                        )?,
                        audio_option: ::core::convert::TryInto::try_into(value.audio_option()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MutatorSettingsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MutatorSettingsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MutatorSettingsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<MutatorSettings>> for MutatorSettings {
                type Value = ::planus::Offset<MutatorSettings>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<MutatorSettings>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MutatorSettingsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[MutatorSettingsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `ExistingMatchBehavior` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `ExistingMatchBehavior` in the file `rlbot/flatbuffers-schema/matchstart.fbs:273`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum ExistingMatchBehavior {
                ///  Always restart the match, even if config is identical.
                Restart = 0,

                ///  Never restart an existing match, just try to remove or spawn cars to match the configuration.
                ///  If we are not in the middle of a match, a match will be started. Handy for LAN matches.
                ContinueAndSpawn = 1,

                ///  Restart the match if any match settings differ.
                RestartIfDifferent = 2,
            }

            impl ExistingMatchBehavior {
                /// Array containing all valid variants of ExistingMatchBehavior
                pub const ENUM_VALUES: [Self; 3] = [
                    Self::Restart,
                    Self::ContinueAndSpawn,
                    Self::RestartIfDifferent,
                ];
            }

            impl ::core::convert::TryFrom<u8> for ExistingMatchBehavior {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(ExistingMatchBehavior::Restart),
                        1 => ::core::result::Result::Ok(ExistingMatchBehavior::ContinueAndSpawn),
                        2 => ::core::result::Result::Ok(ExistingMatchBehavior::RestartIfDifferent),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<ExistingMatchBehavior> for u8 {
                #[inline]
                fn from(value: ExistingMatchBehavior) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for ExistingMatchBehavior {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<ExistingMatchBehavior> for ExistingMatchBehavior {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<ExistingMatchBehavior> for ExistingMatchBehavior {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> ExistingMatchBehavior {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<ExistingMatchBehavior, ExistingMatchBehavior>
                for ExistingMatchBehavior
            {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &ExistingMatchBehavior,
                ) -> ::core::option::Option<ExistingMatchBehavior> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<ExistingMatchBehavior> for ExistingMatchBehavior {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<ExistingMatchBehavior> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for ExistingMatchBehavior {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for ExistingMatchBehavior {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "ExistingMatchBehavior",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<ExistingMatchBehavior> for ExistingMatchBehavior {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `Launcher` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `Launcher` in the file `rlbot/flatbuffers-schema/matchstart.fbs:283`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum Launcher {
                /// The variant `Steam` in the enum `Launcher`
                Steam = 0,

                /// The variant `Epic` in the enum `Launcher`
                Epic = 1,

                /// The variant `Custom` in the enum `Launcher`
                Custom = 2,
            }

            impl Launcher {
                /// Array containing all valid variants of Launcher
                pub const ENUM_VALUES: [Self; 3] = [Self::Steam, Self::Epic, Self::Custom];
            }

            impl ::core::convert::TryFrom<u8> for Launcher {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(Launcher::Steam),
                        1 => ::core::result::Result::Ok(Launcher::Epic),
                        2 => ::core::result::Result::Ok(Launcher::Custom),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<Launcher> for u8 {
                #[inline]
                fn from(value: Launcher) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for Launcher {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<Launcher> for Launcher {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<Launcher> for Launcher {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Launcher {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<Launcher, Launcher> for Launcher {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &Launcher,
                ) -> ::core::option::Option<Launcher> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<Launcher> for Launcher {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Launcher> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for Launcher {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for Launcher {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "Launcher",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<Launcher> for Launcher {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `ScriptConfiguration` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `ScriptConfiguration` in the file `rlbot/flatbuffers-schema/matchstart.fbs:289`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScriptConfiguration {
                /// The field `name` in the table `ScriptConfiguration`
                pub name: ::planus::alloc::string::String,
                /// The field `location` in the table `ScriptConfiguration`
                pub location: ::planus::alloc::string::String,
                /// The field `run_command` in the table `ScriptConfiguration`
                pub run_command: ::planus::alloc::string::String,
                /// The field `spawn_id` in the table `ScriptConfiguration`
                pub spawn_id: i32,
                /// The field `agent_id` in the table `ScriptConfiguration`
                pub agent_id: ::planus::alloc::string::String,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ScriptConfiguration {
                fn default() -> Self {
                    Self {
                        name: ::core::default::Default::default(),
                        location: ::core::default::Default::default(),
                        run_command: ::core::default::Default::default(),
                        spawn_id: 0,
                        agent_id: ::core::default::Default::default(),
                    }
                }
            }

            impl ScriptConfiguration {
                /// Creates a [ScriptConfigurationBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ScriptConfigurationBuilder<()> {
                    ScriptConfigurationBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_location: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_run_command: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_spawn_id: impl ::planus::WriteAsDefault<i32, i32>,
                    field_agent_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_name = field_name.prepare(builder);
                    let prepared_location = field_location.prepare(builder);
                    let prepared_run_command = field_run_command.prepare(builder);
                    let prepared_spawn_id = field_spawn_id.prepare(builder, &0);
                    let prepared_agent_id = field_agent_id.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    table_writer.write_entry::<::planus::Offset<str>>(2);
                    if prepared_spawn_id.is_some() {
                        table_writer.write_entry::<i32>(3);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(4);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_name);
                            object_writer.write::<_, _, 4>(&prepared_location);
                            object_writer.write::<_, _, 4>(&prepared_run_command);
                            if let ::core::option::Option::Some(prepared_spawn_id) =
                                prepared_spawn_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_spawn_id);
                            }
                            object_writer.write::<_, _, 4>(&prepared_agent_id);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ScriptConfiguration>> for ScriptConfiguration {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScriptConfiguration> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ScriptConfiguration>> for ScriptConfiguration {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScriptConfiguration>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ScriptConfiguration> for ScriptConfiguration {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScriptConfiguration> {
                    ScriptConfiguration::create(
                        builder,
                        &self.name,
                        &self.location,
                        &self.run_command,
                        self.spawn_id,
                        &self.agent_id,
                    )
                }
            }

            /// Builder for serializing an instance of the [ScriptConfiguration] type.
            ///
            /// Can be created using the [ScriptConfiguration::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ScriptConfigurationBuilder<State>(State);

            impl ScriptConfigurationBuilder<()> {
                /// Setter for the [`name` field](ScriptConfiguration#structfield.name).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn name<T0>(self, value: T0) -> ScriptConfigurationBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ScriptConfigurationBuilder((value,))
                }
            }

            impl<T0> ScriptConfigurationBuilder<(T0,)> {
                /// Setter for the [`location` field](ScriptConfiguration#structfield.location).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location<T1>(self, value: T1) -> ScriptConfigurationBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    ScriptConfigurationBuilder((v0, value))
                }
            }

            impl<T0, T1> ScriptConfigurationBuilder<(T0, T1)> {
                /// Setter for the [`run_command` field](ScriptConfiguration#structfield.run_command).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn run_command<T2>(self, value: T2) -> ScriptConfigurationBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1) = self.0;
                    ScriptConfigurationBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> ScriptConfigurationBuilder<(T0, T1, T2)> {
                /// Setter for the [`spawn_id` field](ScriptConfiguration#structfield.spawn_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id<T3>(self, value: T3) -> ScriptConfigurationBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<i32, i32>,
                {
                    let (v0, v1, v2) = self.0;
                    ScriptConfigurationBuilder((v0, v1, v2, value))
                }

                /// Sets the [`spawn_id` field](ScriptConfiguration#structfield.spawn_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id_as_default(
                    self,
                ) -> ScriptConfigurationBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.spawn_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ScriptConfigurationBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`agent_id` field](ScriptConfiguration#structfield.agent_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn agent_id<T4>(
                    self,
                    value: T4,
                ) -> ScriptConfigurationBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    ScriptConfigurationBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> ScriptConfigurationBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ScriptConfiguration].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScriptConfiguration>
                where
                    Self: ::planus::WriteAsOffset<ScriptConfiguration>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<i32, i32>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAs<::planus::Offset<ScriptConfiguration>>
                for ScriptConfigurationBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<ScriptConfiguration>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScriptConfiguration> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<i32, i32>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOptional<::planus::Offset<ScriptConfiguration>>
                for ScriptConfigurationBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<ScriptConfiguration>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ScriptConfiguration>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAs<::planus::Offset<str>>,
                    T3: ::planus::WriteAsDefault<i32, i32>,
                    T4: ::planus::WriteAs<::planus::Offset<str>>,
                > ::planus::WriteAsOffset<ScriptConfiguration>
                for ScriptConfigurationBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ScriptConfiguration> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    ScriptConfiguration::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [ScriptConfiguration].
            #[derive(Copy, Clone)]
            pub struct ScriptConfigurationRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ScriptConfigurationRef<'a> {
                /// Getter for the [`name` field](ScriptConfiguration#structfield.name).
                #[inline]
                pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ScriptConfiguration", "name")
                }

                /// Getter for the [`location` field](ScriptConfiguration#structfield.location).
                #[inline]
                pub fn location(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "ScriptConfiguration", "location")
                }

                /// Getter for the [`run_command` field](ScriptConfiguration#structfield.run_command).
                #[inline]
                pub fn run_command(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0
                        .access_required(2, "ScriptConfiguration", "run_command")
                }

                /// Getter for the [`spawn_id` field](ScriptConfiguration#structfield.spawn_id).
                #[inline]
                pub fn spawn_id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "ScriptConfiguration", "spawn_id")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`agent_id` field](ScriptConfiguration#structfield.agent_id).
                #[inline]
                pub fn agent_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(4, "ScriptConfiguration", "agent_id")
                }
            }

            impl<'a> ::core::fmt::Debug for ScriptConfigurationRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScriptConfigurationRef");
                    f.field("name", &self.name());
                    f.field("location", &self.location());
                    f.field("run_command", &self.run_command());
                    f.field("spawn_id", &self.spawn_id());
                    f.field("agent_id", &self.agent_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ScriptConfigurationRef<'a>> for ScriptConfiguration {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ScriptConfigurationRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        name: ::core::convert::Into::into(value.name()?),
                        location: ::core::convert::Into::into(value.location()?),
                        run_command: ::core::convert::Into::into(value.run_command()?),
                        spawn_id: ::core::convert::TryInto::try_into(value.spawn_id()?)?,
                        agent_id: ::core::convert::Into::into(value.agent_id()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScriptConfigurationRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ScriptConfigurationRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScriptConfigurationRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ScriptConfiguration>> for ScriptConfiguration {
                type Value = ::planus::Offset<ScriptConfiguration>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ScriptConfiguration>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ScriptConfigurationRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ScriptConfigurationRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The table `MatchSettings` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `MatchSettings` in the file `rlbot/flatbuffers-schema/matchstart.fbs:297`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct MatchSettings {
                ///  Leave unset to tell RLBot to not launch the game
                pub launcher: self::Launcher,
                ///  The path to the main Rocket League binary
                pub game_path: ::planus::alloc::string::String,
                /// The field `auto_start_bots` in the table `MatchSettings`
                pub auto_start_bots: bool,
                ///  The name of a upk file, like UtopiaStadium_P, which should be loaded.
                ///  On Steam version of Rocket League this can be used to load custom map files,
                ///  but on Epic version it only works on the Psyonix maps.
                pub game_map_upk: ::planus::alloc::string::String,
                /// The field `player_configurations` in the table `MatchSettings`
                pub player_configurations: ::planus::alloc::vec::Vec<self::PlayerConfiguration>,
                /// The field `script_configurations` in the table `MatchSettings`
                pub script_configurations: ::planus::alloc::vec::Vec<self::ScriptConfiguration>,
                /// The field `game_mode` in the table `MatchSettings`
                pub game_mode: self::GameMode,
                /// The field `skip_replays` in the table `MatchSettings`
                pub skip_replays: bool,
                /// The field `instant_start` in the table `MatchSettings`
                pub instant_start: bool,
                /// The field `mutator_settings` in the table `MatchSettings`
                pub mutator_settings:
                    ::core::option::Option<::planus::alloc::boxed::Box<self::MutatorSettings>>,
                /// The field `existing_match_behavior` in the table `MatchSettings`
                pub existing_match_behavior: self::ExistingMatchBehavior,
                /// The field `enable_rendering` in the table `MatchSettings`
                pub enable_rendering: bool,
                /// The field `enable_state_setting` in the table `MatchSettings`
                pub enable_state_setting: bool,
                /// The field `auto_save_replay` in the table `MatchSettings`
                pub auto_save_replay: bool,
                /// The field `freeplay` in the table `MatchSettings`
                pub freeplay: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for MatchSettings {
                fn default() -> Self {
                    Self {
                        launcher: self::Launcher::Steam,
                        game_path: ::core::default::Default::default(),
                        auto_start_bots: false,
                        game_map_upk: ::core::default::Default::default(),
                        player_configurations: ::core::default::Default::default(),
                        script_configurations: ::core::default::Default::default(),
                        game_mode: self::GameMode::Soccer,
                        skip_replays: false,
                        instant_start: false,
                        mutator_settings: ::core::default::Default::default(),
                        existing_match_behavior: self::ExistingMatchBehavior::Restart,
                        enable_rendering: false,
                        enable_state_setting: false,
                        auto_save_replay: false,
                        freeplay: false,
                    }
                }
            }

            impl MatchSettings {
                /// Creates a [MatchSettingsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> MatchSettingsBuilder<()> {
                    MatchSettingsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_launcher: impl ::planus::WriteAsDefault<self::Launcher, self::Launcher>,
                    field_game_path: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_auto_start_bots: impl ::planus::WriteAsDefault<bool, bool>,
                    field_game_map_upk: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_player_configurations: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>,
                    >,
                    field_script_configurations: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>,
                    >,
                    field_game_mode: impl ::planus::WriteAsDefault<self::GameMode, self::GameMode>,
                    field_skip_replays: impl ::planus::WriteAsDefault<bool, bool>,
                    field_instant_start: impl ::planus::WriteAsDefault<bool, bool>,
                    field_mutator_settings: impl ::planus::WriteAsOptional<
                        ::planus::Offset<self::MutatorSettings>,
                    >,
                    field_existing_match_behavior: impl ::planus::WriteAsDefault<
                        self::ExistingMatchBehavior,
                        self::ExistingMatchBehavior,
                    >,
                    field_enable_rendering: impl ::planus::WriteAsDefault<bool, bool>,
                    field_enable_state_setting: impl ::planus::WriteAsDefault<bool, bool>,
                    field_auto_save_replay: impl ::planus::WriteAsDefault<bool, bool>,
                    field_freeplay: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_launcher = field_launcher.prepare(builder, &self::Launcher::Steam);
                    let prepared_game_path = field_game_path.prepare(builder);
                    let prepared_auto_start_bots = field_auto_start_bots.prepare(builder, &false);
                    let prepared_game_map_upk = field_game_map_upk.prepare(builder);
                    let prepared_player_configurations =
                        field_player_configurations.prepare(builder);
                    let prepared_script_configurations =
                        field_script_configurations.prepare(builder);
                    let prepared_game_mode =
                        field_game_mode.prepare(builder, &self::GameMode::Soccer);
                    let prepared_skip_replays = field_skip_replays.prepare(builder, &false);
                    let prepared_instant_start = field_instant_start.prepare(builder, &false);
                    let prepared_mutator_settings = field_mutator_settings.prepare(builder);
                    let prepared_existing_match_behavior = field_existing_match_behavior
                        .prepare(builder, &self::ExistingMatchBehavior::Restart);
                    let prepared_enable_rendering = field_enable_rendering.prepare(builder, &false);
                    let prepared_enable_state_setting =
                        field_enable_state_setting.prepare(builder, &false);
                    let prepared_auto_save_replay = field_auto_save_replay.prepare(builder, &false);
                    let prepared_freeplay = field_freeplay.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<34> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(1);
                    table_writer.write_entry::<::planus::Offset<str>>(3);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>>(4);
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>>(5);
                    if prepared_mutator_settings.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::MutatorSettings>>(9);
                    }
                    if prepared_launcher.is_some() {
                        table_writer.write_entry::<self::Launcher>(0);
                    }
                    if prepared_auto_start_bots.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }
                    if prepared_game_mode.is_some() {
                        table_writer.write_entry::<self::GameMode>(6);
                    }
                    if prepared_skip_replays.is_some() {
                        table_writer.write_entry::<bool>(7);
                    }
                    if prepared_instant_start.is_some() {
                        table_writer.write_entry::<bool>(8);
                    }
                    if prepared_existing_match_behavior.is_some() {
                        table_writer.write_entry::<self::ExistingMatchBehavior>(10);
                    }
                    if prepared_enable_rendering.is_some() {
                        table_writer.write_entry::<bool>(11);
                    }
                    if prepared_enable_state_setting.is_some() {
                        table_writer.write_entry::<bool>(12);
                    }
                    if prepared_auto_save_replay.is_some() {
                        table_writer.write_entry::<bool>(13);
                    }
                    if prepared_freeplay.is_some() {
                        table_writer.write_entry::<bool>(14);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_game_path);
                            object_writer.write::<_, _, 4>(&prepared_game_map_upk);
                            object_writer.write::<_, _, 4>(&prepared_player_configurations);
                            object_writer.write::<_, _, 4>(&prepared_script_configurations);
                            if let ::core::option::Option::Some(prepared_mutator_settings) =
                                prepared_mutator_settings
                            {
                                object_writer.write::<_, _, 4>(&prepared_mutator_settings);
                            }
                            if let ::core::option::Option::Some(prepared_launcher) =
                                prepared_launcher
                            {
                                object_writer.write::<_, _, 1>(&prepared_launcher);
                            }
                            if let ::core::option::Option::Some(prepared_auto_start_bots) =
                                prepared_auto_start_bots
                            {
                                object_writer.write::<_, _, 1>(&prepared_auto_start_bots);
                            }
                            if let ::core::option::Option::Some(prepared_game_mode) =
                                prepared_game_mode
                            {
                                object_writer.write::<_, _, 1>(&prepared_game_mode);
                            }
                            if let ::core::option::Option::Some(prepared_skip_replays) =
                                prepared_skip_replays
                            {
                                object_writer.write::<_, _, 1>(&prepared_skip_replays);
                            }
                            if let ::core::option::Option::Some(prepared_instant_start) =
                                prepared_instant_start
                            {
                                object_writer.write::<_, _, 1>(&prepared_instant_start);
                            }
                            if let ::core::option::Option::Some(prepared_existing_match_behavior) =
                                prepared_existing_match_behavior
                            {
                                object_writer.write::<_, _, 1>(&prepared_existing_match_behavior);
                            }
                            if let ::core::option::Option::Some(prepared_enable_rendering) =
                                prepared_enable_rendering
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_rendering);
                            }
                            if let ::core::option::Option::Some(prepared_enable_state_setting) =
                                prepared_enable_state_setting
                            {
                                object_writer.write::<_, _, 1>(&prepared_enable_state_setting);
                            }
                            if let ::core::option::Option::Some(prepared_auto_save_replay) =
                                prepared_auto_save_replay
                            {
                                object_writer.write::<_, _, 1>(&prepared_auto_save_replay);
                            }
                            if let ::core::option::Option::Some(prepared_freeplay) =
                                prepared_freeplay
                            {
                                object_writer.write::<_, _, 1>(&prepared_freeplay);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<MatchSettings>> for MatchSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MatchSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<MatchSettings>> for MatchSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MatchSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<MatchSettings> for MatchSettings {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MatchSettings> {
                    MatchSettings::create(
                        builder,
                        self.launcher,
                        &self.game_path,
                        self.auto_start_bots,
                        &self.game_map_upk,
                        &self.player_configurations,
                        &self.script_configurations,
                        self.game_mode,
                        self.skip_replays,
                        self.instant_start,
                        &self.mutator_settings,
                        self.existing_match_behavior,
                        self.enable_rendering,
                        self.enable_state_setting,
                        self.auto_save_replay,
                        self.freeplay,
                    )
                }
            }

            /// Builder for serializing an instance of the [MatchSettings] type.
            ///
            /// Can be created using the [MatchSettings::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct MatchSettingsBuilder<State>(State);

            impl MatchSettingsBuilder<()> {
                /// Setter for the [`launcher` field](MatchSettings#structfield.launcher).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn launcher<T0>(self, value: T0) -> MatchSettingsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<self::Launcher, self::Launcher>,
                {
                    MatchSettingsBuilder((value,))
                }

                /// Sets the [`launcher` field](MatchSettings#structfield.launcher) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn launcher_as_default(
                    self,
                ) -> MatchSettingsBuilder<(::planus::DefaultValue,)> {
                    self.launcher(::planus::DefaultValue)
                }
            }

            impl<T0> MatchSettingsBuilder<(T0,)> {
                /// Setter for the [`game_path` field](MatchSettings#structfield.game_path).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_path<T1>(self, value: T1) -> MatchSettingsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0,) = self.0;
                    MatchSettingsBuilder((v0, value))
                }
            }

            impl<T0, T1> MatchSettingsBuilder<(T0, T1)> {
                /// Setter for the [`auto_start_bots` field](MatchSettings#structfield.auto_start_bots).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn auto_start_bots<T2>(self, value: T2) -> MatchSettingsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    MatchSettingsBuilder((v0, v1, value))
                }

                /// Sets the [`auto_start_bots` field](MatchSettings#structfield.auto_start_bots) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn auto_start_bots_as_default(
                    self,
                ) -> MatchSettingsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.auto_start_bots(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> MatchSettingsBuilder<(T0, T1, T2)> {
                /// Setter for the [`game_map_upk` field](MatchSettings#structfield.game_map_upk).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_map_upk<T3>(self, value: T3) -> MatchSettingsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> MatchSettingsBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`player_configurations` field](MatchSettings#structfield.player_configurations).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn player_configurations<T4>(
                    self,
                    value: T4,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>,
                    >,
                {
                    let (v0, v1, v2, v3) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> MatchSettingsBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`script_configurations` field](MatchSettings#structfield.script_configurations).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn script_configurations<T5>(
                    self,
                    value: T5,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>,
                    >,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`game_mode` field](MatchSettings#structfield.game_mode).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_mode<T6>(
                    self,
                    value: T6,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<self::GameMode, self::GameMode>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`game_mode` field](MatchSettings#structfield.game_mode) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_mode_as_default(
                    self,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.game_mode(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`skip_replays` field](MatchSettings#structfield.skip_replays).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn skip_replays<T7>(
                    self,
                    value: T7,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`skip_replays` field](MatchSettings#structfield.skip_replays) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn skip_replays_as_default(
                    self,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.skip_replays(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`instant_start` field](MatchSettings#structfield.instant_start).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn instant_start<T8>(
                    self,
                    value: T8,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`instant_start` field](MatchSettings#structfield.instant_start) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn instant_start_as_default(
                    self,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.instant_start(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
            {
                /// Setter for the [`mutator_settings` field](MatchSettings#structfield.mutator_settings).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mutator_settings<T9>(
                    self,
                    value: T9,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsOptional<::planus::Offset<self::MutatorSettings>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`mutator_settings` field](MatchSettings#structfield.mutator_settings) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn mutator_settings_as_null(
                    self,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ())>
                {
                    self.mutator_settings(())
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`existing_match_behavior` field](MatchSettings#structfield.existing_match_behavior).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn existing_match_behavior<T10>(
                    self,
                    value: T10,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAsDefault<
                        self::ExistingMatchBehavior,
                        self::ExistingMatchBehavior,
                    >,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }

                /// Sets the [`existing_match_behavior` field](MatchSettings#structfield.existing_match_behavior) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn existing_match_behavior_as_default(
                    self,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    ::planus::DefaultValue,
                )> {
                    self.existing_match_behavior(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`enable_rendering` field](MatchSettings#structfield.enable_rendering).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_rendering<T11>(
                    self,
                    value: T11,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`enable_rendering` field](MatchSettings#structfield.enable_rendering) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_rendering_as_default(
                    self,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.enable_rendering(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`enable_state_setting` field](MatchSettings#structfield.enable_state_setting).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_state_setting<T12>(
                    self,
                    value: T12,
                ) -> MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    MatchSettingsBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`enable_state_setting` field](MatchSettings#structfield.enable_state_setting) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn enable_state_setting_as_default(
                    self,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.enable_state_setting(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`auto_save_replay` field](MatchSettings#structfield.auto_save_replay).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn auto_save_replay<T13>(
                    self,
                    value: T13,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                )>
                where
                    T13: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    MatchSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value,
                    ))
                }

                /// Sets the [`auto_save_replay` field](MatchSettings#structfield.auto_save_replay) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn auto_save_replay_as_default(
                    self,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.auto_save_replay(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                MatchSettingsBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`freeplay` field](MatchSettings#structfield.freeplay).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn freeplay<T14>(
                    self,
                    value: T14,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    MatchSettingsBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }

                /// Sets the [`freeplay` field](MatchSettings#structfield.freeplay) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn freeplay_as_default(
                    self,
                ) -> MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    ::planus::DefaultValue,
                )> {
                    self.freeplay(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [MatchSettings].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MatchSettings>
                where
                    Self: ::planus::WriteAsOffset<MatchSettings>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Launcher, self::Launcher>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>,
                    >,
                    T6: ::planus::WriteAsDefault<self::GameMode, self::GameMode>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsOptional<::planus::Offset<self::MutatorSettings>>,
                    T10: ::planus::WriteAsDefault<
                        self::ExistingMatchBehavior,
                        self::ExistingMatchBehavior,
                    >,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<MatchSettings>>
                for MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                type Prepared = ::planus::Offset<MatchSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MatchSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Launcher, self::Launcher>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>,
                    >,
                    T6: ::planus::WriteAsDefault<self::GameMode, self::GameMode>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsOptional<::planus::Offset<self::MutatorSettings>>,
                    T10: ::planus::WriteAsDefault<
                        self::ExistingMatchBehavior,
                        self::ExistingMatchBehavior,
                    >,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<MatchSettings>>
                for MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                type Prepared = ::planus::Offset<MatchSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<MatchSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<self::Launcher, self::Launcher>,
                    T1: ::planus::WriteAs<::planus::Offset<str>>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAs<::planus::Offset<str>>,
                    T4: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerConfiguration>]>,
                    >,
                    T5: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ScriptConfiguration>]>,
                    >,
                    T6: ::planus::WriteAsDefault<self::GameMode, self::GameMode>,
                    T7: ::planus::WriteAsDefault<bool, bool>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsOptional<::planus::Offset<self::MutatorSettings>>,
                    T10: ::planus::WriteAsDefault<
                        self::ExistingMatchBehavior,
                        self::ExistingMatchBehavior,
                    >,
                    T11: ::planus::WriteAsDefault<bool, bool>,
                    T12: ::planus::WriteAsDefault<bool, bool>,
                    T13: ::planus::WriteAsDefault<bool, bool>,
                    T14: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<MatchSettings>
                for MatchSettingsBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<MatchSettings> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = &self.0;
                    MatchSettings::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                    )
                }
            }

            /// Reference to a deserialized [MatchSettings].
            #[derive(Copy, Clone)]
            pub struct MatchSettingsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> MatchSettingsRef<'a> {
                /// Getter for the [`launcher` field](MatchSettings#structfield.launcher).
                #[inline]
                pub fn launcher(&self) -> ::planus::Result<self::Launcher> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "MatchSettings", "launcher")?
                            .unwrap_or(self::Launcher::Steam),
                    )
                }

                /// Getter for the [`game_path` field](MatchSettings#structfield.game_path).
                #[inline]
                pub fn game_path(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(1, "MatchSettings", "game_path")
                }

                /// Getter for the [`auto_start_bots` field](MatchSettings#structfield.auto_start_bots).
                #[inline]
                pub fn auto_start_bots(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "MatchSettings", "auto_start_bots")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`game_map_upk` field](MatchSettings#structfield.game_map_upk).
                #[inline]
                pub fn game_map_upk(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(3, "MatchSettings", "game_map_upk")
                }

                /// Getter for the [`player_configurations` field](MatchSettings#structfield.player_configurations).
                #[inline]
                pub fn player_configurations(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::PlayerConfigurationRef<'a>>>,
                > {
                    self.0
                        .access_required(4, "MatchSettings", "player_configurations")
                }

                /// Getter for the [`script_configurations` field](MatchSettings#structfield.script_configurations).
                #[inline]
                pub fn script_configurations(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::ScriptConfigurationRef<'a>>>,
                > {
                    self.0
                        .access_required(5, "MatchSettings", "script_configurations")
                }

                /// Getter for the [`game_mode` field](MatchSettings#structfield.game_mode).
                #[inline]
                pub fn game_mode(&self) -> ::planus::Result<self::GameMode> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "MatchSettings", "game_mode")?
                            .unwrap_or(self::GameMode::Soccer),
                    )
                }

                /// Getter for the [`skip_replays` field](MatchSettings#structfield.skip_replays).
                #[inline]
                pub fn skip_replays(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "MatchSettings", "skip_replays")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`instant_start` field](MatchSettings#structfield.instant_start).
                #[inline]
                pub fn instant_start(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "MatchSettings", "instant_start")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`mutator_settings` field](MatchSettings#structfield.mutator_settings).
                #[inline]
                pub fn mutator_settings(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::MutatorSettingsRef<'a>>>
                {
                    self.0.access(9, "MatchSettings", "mutator_settings")
                }

                /// Getter for the [`existing_match_behavior` field](MatchSettings#structfield.existing_match_behavior).
                #[inline]
                pub fn existing_match_behavior(
                    &self,
                ) -> ::planus::Result<self::ExistingMatchBehavior> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(10, "MatchSettings", "existing_match_behavior")?
                            .unwrap_or(self::ExistingMatchBehavior::Restart),
                    )
                }

                /// Getter for the [`enable_rendering` field](MatchSettings#structfield.enable_rendering).
                #[inline]
                pub fn enable_rendering(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(11, "MatchSettings", "enable_rendering")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`enable_state_setting` field](MatchSettings#structfield.enable_state_setting).
                #[inline]
                pub fn enable_state_setting(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(12, "MatchSettings", "enable_state_setting")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`auto_save_replay` field](MatchSettings#structfield.auto_save_replay).
                #[inline]
                pub fn auto_save_replay(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(13, "MatchSettings", "auto_save_replay")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`freeplay` field](MatchSettings#structfield.freeplay).
                #[inline]
                pub fn freeplay(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(14, "MatchSettings", "freeplay")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for MatchSettingsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("MatchSettingsRef");
                    f.field("launcher", &self.launcher());
                    f.field("game_path", &self.game_path());
                    f.field("auto_start_bots", &self.auto_start_bots());
                    f.field("game_map_upk", &self.game_map_upk());
                    f.field("player_configurations", &self.player_configurations());
                    f.field("script_configurations", &self.script_configurations());
                    f.field("game_mode", &self.game_mode());
                    f.field("skip_replays", &self.skip_replays());
                    f.field("instant_start", &self.instant_start());
                    if let ::core::option::Option::Some(field_mutator_settings) =
                        self.mutator_settings().transpose()
                    {
                        f.field("mutator_settings", &field_mutator_settings);
                    }
                    f.field("existing_match_behavior", &self.existing_match_behavior());
                    f.field("enable_rendering", &self.enable_rendering());
                    f.field("enable_state_setting", &self.enable_state_setting());
                    f.field("auto_save_replay", &self.auto_save_replay());
                    f.field("freeplay", &self.freeplay());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<MatchSettingsRef<'a>> for MatchSettings {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: MatchSettingsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        launcher: ::core::convert::TryInto::try_into(value.launcher()?)?,
                        game_path: ::core::convert::Into::into(value.game_path()?),
                        auto_start_bots: ::core::convert::TryInto::try_into(
                            value.auto_start_bots()?,
                        )?,
                        game_map_upk: ::core::convert::Into::into(value.game_map_upk()?),
                        player_configurations: value.player_configurations()?.to_vec_result()?,
                        script_configurations: value.script_configurations()?.to_vec_result()?,
                        game_mode: ::core::convert::TryInto::try_into(value.game_mode()?)?,
                        skip_replays: ::core::convert::TryInto::try_into(value.skip_replays()?)?,
                        instant_start: ::core::convert::TryInto::try_into(value.instant_start()?)?,
                        mutator_settings: if let ::core::option::Option::Some(mutator_settings) =
                            value.mutator_settings()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(mutator_settings)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        existing_match_behavior: ::core::convert::TryInto::try_into(
                            value.existing_match_behavior()?,
                        )?,
                        enable_rendering: ::core::convert::TryInto::try_into(
                            value.enable_rendering()?,
                        )?,
                        enable_state_setting: ::core::convert::TryInto::try_into(
                            value.enable_state_setting()?,
                        )?,
                        auto_save_replay: ::core::convert::TryInto::try_into(
                            value.auto_save_replay()?,
                        )?,
                        freeplay: ::core::convert::TryInto::try_into(value.freeplay()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for MatchSettingsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for MatchSettingsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[MatchSettingsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<MatchSettings>> for MatchSettings {
                type Value = ::planus::Offset<MatchSettings>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<MatchSettings>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for MatchSettingsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[MatchSettingsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `StartCommand` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `StartCommand` in the file `rlbot/flatbuffers-schema/matchstart.fbs:320`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StartCommand {
                /// The field `config_path` in the table `StartCommand`
                pub config_path: ::planus::alloc::string::String,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for StartCommand {
                fn default() -> Self {
                    Self {
                        config_path: ::core::default::Default::default(),
                    }
                }
            }

            impl StartCommand {
                /// Creates a [StartCommandBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StartCommandBuilder<()> {
                    StartCommandBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_config_path: impl ::planus::WriteAs<::planus::Offset<str>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_config_path = field_config_path.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_config_path);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StartCommand>> for StartCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StartCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StartCommand>> for StartCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StartCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StartCommand> for StartCommand {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StartCommand> {
                    StartCommand::create(builder, &self.config_path)
                }
            }

            /// Builder for serializing an instance of the [StartCommand] type.
            ///
            /// Can be created using the [StartCommand::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StartCommandBuilder<State>(State);

            impl StartCommandBuilder<()> {
                /// Setter for the [`config_path` field](StartCommand#structfield.config_path).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn config_path<T0>(self, value: T0) -> StartCommandBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    StartCommandBuilder((value,))
                }
            }

            impl<T0> StartCommandBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StartCommand].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StartCommand>
                where
                    Self: ::planus::WriteAsOffset<StartCommand>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAs<::planus::Offset<StartCommand>> for StartCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<StartCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StartCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>>
                ::planus::WriteAsOptional<::planus::Offset<StartCommand>>
                for StartCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<StartCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StartCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<str>>> ::planus::WriteAsOffset<StartCommand>
                for StartCommandBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StartCommand> {
                    let (v0,) = &self.0;
                    StartCommand::create(builder, v0)
                }
            }

            /// Reference to a deserialized [StartCommand].
            #[derive(Copy, Clone)]
            pub struct StartCommandRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StartCommandRef<'a> {
                /// Getter for the [`config_path` field](StartCommand#structfield.config_path).
                #[inline]
                pub fn config_path(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "StartCommand", "config_path")
                }
            }

            impl<'a> ::core::fmt::Debug for StartCommandRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StartCommandRef");
                    f.field("config_path", &self.config_path());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StartCommandRef<'a>> for StartCommand {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StartCommandRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        config_path: ::core::convert::Into::into(value.config_path()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StartCommandRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StartCommandRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StartCommandRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StartCommand>> for StartCommand {
                type Value = ::planus::Offset<StartCommand>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StartCommand>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StartCommandRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StartCommandRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `StopCommand` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `StopCommand` in the file `rlbot/flatbuffers-schema/matchstart.fbs:324`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct StopCommand {
                /// The field `shutdown_server` in the table `StopCommand`
                pub shutdown_server: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for StopCommand {
                fn default() -> Self {
                    Self {
                        shutdown_server: false,
                    }
                }
            }

            impl StopCommand {
                /// Creates a [StopCommandBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> StopCommandBuilder<()> {
                    StopCommandBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_shutdown_server: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_shutdown_server = field_shutdown_server.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_shutdown_server.is_some() {
                        table_writer.write_entry::<bool>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_shutdown_server) =
                                prepared_shutdown_server
                            {
                                object_writer.write::<_, _, 1>(&prepared_shutdown_server);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<StopCommand>> for StopCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StopCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<StopCommand>> for StopCommand {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StopCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<StopCommand> for StopCommand {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StopCommand> {
                    StopCommand::create(builder, self.shutdown_server)
                }
            }

            /// Builder for serializing an instance of the [StopCommand] type.
            ///
            /// Can be created using the [StopCommand::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct StopCommandBuilder<State>(State);

            impl StopCommandBuilder<()> {
                /// Setter for the [`shutdown_server` field](StopCommand#structfield.shutdown_server).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn shutdown_server<T0>(self, value: T0) -> StopCommandBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<bool, bool>,
                {
                    StopCommandBuilder((value,))
                }

                /// Sets the [`shutdown_server` field](StopCommand#structfield.shutdown_server) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn shutdown_server_as_default(
                    self,
                ) -> StopCommandBuilder<(::planus::DefaultValue,)> {
                    self.shutdown_server(::planus::DefaultValue)
                }
            }

            impl<T0> StopCommandBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [StopCommand].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StopCommand>
                where
                    Self: ::planus::WriteAsOffset<StopCommand>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<bool, bool>>
                ::planus::WriteAs<::planus::Offset<StopCommand>> for StopCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<StopCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StopCommand> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<bool, bool>>
                ::planus::WriteAsOptional<::planus::Offset<StopCommand>>
                for StopCommandBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<StopCommand>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<StopCommand>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<bool, bool>> ::planus::WriteAsOffset<StopCommand>
                for StopCommandBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<StopCommand> {
                    let (v0,) = &self.0;
                    StopCommand::create(builder, v0)
                }
            }

            /// Reference to a deserialized [StopCommand].
            #[derive(Copy, Clone)]
            pub struct StopCommandRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> StopCommandRef<'a> {
                /// Getter for the [`shutdown_server` field](StopCommand#structfield.shutdown_server).
                #[inline]
                pub fn shutdown_server(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "StopCommand", "shutdown_server")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for StopCommandRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("StopCommandRef");
                    f.field("shutdown_server", &self.shutdown_server());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<StopCommandRef<'a>> for StopCommand {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: StopCommandRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        shutdown_server: ::core::convert::TryInto::try_into(
                            value.shutdown_server()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for StopCommandRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for StopCommandRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[StopCommandRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<StopCommand>> for StopCommand {
                type Value = ::planus::Offset<StopCommand>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<StopCommand>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for StopCommandRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[StopCommandRef]", "read_as_root", 0)
                    })
                }
            }

            ///  Sent when connecting to RLBot to indicate what type of messages are desired.
            ///  This could be sent by a bot, or a bot manager governing several bots, an
            ///  overlay, or any other utility that connects to the RLBot process.
            ///
            /// Generated from these locations:
            /// * Table `ConnectionSettings` in the file `rlbot/flatbuffers-schema/rlbot.fbs:11`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ConnectionSettings {
                ///  The ID of the bot/script that is associated with the incoming connection.
                pub agent_id: ::planus::alloc::string::String,
                ///  If this is set, RLBot will send BallPrediction data back to the client when available.
                pub wants_ball_predictions: bool,
                ///  If this is set, RLBot will send MatchComms to the client when available.
                pub wants_comms: bool,
                ///  If this is set, RLBot will close the connection after the match ends. The GUI will not want this
                pub close_after_match: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ConnectionSettings {
                fn default() -> Self {
                    Self {
                        agent_id: ::core::default::Default::default(),
                        wants_ball_predictions: false,
                        wants_comms: false,
                        close_after_match: false,
                    }
                }
            }

            impl ConnectionSettings {
                /// Creates a [ConnectionSettingsBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ConnectionSettingsBuilder<()> {
                    ConnectionSettingsBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_agent_id: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_wants_ball_predictions: impl ::planus::WriteAsDefault<bool, bool>,
                    field_wants_comms: impl ::planus::WriteAsDefault<bool, bool>,
                    field_close_after_match: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_agent_id = field_agent_id.prepare(builder);
                    let prepared_wants_ball_predictions =
                        field_wants_ball_predictions.prepare(builder, &false);
                    let prepared_wants_comms = field_wants_comms.prepare(builder, &false);
                    let prepared_close_after_match =
                        field_close_after_match.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_wants_ball_predictions.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }
                    if prepared_wants_comms.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }
                    if prepared_close_after_match.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_agent_id);
                            if let ::core::option::Option::Some(prepared_wants_ball_predictions) =
                                prepared_wants_ball_predictions
                            {
                                object_writer.write::<_, _, 1>(&prepared_wants_ball_predictions);
                            }
                            if let ::core::option::Option::Some(prepared_wants_comms) =
                                prepared_wants_comms
                            {
                                object_writer.write::<_, _, 1>(&prepared_wants_comms);
                            }
                            if let ::core::option::Option::Some(prepared_close_after_match) =
                                prepared_close_after_match
                            {
                                object_writer.write::<_, _, 1>(&prepared_close_after_match);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ConnectionSettings>> for ConnectionSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectionSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ConnectionSettings>> for ConnectionSettings {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectionSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ConnectionSettings> for ConnectionSettings {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectionSettings> {
                    ConnectionSettings::create(
                        builder,
                        &self.agent_id,
                        self.wants_ball_predictions,
                        self.wants_comms,
                        self.close_after_match,
                    )
                }
            }

            /// Builder for serializing an instance of the [ConnectionSettings] type.
            ///
            /// Can be created using the [ConnectionSettings::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ConnectionSettingsBuilder<State>(State);

            impl ConnectionSettingsBuilder<()> {
                /// Setter for the [`agent_id` field](ConnectionSettings#structfield.agent_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn agent_id<T0>(self, value: T0) -> ConnectionSettingsBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    ConnectionSettingsBuilder((value,))
                }
            }

            impl<T0> ConnectionSettingsBuilder<(T0,)> {
                /// Setter for the [`wants_ball_predictions` field](ConnectionSettings#structfield.wants_ball_predictions).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wants_ball_predictions<T1>(
                    self,
                    value: T1,
                ) -> ConnectionSettingsBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    ConnectionSettingsBuilder((v0, value))
                }

                /// Sets the [`wants_ball_predictions` field](ConnectionSettings#structfield.wants_ball_predictions) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wants_ball_predictions_as_default(
                    self,
                ) -> ConnectionSettingsBuilder<(T0, ::planus::DefaultValue)> {
                    self.wants_ball_predictions(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ConnectionSettingsBuilder<(T0, T1)> {
                /// Setter for the [`wants_comms` field](ConnectionSettings#structfield.wants_comms).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wants_comms<T2>(self, value: T2) -> ConnectionSettingsBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    ConnectionSettingsBuilder((v0, v1, value))
                }

                /// Sets the [`wants_comms` field](ConnectionSettings#structfield.wants_comms) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn wants_comms_as_default(
                    self,
                ) -> ConnectionSettingsBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.wants_comms(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> ConnectionSettingsBuilder<(T0, T1, T2)> {
                /// Setter for the [`close_after_match` field](ConnectionSettings#structfield.close_after_match).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn close_after_match<T3>(
                    self,
                    value: T3,
                ) -> ConnectionSettingsBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    ConnectionSettingsBuilder((v0, v1, v2, value))
                }

                /// Sets the [`close_after_match` field](ConnectionSettings#structfield.close_after_match) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn close_after_match_as_default(
                    self,
                ) -> ConnectionSettingsBuilder<(T0, T1, T2, ::planus::DefaultValue)>
                {
                    self.close_after_match(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> ConnectionSettingsBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ConnectionSettings].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectionSettings>
                where
                    Self: ::planus::WriteAsOffset<ConnectionSettings>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<ConnectionSettings>>
                for ConnectionSettingsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConnectionSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectionSettings> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<ConnectionSettings>>
                for ConnectionSettingsBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<ConnectionSettings>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ConnectionSettings>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<ConnectionSettings>
                for ConnectionSettingsBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ConnectionSettings> {
                    let (v0, v1, v2, v3) = &self.0;
                    ConnectionSettings::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [ConnectionSettings].
            #[derive(Copy, Clone)]
            pub struct ConnectionSettingsRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ConnectionSettingsRef<'a> {
                /// Getter for the [`agent_id` field](ConnectionSettings#structfield.agent_id).
                #[inline]
                pub fn agent_id(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "ConnectionSettings", "agent_id")
                }

                /// Getter for the [`wants_ball_predictions` field](ConnectionSettings#structfield.wants_ball_predictions).
                #[inline]
                pub fn wants_ball_predictions(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ConnectionSettings", "wants_ball_predictions")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`wants_comms` field](ConnectionSettings#structfield.wants_comms).
                #[inline]
                pub fn wants_comms(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "ConnectionSettings", "wants_comms")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`close_after_match` field](ConnectionSettings#structfield.close_after_match).
                #[inline]
                pub fn close_after_match(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "ConnectionSettings", "close_after_match")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ConnectionSettingsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ConnectionSettingsRef");
                    f.field("agent_id", &self.agent_id());
                    f.field("wants_ball_predictions", &self.wants_ball_predictions());
                    f.field("wants_comms", &self.wants_comms());
                    f.field("close_after_match", &self.close_after_match());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ConnectionSettingsRef<'a>> for ConnectionSettings {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ConnectionSettingsRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        agent_id: ::core::convert::Into::into(value.agent_id()?),
                        wants_ball_predictions: ::core::convert::TryInto::try_into(
                            value.wants_ball_predictions()?,
                        )?,
                        wants_comms: ::core::convert::TryInto::try_into(value.wants_comms()?)?,
                        close_after_match: ::core::convert::TryInto::try_into(
                            value.close_after_match()?,
                        )?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ConnectionSettingsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ConnectionSettingsRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ConnectionSettingsRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ConnectionSettings>> for ConnectionSettings {
                type Value = ::planus::Offset<ConnectionSettings>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ConnectionSettings>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ConnectionSettingsRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ConnectionSettingsRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ControllableInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `ControllableInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:22`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ControllableInfo {
                /// The field `index` in the table `ControllableInfo`
                pub index: u32,
                /// The field `spawn_id` in the table `ControllableInfo`
                pub spawn_id: i32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ControllableInfo {
                fn default() -> Self {
                    Self {
                        index: 0,
                        spawn_id: 0,
                    }
                }
            }

            impl ControllableInfo {
                /// Creates a [ControllableInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ControllableInfoBuilder<()> {
                    ControllableInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_spawn_id: impl ::planus::WriteAsDefault<i32, i32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_index = field_index.prepare(builder, &0);
                    let prepared_spawn_id = field_spawn_id.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    if prepared_spawn_id.is_some() {
                        table_writer.write_entry::<i32>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_index) = prepared_index {
                                object_writer.write::<_, _, 4>(&prepared_index);
                            }
                            if let ::core::option::Option::Some(prepared_spawn_id) =
                                prepared_spawn_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_spawn_id);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ControllableInfo>> for ControllableInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ControllableInfo>> for ControllableInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ControllableInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ControllableInfo> for ControllableInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableInfo> {
                    ControllableInfo::create(builder, self.index, self.spawn_id)
                }
            }

            /// Builder for serializing an instance of the [ControllableInfo] type.
            ///
            /// Can be created using the [ControllableInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ControllableInfoBuilder<State>(State);

            impl ControllableInfoBuilder<()> {
                /// Setter for the [`index` field](ControllableInfo#structfield.index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index<T0>(self, value: T0) -> ControllableInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ControllableInfoBuilder((value,))
                }

                /// Sets the [`index` field](ControllableInfo#structfield.index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index_as_default(
                    self,
                ) -> ControllableInfoBuilder<(::planus::DefaultValue,)> {
                    self.index(::planus::DefaultValue)
                }
            }

            impl<T0> ControllableInfoBuilder<(T0,)> {
                /// Setter for the [`spawn_id` field](ControllableInfo#structfield.spawn_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id<T1>(self, value: T1) -> ControllableInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<i32, i32>,
                {
                    let (v0,) = self.0;
                    ControllableInfoBuilder((v0, value))
                }

                /// Sets the [`spawn_id` field](ControllableInfo#structfield.spawn_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id_as_default(
                    self,
                ) -> ControllableInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.spawn_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1> ControllableInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ControllableInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableInfo>
                where
                    Self: ::planus::WriteAsOffset<ControllableInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAs<::planus::Offset<ControllableInfo>>
                for ControllableInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ControllableInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAsOptional<::planus::Offset<ControllableInfo>>
                for ControllableInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ControllableInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ControllableInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAsOffset<ControllableInfo> for ControllableInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableInfo> {
                    let (v0, v1) = &self.0;
                    ControllableInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [ControllableInfo].
            #[derive(Copy, Clone)]
            pub struct ControllableInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ControllableInfoRef<'a> {
                /// Getter for the [`index` field](ControllableInfo#structfield.index).
                #[inline]
                pub fn index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "ControllableInfo", "index")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`spawn_id` field](ControllableInfo#structfield.spawn_id).
                #[inline]
                pub fn spawn_id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "ControllableInfo", "spawn_id")?
                            .unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for ControllableInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ControllableInfoRef");
                    f.field("index", &self.index());
                    f.field("spawn_id", &self.spawn_id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ControllableInfoRef<'a>> for ControllableInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ControllableInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        index: ::core::convert::TryInto::try_into(value.index()?)?,
                        spawn_id: ::core::convert::TryInto::try_into(value.spawn_id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ControllableInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ControllableInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ControllableInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ControllableInfo>> for ControllableInfo {
                type Value = ::planus::Offset<ControllableInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ControllableInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ControllableInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[ControllableInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `ControllableTeamInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `ControllableTeamInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:27`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ControllableTeamInfo {
                ///  The assigned team for this connection
                pub team: u32,
                ///  The bots that RLBot will allow this connection to control
                pub controllables: ::planus::alloc::vec::Vec<self::ControllableInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for ControllableTeamInfo {
                fn default() -> Self {
                    Self {
                        team: 0,
                        controllables: ::core::default::Default::default(),
                    }
                }
            }

            impl ControllableTeamInfo {
                /// Creates a [ControllableTeamInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> ControllableTeamInfoBuilder<()> {
                    ControllableTeamInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_team: impl ::planus::WriteAsDefault<u32, u32>,
                    field_controllables: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ControllableInfo>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_team = field_team.prepare(builder, &0);
                    let prepared_controllables = field_controllables.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_team.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<self::ControllableInfo>]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_team) = prepared_team {
                                object_writer.write::<_, _, 4>(&prepared_team);
                            }
                            object_writer.write::<_, _, 4>(&prepared_controllables);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<ControllableTeamInfo>> for ControllableTeamInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableTeamInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<ControllableTeamInfo>> for ControllableTeamInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ControllableTeamInfo>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<ControllableTeamInfo> for ControllableTeamInfo {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableTeamInfo> {
                    ControllableTeamInfo::create(builder, self.team, &self.controllables)
                }
            }

            /// Builder for serializing an instance of the [ControllableTeamInfo] type.
            ///
            /// Can be created using the [ControllableTeamInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct ControllableTeamInfoBuilder<State>(State);

            impl ControllableTeamInfoBuilder<()> {
                /// Setter for the [`team` field](ControllableTeamInfo#structfield.team).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team<T0>(self, value: T0) -> ControllableTeamInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    ControllableTeamInfoBuilder((value,))
                }

                /// Sets the [`team` field](ControllableTeamInfo#structfield.team) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_as_default(
                    self,
                ) -> ControllableTeamInfoBuilder<(::planus::DefaultValue,)> {
                    self.team(::planus::DefaultValue)
                }
            }

            impl<T0> ControllableTeamInfoBuilder<(T0,)> {
                /// Setter for the [`controllables` field](ControllableTeamInfo#structfield.controllables).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn controllables<T1>(self, value: T1) -> ControllableTeamInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::ControllableInfo>]>,
                    >,
                {
                    let (v0,) = self.0;
                    ControllableTeamInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> ControllableTeamInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [ControllableTeamInfo].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableTeamInfo>
                where
                    Self: ::planus::WriteAsOffset<ControllableTeamInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ControllableInfo>]>>,
                > ::planus::WriteAs<::planus::Offset<ControllableTeamInfo>>
                for ControllableTeamInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ControllableTeamInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableTeamInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ControllableInfo>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<ControllableTeamInfo>>
                for ControllableTeamInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<ControllableTeamInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<ControllableTeamInfo>>
                {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::ControllableInfo>]>>,
                > ::planus::WriteAsOffset<ControllableTeamInfo>
                for ControllableTeamInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllableTeamInfo> {
                    let (v0, v1) = &self.0;
                    ControllableTeamInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [ControllableTeamInfo].
            #[derive(Copy, Clone)]
            pub struct ControllableTeamInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> ControllableTeamInfoRef<'a> {
                /// Getter for the [`team` field](ControllableTeamInfo#structfield.team).
                #[inline]
                pub fn team(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "ControllableTeamInfo", "team")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`controllables` field](ControllableTeamInfo#structfield.controllables).
                #[inline]
                pub fn controllables(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::ControllableInfoRef<'a>>>,
                > {
                    self.0
                        .access_required(1, "ControllableTeamInfo", "controllables")
                }
            }

            impl<'a> ::core::fmt::Debug for ControllableTeamInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ControllableTeamInfoRef");
                    f.field("team", &self.team());
                    f.field("controllables", &self.controllables());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<ControllableTeamInfoRef<'a>> for ControllableTeamInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: ControllableTeamInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        team: ::core::convert::TryInto::try_into(value.team()?)?,
                        controllables: value.controllables()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for ControllableTeamInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for ControllableTeamInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ControllableTeamInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<ControllableTeamInfo>> for ControllableTeamInfo {
                type Value = ::planus::Offset<ControllableTeamInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<ControllableTeamInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for ControllableTeamInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[ControllableTeamInfoRef]",
                            "read_as_root",
                            0,
                        )
                    })
                }
            }

            /// The struct `ControllerState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `ControllerState` in the file `rlbot/flatbuffers-schema/rlbot.fbs:34`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ControllerState {
                ///  -1 for full reverse, 1 for full forward
                pub throttle: f32,

                ///  -1 for full left, 1 for full right
                pub steer: f32,

                ///  -1 for nose down, 1 for nose up
                pub pitch: f32,

                ///  -1 for full left, 1 for full right
                pub yaw: f32,

                ///  -1 for roll left, 1 for roll right
                pub roll: f32,

                ///  true if you want to press the jump button
                pub jump: bool,

                ///  true if you want to press the boost button
                pub boost: bool,

                ///  true if you want to press the handbrake button
                pub handbrake: bool,

                ///  true if you want to press the 'use item' button, used in rumble etc.
                pub use_item: bool,
            }

            impl ::planus::Primitive for ControllerState {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 24;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<ControllerState> for ControllerState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 20>();
                    self.throttle.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 16>();
                    self.steer.write(cur, buffer_position - 4);
                    let (cur, cursor) = cursor.split::<4, 12>();
                    self.pitch.write(cur, buffer_position - 8);
                    let (cur, cursor) = cursor.split::<4, 8>();
                    self.yaw.write(cur, buffer_position - 12);
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.roll.write(cur, buffer_position - 16);
                    let (cur, cursor) = cursor.split::<1, 3>();
                    self.jump.write(cur, buffer_position - 20);
                    let (cur, cursor) = cursor.split::<1, 2>();
                    self.boost.write(cur, buffer_position - 21);
                    let (cur, cursor) = cursor.split::<1, 1>();
                    self.handbrake.write(cur, buffer_position - 22);
                    let (cur, cursor) = cursor.split::<1, 0>();
                    self.use_item.write(cur, buffer_position - 23);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<ControllerState> for ControllerState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<ControllerState> {
                    unsafe {
                        builder.write_with(24, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 24]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<ControllerState> for ControllerState {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<ControllerState> for ControllerState {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [ControllerState].
            #[derive(Copy, Clone)]
            pub struct ControllerStateRef<'a>(::planus::ArrayWithStartOffset<'a, 24>);

            impl<'a> ControllerStateRef<'a> {
                /// Getter for the [`throttle` field](ControllerState#structfield.throttle).
                pub fn throttle(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`steer` field](ControllerState#structfield.steer).
                pub fn steer(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`pitch` field](ControllerState#structfield.pitch).
                pub fn pitch(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(8).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`yaw` field](ControllerState#structfield.yaw).
                pub fn yaw(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(12).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`roll` field](ControllerState#structfield.roll).
                pub fn roll(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(16).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`jump` field](ControllerState#structfield.jump).
                pub fn jump(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(20).unwrap();

                    buffer.as_array()[0] != 0
                }

                /// Getter for the [`boost` field](ControllerState#structfield.boost).
                pub fn boost(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(21).unwrap();

                    buffer.as_array()[0] != 0
                }

                /// Getter for the [`handbrake` field](ControllerState#structfield.handbrake).
                pub fn handbrake(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(22).unwrap();

                    buffer.as_array()[0] != 0
                }

                /// Getter for the [`use_item` field](ControllerState#structfield.use_item).
                pub fn use_item(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(23).unwrap();

                    buffer.as_array()[0] != 0
                }
            }

            impl<'a> ::core::fmt::Debug for ControllerStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ControllerStateRef");
                    f.field("throttle", &self.throttle());
                    f.field("steer", &self.steer());
                    f.field("pitch", &self.pitch());
                    f.field("yaw", &self.yaw());
                    f.field("roll", &self.roll());
                    f.field("jump", &self.jump());
                    f.field("boost", &self.boost());
                    f.field("handbrake", &self.handbrake());
                    f.field("use_item", &self.use_item());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 24>> for ControllerStateRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 24>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<ControllerStateRef<'a>> for ControllerState {
                #[allow(unreachable_code)]
                fn from(value: ControllerStateRef<'a>) -> Self {
                    Self {
                        throttle: value.throttle(),
                        steer: value.steer(),
                        pitch: value.pitch(),
                        yaw: value.yaw(),
                        roll: value.roll(),
                        jump: value.jump(),
                        boost: value.boost(),
                        handbrake: value.handbrake(),
                        use_item: value.use_item(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<ControllerStateRef<'a>> for ControllerStateRef<'b> {
                fn eq(&self, other: &ControllerStateRef<'_>) -> bool {
                    self.throttle() == other.throttle()
                        && self.steer() == other.steer()
                        && self.pitch() == other.pitch()
                        && self.yaw() == other.yaw()
                        && self.roll() == other.roll()
                        && self.jump() == other.jump()
                        && self.boost() == other.boost()
                        && self.handbrake() == other.handbrake()
                        && self.use_item() == other.use_item()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<ControllerStateRef<'a>> for ControllerStateRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &ControllerStateRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.throttle().partial_cmp(&other.throttle()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.steer().partial_cmp(&other.steer()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.pitch().partial_cmp(&other.pitch()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.yaw().partial_cmp(&other.yaw()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.roll().partial_cmp(&other.roll()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.jump().partial_cmp(&other.jump()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.boost().partial_cmp(&other.boost()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.handbrake().partial_cmp(&other.handbrake()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.use_item().partial_cmp(&other.use_item())
                }
            }

            impl<'a> ::planus::TableRead<'a> for ControllerStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<24>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for ControllerStateRef<'a> {
                const STRIDE: usize = 24;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<ControllerState> for ControllerState {
                const STRIDE: usize = 24;

                type Value = ControllerState;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[ControllerState],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 24];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (24 * i) as u32,
                        );
                    }
                }
            }

            /// The table `PlayerInput` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `PlayerInput` in the file `rlbot/flatbuffers-schema/rlbot.fbs:55`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct PlayerInput {
                /// The field `player_index` in the table `PlayerInput`
                pub player_index: u32,
                /// The field `controller_state` in the table `PlayerInput`
                pub controller_state: self::ControllerState,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PlayerInput {
                fn default() -> Self {
                    Self {
                        player_index: 0,
                        controller_state: ::core::default::Default::default(),
                    }
                }
            }

            impl PlayerInput {
                /// Creates a [PlayerInputBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlayerInputBuilder<()> {
                    PlayerInputBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_player_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_controller_state: impl ::planus::WriteAs<self::ControllerState>,
                ) -> ::planus::Offset<Self> {
                    let prepared_player_index = field_player_index.prepare(builder, &0);
                    let prepared_controller_state = field_controller_state.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_player_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<self::ControllerState>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_player_index) =
                                prepared_player_index
                            {
                                object_writer.write::<_, _, 4>(&prepared_player_index);
                            }
                            object_writer.write::<_, _, 24>(&prepared_controller_state);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlayerInput>> for PlayerInput {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerInput> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlayerInput>> for PlayerInput {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerInput>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlayerInput> for PlayerInput {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerInput> {
                    PlayerInput::create(builder, self.player_index, self.controller_state)
                }
            }

            /// Builder for serializing an instance of the [PlayerInput] type.
            ///
            /// Can be created using the [PlayerInput::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlayerInputBuilder<State>(State);

            impl PlayerInputBuilder<()> {
                /// Setter for the [`player_index` field](PlayerInput#structfield.player_index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn player_index<T0>(self, value: T0) -> PlayerInputBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    PlayerInputBuilder((value,))
                }

                /// Sets the [`player_index` field](PlayerInput#structfield.player_index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn player_index_as_default(
                    self,
                ) -> PlayerInputBuilder<(::planus::DefaultValue,)> {
                    self.player_index(::planus::DefaultValue)
                }
            }

            impl<T0> PlayerInputBuilder<(T0,)> {
                /// Setter for the [`controller_state` field](PlayerInput#structfield.controller_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn controller_state<T1>(self, value: T1) -> PlayerInputBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::ControllerState>,
                {
                    let (v0,) = self.0;
                    PlayerInputBuilder((v0, value))
                }
            }

            impl<T0, T1> PlayerInputBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlayerInput].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerInput>
                where
                    Self: ::planus::WriteAsOffset<PlayerInput>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<self::ControllerState>,
                > ::planus::WriteAs<::planus::Offset<PlayerInput>>
                for PlayerInputBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<PlayerInput>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerInput> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<self::ControllerState>,
                > ::planus::WriteAsOptional<::planus::Offset<PlayerInput>>
                for PlayerInputBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<PlayerInput>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerInput>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<u32, u32>,
                    T1: ::planus::WriteAs<self::ControllerState>,
                > ::planus::WriteAsOffset<PlayerInput> for PlayerInputBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PlayerInput> {
                    let (v0, v1) = &self.0;
                    PlayerInput::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [PlayerInput].
            #[derive(Copy, Clone)]
            pub struct PlayerInputRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlayerInputRef<'a> {
                /// Getter for the [`player_index` field](PlayerInput#structfield.player_index).
                #[inline]
                pub fn player_index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "PlayerInput", "player_index")?
                            .unwrap_or(0),
                    )
                }

                /// Getter for the [`controller_state` field](PlayerInput#structfield.controller_state).
                #[inline]
                pub fn controller_state(&self) -> ::planus::Result<self::ControllerStateRef<'a>> {
                    self.0.access_required(1, "PlayerInput", "controller_state")
                }
            }

            impl<'a> ::core::fmt::Debug for PlayerInputRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlayerInputRef");
                    f.field("player_index", &self.player_index());
                    f.field("controller_state", &self.controller_state());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlayerInputRef<'a>> for PlayerInput {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlayerInputRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        player_index: ::core::convert::TryInto::try_into(value.player_index()?)?,
                        controller_state: ::core::convert::Into::into(value.controller_state()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlayerInputRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlayerInputRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlayerInputRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlayerInput>> for PlayerInput {
                type Value = ::planus::Offset<PlayerInput>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlayerInput>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlayerInputRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PlayerInputRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `Vector2` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Vector2` in the file `rlbot/flatbuffers-schema/rlbot.fbs:62`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Vector2 {
                /// The field `x` in the struct `Vector2`
                pub x: f32,

                /// The field `y` in the struct `Vector2`
                pub y: f32,
            }

            impl ::planus::Primitive for Vector2 {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 8;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Vector2> for Vector2 {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.x.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.y.write(cur, buffer_position - 4);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Vector2> for Vector2 {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Vector2> {
                    unsafe {
                        builder.write_with(8, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 8]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Vector2> for Vector2 {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Vector2> for Vector2 {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Vector2].
            #[derive(Copy, Clone)]
            pub struct Vector2Ref<'a>(::planus::ArrayWithStartOffset<'a, 8>);

            impl<'a> Vector2Ref<'a> {
                /// Getter for the [`x` field](Vector2#structfield.x).
                pub fn x(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`y` field](Vector2#structfield.y).
                pub fn y(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for Vector2Ref<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Vector2Ref");
                    f.field("x", &self.x());
                    f.field("y", &self.y());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 8>> for Vector2Ref<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 8>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<Vector2Ref<'a>> for Vector2 {
                #[allow(unreachable_code)]
                fn from(value: Vector2Ref<'a>) -> Self {
                    Self {
                        x: value.x(),
                        y: value.y(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<Vector2Ref<'a>> for Vector2Ref<'b> {
                fn eq(&self, other: &Vector2Ref<'_>) -> bool {
                    self.x() == other.x() && self.y() == other.y()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<Vector2Ref<'a>> for Vector2Ref<'b> {
                fn partial_cmp(
                    &self,
                    other: &Vector2Ref<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.x().partial_cmp(&other.x()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.y().partial_cmp(&other.y())
                }
            }

            impl<'a> ::planus::TableRead<'a> for Vector2Ref<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<8>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for Vector2Ref<'a> {
                const STRIDE: usize = 8;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Vector2> for Vector2 {
                const STRIDE: usize = 8;

                type Value = Vector2;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Vector2],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 8];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (8 * i) as u32,
                        );
                    }
                }
            }

            /// The struct `Vector3` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Vector3` in the file `rlbot/flatbuffers-schema/rlbot.fbs:68`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Vector3 {
                /// The field `x` in the struct `Vector3`
                pub x: f32,

                /// The field `y` in the struct `Vector3`
                pub y: f32,

                /// The field `z` in the struct `Vector3`
                pub z: f32,
            }

            impl ::planus::Primitive for Vector3 {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 12;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Vector3> for Vector3 {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 8>();
                    self.x.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.y.write(cur, buffer_position - 4);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.z.write(cur, buffer_position - 8);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Vector3> for Vector3 {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Vector3> {
                    unsafe {
                        builder.write_with(12, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 12]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Vector3> for Vector3 {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Vector3> for Vector3 {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Vector3].
            #[derive(Copy, Clone)]
            pub struct Vector3Ref<'a>(::planus::ArrayWithStartOffset<'a, 12>);

            impl<'a> Vector3Ref<'a> {
                /// Getter for the [`x` field](Vector3#structfield.x).
                pub fn x(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`y` field](Vector3#structfield.y).
                pub fn y(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`z` field](Vector3#structfield.z).
                pub fn z(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(8).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for Vector3Ref<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Vector3Ref");
                    f.field("x", &self.x());
                    f.field("y", &self.y());
                    f.field("z", &self.z());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 12>> for Vector3Ref<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 12>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<Vector3Ref<'a>> for Vector3 {
                #[allow(unreachable_code)]
                fn from(value: Vector3Ref<'a>) -> Self {
                    Self {
                        x: value.x(),
                        y: value.y(),
                        z: value.z(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<Vector3Ref<'a>> for Vector3Ref<'b> {
                fn eq(&self, other: &Vector3Ref<'_>) -> bool {
                    self.x() == other.x() && self.y() == other.y() && self.z() == other.z()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<Vector3Ref<'a>> for Vector3Ref<'b> {
                fn partial_cmp(
                    &self,
                    other: &Vector3Ref<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.x().partial_cmp(&other.x()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.y().partial_cmp(&other.y()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.z().partial_cmp(&other.z())
                }
            }

            impl<'a> ::planus::TableRead<'a> for Vector3Ref<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<12>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for Vector3Ref<'a> {
                const STRIDE: usize = 12;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Vector3> for Vector3 {
                const STRIDE: usize = 12;

                type Value = Vector3;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Vector3],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 12];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (12 * i) as u32,
                        );
                    }
                }
            }

            ///  Expresses the rotation state of an object in Euler angles, with values in radians.
            ///
            /// Generated from these locations:
            /// * Struct `Rotator` in the file `rlbot/flatbuffers-schema/rlbot.fbs:75`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Rotator {
                /// The field `pitch` in the struct `Rotator`
                pub pitch: f32,

                /// The field `yaw` in the struct `Rotator`
                pub yaw: f32,

                /// The field `roll` in the struct `Rotator`
                pub roll: f32,
            }

            impl ::planus::Primitive for Rotator {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 12;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Rotator> for Rotator {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 8>();
                    self.pitch.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.yaw.write(cur, buffer_position - 4);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.roll.write(cur, buffer_position - 8);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Rotator> for Rotator {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rotator> {
                    unsafe {
                        builder.write_with(12, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 12]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Rotator> for Rotator {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Rotator> for Rotator {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Rotator].
            #[derive(Copy, Clone)]
            pub struct RotatorRef<'a>(::planus::ArrayWithStartOffset<'a, 12>);

            impl<'a> RotatorRef<'a> {
                /// Getter for the [`pitch` field](Rotator#structfield.pitch).
                pub fn pitch(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`yaw` field](Rotator#structfield.yaw).
                pub fn yaw(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`roll` field](Rotator#structfield.roll).
                pub fn roll(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(8).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for RotatorRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RotatorRef");
                    f.field("pitch", &self.pitch());
                    f.field("yaw", &self.yaw());
                    f.field("roll", &self.roll());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 12>> for RotatorRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 12>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<RotatorRef<'a>> for Rotator {
                #[allow(unreachable_code)]
                fn from(value: RotatorRef<'a>) -> Self {
                    Self {
                        pitch: value.pitch(),
                        yaw: value.yaw(),
                        roll: value.roll(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<RotatorRef<'a>> for RotatorRef<'b> {
                fn eq(&self, other: &RotatorRef<'_>) -> bool {
                    self.pitch() == other.pitch()
                        && self.yaw() == other.yaw()
                        && self.roll() == other.roll()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<RotatorRef<'a>> for RotatorRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &RotatorRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.pitch().partial_cmp(&other.pitch()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.yaw().partial_cmp(&other.yaw()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.roll().partial_cmp(&other.roll())
                }
            }

            impl<'a> ::planus::TableRead<'a> for RotatorRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<12>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for RotatorRef<'a> {
                const STRIDE: usize = 12;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Rotator> for Rotator {
                const STRIDE: usize = 12;

                type Value = Rotator;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Rotator],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 12];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (12 * i) as u32,
                        );
                    }
                }
            }

            /// The table `BoxShape` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `BoxShape` in the file `rlbot/flatbuffers-schema/rlbot.fbs:81`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BoxShape {
                /// The field `length` in the table `BoxShape`
                pub length: f32,
                /// The field `width` in the table `BoxShape`
                pub width: f32,
                /// The field `height` in the table `BoxShape`
                pub height: f32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BoxShape {
                fn default() -> Self {
                    Self {
                        length: 0.0,
                        width: 0.0,
                        height: 0.0,
                    }
                }
            }

            impl BoxShape {
                /// Creates a [BoxShapeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BoxShapeBuilder<()> {
                    BoxShapeBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_length: impl ::planus::WriteAsDefault<f32, f32>,
                    field_width: impl ::planus::WriteAsDefault<f32, f32>,
                    field_height: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_length = field_length.prepare(builder, &0.0);
                    let prepared_width = field_width.prepare(builder, &0.0);
                    let prepared_height = field_height.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    if prepared_length.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }
                    if prepared_width.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }
                    if prepared_height.is_some() {
                        table_writer.write_entry::<f32>(2);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_length) = prepared_length {
                                object_writer.write::<_, _, 4>(&prepared_length);
                            }
                            if let ::core::option::Option::Some(prepared_width) = prepared_width {
                                object_writer.write::<_, _, 4>(&prepared_width);
                            }
                            if let ::core::option::Option::Some(prepared_height) = prepared_height {
                                object_writer.write::<_, _, 4>(&prepared_height);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BoxShape>> for BoxShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoxShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BoxShape>> for BoxShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BoxShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BoxShape> for BoxShape {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoxShape> {
                    BoxShape::create(builder, self.length, self.width, self.height)
                }
            }

            /// Builder for serializing an instance of the [BoxShape] type.
            ///
            /// Can be created using the [BoxShape::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BoxShapeBuilder<State>(State);

            impl BoxShapeBuilder<()> {
                /// Setter for the [`length` field](BoxShape#structfield.length).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn length<T0>(self, value: T0) -> BoxShapeBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    BoxShapeBuilder((value,))
                }

                /// Sets the [`length` field](BoxShape#structfield.length) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn length_as_default(self) -> BoxShapeBuilder<(::planus::DefaultValue,)> {
                    self.length(::planus::DefaultValue)
                }
            }

            impl<T0> BoxShapeBuilder<(T0,)> {
                /// Setter for the [`width` field](BoxShape#structfield.width).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width<T1>(self, value: T1) -> BoxShapeBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    BoxShapeBuilder((v0, value))
                }

                /// Sets the [`width` field](BoxShape#structfield.width) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width_as_default(self) -> BoxShapeBuilder<(T0, ::planus::DefaultValue)> {
                    self.width(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BoxShapeBuilder<(T0, T1)> {
                /// Setter for the [`height` field](BoxShape#structfield.height).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height<T2>(self, value: T2) -> BoxShapeBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1) = self.0;
                    BoxShapeBuilder((v0, v1, value))
                }

                /// Sets the [`height` field](BoxShape#structfield.height) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height_as_default(
                    self,
                ) -> BoxShapeBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.height(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> BoxShapeBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BoxShape].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoxShape>
                where
                    Self: ::planus::WriteAsOffset<BoxShape>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAs<::planus::Offset<BoxShape>> for BoxShapeBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<BoxShape>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoxShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOptional<::planus::Offset<BoxShape>>
                for BoxShapeBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<BoxShape>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BoxShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOffset<BoxShape> for BoxShapeBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoxShape> {
                    let (v0, v1, v2) = &self.0;
                    BoxShape::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [BoxShape].
            #[derive(Copy, Clone)]
            pub struct BoxShapeRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BoxShapeRef<'a> {
                /// Getter for the [`length` field](BoxShape#structfield.length).
                #[inline]
                pub fn length(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "BoxShape", "length")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`width` field](BoxShape#structfield.width).
                #[inline]
                pub fn width(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "BoxShape", "width")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`height` field](BoxShape#structfield.height).
                #[inline]
                pub fn height(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "BoxShape", "height")?.unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BoxShapeRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BoxShapeRef");
                    f.field("length", &self.length());
                    f.field("width", &self.width());
                    f.field("height", &self.height());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BoxShapeRef<'a>> for BoxShape {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BoxShapeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        length: ::core::convert::TryInto::try_into(value.length()?)?,
                        width: ::core::convert::TryInto::try_into(value.width()?)?,
                        height: ::core::convert::TryInto::try_into(value.height()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BoxShapeRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BoxShapeRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BoxShapeRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BoxShape>> for BoxShape {
                type Value = ::planus::Offset<BoxShape>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BoxShape>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BoxShapeRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BoxShapeRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `SphereShape` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `SphereShape` in the file `rlbot/flatbuffers-schema/rlbot.fbs:87`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct SphereShape {
                /// The field `diameter` in the table `SphereShape`
                pub diameter: f32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for SphereShape {
                fn default() -> Self {
                    Self { diameter: 0.0 }
                }
            }

            impl SphereShape {
                /// Creates a [SphereShapeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> SphereShapeBuilder<()> {
                    SphereShapeBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_diameter: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_diameter = field_diameter.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_diameter.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_diameter) =
                                prepared_diameter
                            {
                                object_writer.write::<_, _, 4>(&prepared_diameter);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<SphereShape>> for SphereShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SphereShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<SphereShape>> for SphereShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SphereShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<SphereShape> for SphereShape {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SphereShape> {
                    SphereShape::create(builder, self.diameter)
                }
            }

            /// Builder for serializing an instance of the [SphereShape] type.
            ///
            /// Can be created using the [SphereShape::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct SphereShapeBuilder<State>(State);

            impl SphereShapeBuilder<()> {
                /// Setter for the [`diameter` field](SphereShape#structfield.diameter).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn diameter<T0>(self, value: T0) -> SphereShapeBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    SphereShapeBuilder((value,))
                }

                /// Sets the [`diameter` field](SphereShape#structfield.diameter) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn diameter_as_default(self) -> SphereShapeBuilder<(::planus::DefaultValue,)> {
                    self.diameter(::planus::DefaultValue)
                }
            }

            impl<T0> SphereShapeBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [SphereShape].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SphereShape>
                where
                    Self: ::planus::WriteAsOffset<SphereShape>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<f32, f32>>
                ::planus::WriteAs<::planus::Offset<SphereShape>> for SphereShapeBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SphereShape>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SphereShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<f32, f32>>
                ::planus::WriteAsOptional<::planus::Offset<SphereShape>>
                for SphereShapeBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<SphereShape>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<SphereShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<f32, f32>> ::planus::WriteAsOffset<SphereShape>
                for SphereShapeBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<SphereShape> {
                    let (v0,) = &self.0;
                    SphereShape::create(builder, v0)
                }
            }

            /// Reference to a deserialized [SphereShape].
            #[derive(Copy, Clone)]
            pub struct SphereShapeRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> SphereShapeRef<'a> {
                /// Getter for the [`diameter` field](SphereShape#structfield.diameter).
                #[inline]
                pub fn diameter(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "SphereShape", "diameter")?.unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for SphereShapeRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("SphereShapeRef");
                    f.field("diameter", &self.diameter());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<SphereShapeRef<'a>> for SphereShape {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: SphereShapeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        diameter: ::core::convert::TryInto::try_into(value.diameter()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for SphereShapeRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for SphereShapeRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[SphereShapeRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<SphereShape>> for SphereShape {
                type Value = ::planus::Offset<SphereShape>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<SphereShape>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for SphereShapeRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[SphereShapeRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `CylinderShape` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `CylinderShape` in the file `rlbot/flatbuffers-schema/rlbot.fbs:91`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct CylinderShape {
                /// The field `diameter` in the table `CylinderShape`
                pub diameter: f32,
                /// The field `height` in the table `CylinderShape`
                pub height: f32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for CylinderShape {
                fn default() -> Self {
                    Self {
                        diameter: 0.0,
                        height: 0.0,
                    }
                }
            }

            impl CylinderShape {
                /// Creates a [CylinderShapeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CylinderShapeBuilder<()> {
                    CylinderShapeBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_diameter: impl ::planus::WriteAsDefault<f32, f32>,
                    field_height: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_diameter = field_diameter.prepare(builder, &0.0);
                    let prepared_height = field_height.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_diameter.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }
                    if prepared_height.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_diameter) =
                                prepared_diameter
                            {
                                object_writer.write::<_, _, 4>(&prepared_diameter);
                            }
                            if let ::core::option::Option::Some(prepared_height) = prepared_height {
                                object_writer.write::<_, _, 4>(&prepared_height);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CylinderShape>> for CylinderShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CylinderShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CylinderShape>> for CylinderShape {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CylinderShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CylinderShape> for CylinderShape {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CylinderShape> {
                    CylinderShape::create(builder, self.diameter, self.height)
                }
            }

            /// Builder for serializing an instance of the [CylinderShape] type.
            ///
            /// Can be created using the [CylinderShape::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CylinderShapeBuilder<State>(State);

            impl CylinderShapeBuilder<()> {
                /// Setter for the [`diameter` field](CylinderShape#structfield.diameter).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn diameter<T0>(self, value: T0) -> CylinderShapeBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    CylinderShapeBuilder((value,))
                }

                /// Sets the [`diameter` field](CylinderShape#structfield.diameter) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn diameter_as_default(
                    self,
                ) -> CylinderShapeBuilder<(::planus::DefaultValue,)> {
                    self.diameter(::planus::DefaultValue)
                }
            }

            impl<T0> CylinderShapeBuilder<(T0,)> {
                /// Setter for the [`height` field](CylinderShape#structfield.height).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height<T1>(self, value: T1) -> CylinderShapeBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    CylinderShapeBuilder((v0, value))
                }

                /// Sets the [`height` field](CylinderShape#structfield.height) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height_as_default(
                    self,
                ) -> CylinderShapeBuilder<(T0, ::planus::DefaultValue)> {
                    self.height(::planus::DefaultValue)
                }
            }

            impl<T0, T1> CylinderShapeBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CylinderShape].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CylinderShape>
                where
                    Self: ::planus::WriteAsOffset<CylinderShape>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAs<::planus::Offset<CylinderShape>>
                for CylinderShapeBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CylinderShape>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CylinderShape> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOptional<::planus::Offset<CylinderShape>>
                for CylinderShapeBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CylinderShape>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CylinderShape>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOffset<CylinderShape> for CylinderShapeBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<CylinderShape> {
                    let (v0, v1) = &self.0;
                    CylinderShape::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CylinderShape].
            #[derive(Copy, Clone)]
            pub struct CylinderShapeRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CylinderShapeRef<'a> {
                /// Getter for the [`diameter` field](CylinderShape#structfield.diameter).
                #[inline]
                pub fn diameter(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "CylinderShape", "diameter")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`height` field](CylinderShape#structfield.height).
                #[inline]
                pub fn height(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(1, "CylinderShape", "height")?.unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for CylinderShapeRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CylinderShapeRef");
                    f.field("diameter", &self.diameter());
                    f.field("height", &self.height());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CylinderShapeRef<'a>> for CylinderShape {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CylinderShapeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        diameter: ::core::convert::TryInto::try_into(value.diameter()?)?,
                        height: ::core::convert::TryInto::try_into(value.height()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CylinderShapeRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CylinderShapeRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CylinderShapeRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CylinderShape>> for CylinderShape {
                type Value = ::planus::Offset<CylinderShape>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CylinderShape>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CylinderShapeRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CylinderShapeRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `CollisionShape` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Union `CollisionShape` in the file `rlbot/flatbuffers-schema/rlbot.fbs:96`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum CollisionShape {
                /// The variant of type `BoxShape` in the union `CollisionShape`
                BoxShape(::planus::alloc::boxed::Box<self::BoxShape>),

                /// The variant of type `SphereShape` in the union `CollisionShape`
                SphereShape(::planus::alloc::boxed::Box<self::SphereShape>),

                /// The variant of type `CylinderShape` in the union `CollisionShape`
                CylinderShape(::planus::alloc::boxed::Box<self::CylinderShape>),
            }

            impl CollisionShape {
                /// Creates a [CollisionShapeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CollisionShapeBuilder<::planus::Uninitialized> {
                    CollisionShapeBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_box_shape(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BoxShape>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_sphere_shape(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::SphereShape>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_cylinder_shape(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::CylinderShape>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<CollisionShape> for CollisionShape {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BoxShape(value) => Self::create_box_shape(builder, value),
                        Self::SphereShape(value) => Self::create_sphere_shape(builder, value),
                        Self::CylinderShape(value) => Self::create_cylinder_shape(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<CollisionShape> for CollisionShape {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [CollisionShape] type.
            ///
            /// Can be created using the [CollisionShape::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CollisionShapeBuilder<T>(T);

            impl CollisionShapeBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`BoxShape` variant](CollisionShape#variant.BoxShape).
                #[inline]
                pub fn box_shape<T>(
                    self,
                    value: T,
                ) -> CollisionShapeBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::BoxShape>,
                {
                    CollisionShapeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`SphereShape` variant](CollisionShape#variant.SphereShape).
                #[inline]
                pub fn sphere_shape<T>(
                    self,
                    value: T,
                ) -> CollisionShapeBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::SphereShape>,
                {
                    CollisionShapeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`CylinderShape` variant](CollisionShape#variant.CylinderShape).
                #[inline]
                pub fn cylinder_shape<T>(
                    self,
                    value: T,
                ) -> CollisionShapeBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::CylinderShape>,
                {
                    CollisionShapeBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> CollisionShapeBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [CollisionShape].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<CollisionShape>
                where
                    Self: ::planus::WriteAsUnion<CollisionShape>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BoxShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<CollisionShape> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BoxShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<CollisionShape>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::SphereShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<CollisionShape> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::SphereShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<CollisionShape>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::CylinderShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<CollisionShape> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<CollisionShape>
                for CollisionShapeBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::CylinderShape>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<CollisionShape>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [CollisionShape].
            #[derive(Copy, Clone, Debug)]
            pub enum CollisionShapeRef<'a> {
                BoxShape(self::BoxShapeRef<'a>),
                SphereShape(self::SphereShapeRef<'a>),
                CylinderShape(self::CylinderShapeRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<CollisionShapeRef<'a>> for CollisionShape {
                type Error = ::planus::Error;

                fn try_from(value: CollisionShapeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        CollisionShapeRef::BoxShape(value) => {
                            Self::BoxShape(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        CollisionShapeRef::SphereShape(value) => {
                            Self::SphereShape(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        CollisionShapeRef::CylinderShape(value) => {
                            Self::CylinderShape(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for CollisionShapeRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BoxShape(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::SphereShape(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::CylinderShape(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `Touch` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `Touch` in the file `rlbot/flatbuffers-schema/rlbot.fbs:98`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Touch {
                ///  Seconds that had elapsed in the game when the touch occurred.
                pub game_seconds: f32,
                ///  The point of contact for the touch.
                pub location: self::Vector3,
                ///  The direction of the touch.
                pub normal: self::Vector3,
                ///  The index of the ball that was touched.
                pub ball_index: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Touch {
                fn default() -> Self {
                    Self {
                        game_seconds: 0.0,
                        location: ::core::default::Default::default(),
                        normal: ::core::default::Default::default(),
                        ball_index: 0,
                    }
                }
            }

            impl Touch {
                /// Creates a [TouchBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> TouchBuilder<()> {
                    TouchBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_game_seconds: impl ::planus::WriteAsDefault<f32, f32>,
                    field_location: impl ::planus::WriteAs<self::Vector3>,
                    field_normal: impl ::planus::WriteAs<self::Vector3>,
                    field_ball_index: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_game_seconds = field_game_seconds.prepare(builder, &0.0);
                    let prepared_location = field_location.prepare(builder);
                    let prepared_normal = field_normal.prepare(builder);
                    let prepared_ball_index = field_ball_index.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    if prepared_game_seconds.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }
                    table_writer.write_entry::<self::Vector3>(1);
                    table_writer.write_entry::<self::Vector3>(2);
                    if prepared_ball_index.is_some() {
                        table_writer.write_entry::<u32>(3);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_game_seconds) =
                                prepared_game_seconds
                            {
                                object_writer.write::<_, _, 4>(&prepared_game_seconds);
                            }
                            object_writer.write::<_, _, 12>(&prepared_location);
                            object_writer.write::<_, _, 12>(&prepared_normal);
                            if let ::core::option::Option::Some(prepared_ball_index) =
                                prepared_ball_index
                            {
                                object_writer.write::<_, _, 4>(&prepared_ball_index);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Touch>> for Touch {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Touch> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Touch>> for Touch {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Touch>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Touch> for Touch {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Touch> {
                    Touch::create(
                        builder,
                        self.game_seconds,
                        self.location,
                        self.normal,
                        self.ball_index,
                    )
                }
            }

            /// Builder for serializing an instance of the [Touch] type.
            ///
            /// Can be created using the [Touch::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct TouchBuilder<State>(State);

            impl TouchBuilder<()> {
                /// Setter for the [`game_seconds` field](Touch#structfield.game_seconds).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_seconds<T0>(self, value: T0) -> TouchBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    TouchBuilder((value,))
                }

                /// Sets the [`game_seconds` field](Touch#structfield.game_seconds) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_seconds_as_default(self) -> TouchBuilder<(::planus::DefaultValue,)> {
                    self.game_seconds(::planus::DefaultValue)
                }
            }

            impl<T0> TouchBuilder<(T0,)> {
                /// Setter for the [`location` field](Touch#structfield.location).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location<T1>(self, value: T1) -> TouchBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0,) = self.0;
                    TouchBuilder((v0, value))
                }
            }

            impl<T0, T1> TouchBuilder<(T0, T1)> {
                /// Setter for the [`normal` field](Touch#structfield.normal).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn normal<T2>(self, value: T2) -> TouchBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0, v1) = self.0;
                    TouchBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> TouchBuilder<(T0, T1, T2)> {
                /// Setter for the [`ball_index` field](Touch#structfield.ball_index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_index<T3>(self, value: T3) -> TouchBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2) = self.0;
                    TouchBuilder((v0, v1, v2, value))
                }

                /// Sets the [`ball_index` field](Touch#structfield.ball_index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn ball_index_as_default(
                    self,
                ) -> TouchBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.ball_index(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> TouchBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Touch].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Touch>
                where
                    Self: ::planus::WriteAsOffset<Touch>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<Touch>> for TouchBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Touch>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Touch> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<Touch>>
                for TouchBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Touch>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Touch>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<Touch> for TouchBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Touch> {
                    let (v0, v1, v2, v3) = &self.0;
                    Touch::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [Touch].
            #[derive(Copy, Clone)]
            pub struct TouchRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> TouchRef<'a> {
                /// Getter for the [`game_seconds` field](Touch#structfield.game_seconds).
                #[inline]
                pub fn game_seconds(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "Touch", "game_seconds")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`location` field](Touch#structfield.location).
                #[inline]
                pub fn location(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(1, "Touch", "location")
                }

                /// Getter for the [`normal` field](Touch#structfield.normal).
                #[inline]
                pub fn normal(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(2, "Touch", "normal")
                }

                /// Getter for the [`ball_index` field](Touch#structfield.ball_index).
                #[inline]
                pub fn ball_index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "Touch", "ball_index")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for TouchRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TouchRef");
                    f.field("game_seconds", &self.game_seconds());
                    f.field("location", &self.location());
                    f.field("normal", &self.normal());
                    f.field("ball_index", &self.ball_index());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<TouchRef<'a>> for Touch {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: TouchRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        game_seconds: ::core::convert::TryInto::try_into(value.game_seconds()?)?,
                        location: ::core::convert::Into::into(value.location()?),
                        normal: ::core::convert::Into::into(value.normal()?),
                        ball_index: ::core::convert::TryInto::try_into(value.ball_index()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for TouchRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for TouchRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[TouchRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Touch>> for Touch {
                type Value = ::planus::Offset<Touch>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Touch>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for TouchRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[TouchRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `ScoreInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `ScoreInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:109`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct ScoreInfo {
                /// The field `score` in the struct `ScoreInfo`
                pub score: u32,

                /// The field `goals` in the struct `ScoreInfo`
                pub goals: u32,

                /// The field `own_goals` in the struct `ScoreInfo`
                pub own_goals: u32,

                /// The field `assists` in the struct `ScoreInfo`
                pub assists: u32,

                /// The field `saves` in the struct `ScoreInfo`
                pub saves: u32,

                /// The field `shots` in the struct `ScoreInfo`
                pub shots: u32,

                /// The field `demolitions` in the struct `ScoreInfo`
                pub demolitions: u32,
            }

            impl ::planus::Primitive for ScoreInfo {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 28;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<ScoreInfo> for ScoreInfo {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 24>();
                    self.score.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 20>();
                    self.goals.write(cur, buffer_position - 4);
                    let (cur, cursor) = cursor.split::<4, 16>();
                    self.own_goals.write(cur, buffer_position - 8);
                    let (cur, cursor) = cursor.split::<4, 12>();
                    self.assists.write(cur, buffer_position - 12);
                    let (cur, cursor) = cursor.split::<4, 8>();
                    self.saves.write(cur, buffer_position - 16);
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.shots.write(cur, buffer_position - 20);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.demolitions.write(cur, buffer_position - 24);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<ScoreInfo> for ScoreInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<ScoreInfo> {
                    unsafe {
                        builder.write_with(28, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 28]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<ScoreInfo> for ScoreInfo {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<ScoreInfo> for ScoreInfo {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [ScoreInfo].
            #[derive(Copy, Clone)]
            pub struct ScoreInfoRef<'a>(::planus::ArrayWithStartOffset<'a, 28>);

            impl<'a> ScoreInfoRef<'a> {
                /// Getter for the [`score` field](ScoreInfo#structfield.score).
                pub fn score(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`goals` field](ScoreInfo#structfield.goals).
                pub fn goals(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`own_goals` field](ScoreInfo#structfield.own_goals).
                pub fn own_goals(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(8).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`assists` field](ScoreInfo#structfield.assists).
                pub fn assists(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(12).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`saves` field](ScoreInfo#structfield.saves).
                pub fn saves(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(16).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`shots` field](ScoreInfo#structfield.shots).
                pub fn shots(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(20).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`demolitions` field](ScoreInfo#structfield.demolitions).
                pub fn demolitions(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(24).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for ScoreInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ScoreInfoRef");
                    f.field("score", &self.score());
                    f.field("goals", &self.goals());
                    f.field("own_goals", &self.own_goals());
                    f.field("assists", &self.assists());
                    f.field("saves", &self.saves());
                    f.field("shots", &self.shots());
                    f.field("demolitions", &self.demolitions());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 28>> for ScoreInfoRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 28>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<ScoreInfoRef<'a>> for ScoreInfo {
                #[allow(unreachable_code)]
                fn from(value: ScoreInfoRef<'a>) -> Self {
                    Self {
                        score: value.score(),
                        goals: value.goals(),
                        own_goals: value.own_goals(),
                        assists: value.assists(),
                        saves: value.saves(),
                        shots: value.shots(),
                        demolitions: value.demolitions(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<ScoreInfoRef<'a>> for ScoreInfoRef<'b> {
                fn eq(&self, other: &ScoreInfoRef<'_>) -> bool {
                    self.score() == other.score()
                        && self.goals() == other.goals()
                        && self.own_goals() == other.own_goals()
                        && self.assists() == other.assists()
                        && self.saves() == other.saves()
                        && self.shots() == other.shots()
                        && self.demolitions() == other.demolitions()
                }
            }

            impl<'a> ::core::cmp::Eq for ScoreInfoRef<'a> {}
            impl<'a, 'b> ::core::cmp::PartialOrd<ScoreInfoRef<'a>> for ScoreInfoRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &ScoreInfoRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::option::Option::Some(::core::cmp::Ord::cmp(self, other))
                }
            }

            impl<'a> ::core::cmp::Ord for ScoreInfoRef<'a> {
                fn cmp(&self, other: &ScoreInfoRef<'_>) -> ::core::cmp::Ordering {
                    self.score()
                        .cmp(&other.score())
                        .then_with(|| self.goals().cmp(&other.goals()))
                        .then_with(|| self.own_goals().cmp(&other.own_goals()))
                        .then_with(|| self.assists().cmp(&other.assists()))
                        .then_with(|| self.saves().cmp(&other.saves()))
                        .then_with(|| self.shots().cmp(&other.shots()))
                        .then_with(|| self.demolitions().cmp(&other.demolitions()))
                }
            }

            impl<'a> ::core::hash::Hash for ScoreInfoRef<'a> {
                fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
                    self.score().hash(state);
                    self.goals().hash(state);
                    self.own_goals().hash(state);
                    self.assists().hash(state);
                    self.saves().hash(state);
                    self.shots().hash(state);
                    self.demolitions().hash(state);
                }
            }

            impl<'a> ::planus::TableRead<'a> for ScoreInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<28>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for ScoreInfoRef<'a> {
                const STRIDE: usize = 28;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<ScoreInfo> for ScoreInfo {
                const STRIDE: usize = 28;

                type Value = ScoreInfo;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[ScoreInfo],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 28];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (28 * i) as u32,
                        );
                    }
                }
            }

            /// The struct `Physics` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Physics` in the file `rlbot/flatbuffers-schema/rlbot.fbs:119`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Physics {
                /// The field `location` in the struct `Physics`
                pub location: self::Vector3,

                /// The field `rotation` in the struct `Physics`
                pub rotation: self::Rotator,

                /// The field `velocity` in the struct `Physics`
                pub velocity: self::Vector3,

                /// The field `angular_velocity` in the struct `Physics`
                pub angular_velocity: self::Vector3,
            }

            impl ::planus::Primitive for Physics {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 48;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Physics> for Physics {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<12, 36>();
                    self.location.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<12, 24>();
                    self.rotation.write(cur, buffer_position - 12);
                    let (cur, cursor) = cursor.split::<12, 12>();
                    self.velocity.write(cur, buffer_position - 24);
                    let (cur, cursor) = cursor.split::<12, 0>();
                    self.angular_velocity.write(cur, buffer_position - 36);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Physics> for Physics {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Physics> {
                    unsafe {
                        builder.write_with(48, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 48]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Physics> for Physics {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Physics> for Physics {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Physics].
            #[derive(Copy, Clone)]
            pub struct PhysicsRef<'a>(::planus::ArrayWithStartOffset<'a, 48>);

            impl<'a> PhysicsRef<'a> {
                /// Getter for the [`location` field](Physics#structfield.location).
                pub fn location(&self) -> self::Vector3Ref<'a> {
                    let buffer = self.0.advance_as_array::<12>(0).unwrap();

                    ::core::convert::From::from(buffer)
                }

                /// Getter for the [`rotation` field](Physics#structfield.rotation).
                pub fn rotation(&self) -> self::RotatorRef<'a> {
                    let buffer = self.0.advance_as_array::<12>(12).unwrap();

                    ::core::convert::From::from(buffer)
                }

                /// Getter for the [`velocity` field](Physics#structfield.velocity).
                pub fn velocity(&self) -> self::Vector3Ref<'a> {
                    let buffer = self.0.advance_as_array::<12>(24).unwrap();

                    ::core::convert::From::from(buffer)
                }

                /// Getter for the [`angular_velocity` field](Physics#structfield.angular_velocity).
                pub fn angular_velocity(&self) -> self::Vector3Ref<'a> {
                    let buffer = self.0.advance_as_array::<12>(36).unwrap();

                    ::core::convert::From::from(buffer)
                }
            }

            impl<'a> ::core::fmt::Debug for PhysicsRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PhysicsRef");
                    f.field("location", &self.location());
                    f.field("rotation", &self.rotation());
                    f.field("velocity", &self.velocity());
                    f.field("angular_velocity", &self.angular_velocity());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 48>> for PhysicsRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 48>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<PhysicsRef<'a>> for Physics {
                #[allow(unreachable_code)]
                fn from(value: PhysicsRef<'a>) -> Self {
                    Self {
                        location: ::core::convert::From::from(value.location()),
                        rotation: ::core::convert::From::from(value.rotation()),
                        velocity: ::core::convert::From::from(value.velocity()),
                        angular_velocity: ::core::convert::From::from(value.angular_velocity()),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<PhysicsRef<'a>> for PhysicsRef<'b> {
                fn eq(&self, other: &PhysicsRef<'_>) -> bool {
                    self.location() == other.location()
                        && self.rotation() == other.rotation()
                        && self.velocity() == other.velocity()
                        && self.angular_velocity() == other.angular_velocity()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<PhysicsRef<'a>> for PhysicsRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &PhysicsRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.location().partial_cmp(&other.location()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.rotation().partial_cmp(&other.rotation()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    match self.velocity().partial_cmp(&other.velocity()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.angular_velocity()
                        .partial_cmp(&other.angular_velocity())
                }
            }

            impl<'a> ::planus::TableRead<'a> for PhysicsRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<48>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for PhysicsRef<'a> {
                const STRIDE: usize = 48;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Physics> for Physics {
                const STRIDE: usize = 48;

                type Value = Physics;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Physics],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 48];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (48 * i) as u32,
                        );
                    }
                }
            }

            /// The enum `AirState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `AirState` in the file `rlbot/flatbuffers-schema/rlbot.fbs:126`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum AirState {
                ///  All wheels are on the ground
                OnGround = 0,

                ///  When the bot is jumping,
                ///  then InAir right after
                Jumping = 1,

                ///  When the bot is double jumping,
                ///  then InAir right after
                DoubleJumping = 2,

                ///  When the bot is dodging,
                ///  then InAir right after
                Dodging = 3,

                /// The variant `InAir` in the enum `AirState`
                InAir = 4,
            }

            impl AirState {
                /// Array containing all valid variants of AirState
                pub const ENUM_VALUES: [Self; 5] = [
                    Self::OnGround,
                    Self::Jumping,
                    Self::DoubleJumping,
                    Self::Dodging,
                    Self::InAir,
                ];
            }

            impl ::core::convert::TryFrom<u8> for AirState {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(AirState::OnGround),
                        1 => ::core::result::Result::Ok(AirState::Jumping),
                        2 => ::core::result::Result::Ok(AirState::DoubleJumping),
                        3 => ::core::result::Result::Ok(AirState::Dodging),
                        4 => ::core::result::Result::Ok(AirState::InAir),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<AirState> for u8 {
                #[inline]
                fn from(value: AirState) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for AirState {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<AirState> for AirState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<AirState> for AirState {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> AirState {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<AirState, AirState> for AirState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &AirState,
                ) -> ::core::option::Option<AirState> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<AirState> for AirState {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<AirState> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for AirState {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for AirState {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "AirState",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<AirState> for AirState {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `PlayerInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `PlayerInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:141`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct PlayerInfo {
                /// The field `physics` in the table `PlayerInfo`
                pub physics: self::Physics,
                /// The field `score_info` in the table `PlayerInfo`
                pub score_info: self::ScoreInfo,
                /// The field `hitbox` in the table `PlayerInfo`
                pub hitbox: ::planus::alloc::boxed::Box<self::BoxShape>,
                /// The field `hitbox_offset` in the table `PlayerInfo`
                pub hitbox_offset: self::Vector3,
                /// The field `latest_touch` in the table `PlayerInfo`
                pub latest_touch: ::core::option::Option<::planus::alloc::boxed::Box<self::Touch>>,
                /// The field `air_state` in the table `PlayerInfo`
                pub air_state: self::AirState,
                ///  How long until the bot cannot dodge anymore, -1 while on ground or when airborne for too long after jumping
                pub dodge_timeout: f32,
                ///  How long until the bot is not demolished anymore, -1 if not demolished
                pub demolished_timeout: f32,
                /// The field `is_supersonic` in the table `PlayerInfo`
                pub is_supersonic: bool,
                /// The field `is_bot` in the table `PlayerInfo`
                pub is_bot: bool,
                /// The field `name` in the table `PlayerInfo`
                pub name: ::planus::alloc::string::String,
                /// The field `team` in the table `PlayerInfo`
                pub team: u32,
                /// The field `boost` in the table `PlayerInfo`
                pub boost: u32,
                /// The field `spawn_id` in the table `PlayerInfo`
                pub spawn_id: i32,
                ///  Notifications the player triggered by some in-game event, such as:
                ///     Win, Loss, TimePlayed;
                ///     Shot, Assist, Center, Clear, PoolShot;
                ///     Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
                ///     AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
                ///     Save, EpicSave, FreezeSave;
                ///     HatTrick, Savior, Playmaker, MVP;
                ///     FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
                ///     MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
                ///     CarTouches, Demolition, Demolish;
                ///     LowFive, HighFive;
                ///  Clears every tick.
                pub accolades: ::planus::alloc::vec::Vec<::planus::alloc::string::String>,
                ///  The last known controller input from this player
                pub last_input: self::ControllerState,
                ///  If the player was the last one to be watched by a spectator
                pub last_spectated: bool,
                /// The field `has_jumped` in the table `PlayerInfo`
                pub has_jumped: bool,
                /// The field `has_double_jumped` in the table `PlayerInfo`
                pub has_double_jumped: bool,
                /// The field `has_dodged` in the table `PlayerInfo`
                pub has_dodged: bool,
                ///  The time in seconds since the last dodge was initiated.
                ///  Resets to 0 when the player lands on the ground.
                pub dodge_elapsed: f32,
                /// The field `dodge_dir` in the table `PlayerInfo`
                pub dodge_dir: self::Vector2,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PlayerInfo {
                fn default() -> Self {
                    Self {
                        physics: ::core::default::Default::default(),
                        score_info: ::core::default::Default::default(),
                        hitbox: ::core::default::Default::default(),
                        hitbox_offset: ::core::default::Default::default(),
                        latest_touch: ::core::default::Default::default(),
                        air_state: self::AirState::OnGround,
                        dodge_timeout: 0.0,
                        demolished_timeout: 0.0,
                        is_supersonic: false,
                        is_bot: false,
                        name: ::core::default::Default::default(),
                        team: 0,
                        boost: 0,
                        spawn_id: 0,
                        accolades: ::core::default::Default::default(),
                        last_input: ::core::default::Default::default(),
                        last_spectated: false,
                        has_jumped: false,
                        has_double_jumped: false,
                        has_dodged: false,
                        dodge_elapsed: 0.0,
                        dodge_dir: ::core::default::Default::default(),
                    }
                }
            }

            impl PlayerInfo {
                /// Creates a [PlayerInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PlayerInfoBuilder<()> {
                    PlayerInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_physics: impl ::planus::WriteAs<self::Physics>,
                    field_score_info: impl ::planus::WriteAs<self::ScoreInfo>,
                    field_hitbox: impl ::planus::WriteAs<::planus::Offset<self::BoxShape>>,
                    field_hitbox_offset: impl ::planus::WriteAs<self::Vector3>,
                    field_latest_touch: impl ::planus::WriteAsOptional<::planus::Offset<self::Touch>>,
                    field_air_state: impl ::planus::WriteAsDefault<self::AirState, self::AirState>,
                    field_dodge_timeout: impl ::planus::WriteAsDefault<f32, f32>,
                    field_demolished_timeout: impl ::planus::WriteAsDefault<f32, f32>,
                    field_is_supersonic: impl ::planus::WriteAsDefault<bool, bool>,
                    field_is_bot: impl ::planus::WriteAsDefault<bool, bool>,
                    field_name: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_team: impl ::planus::WriteAsDefault<u32, u32>,
                    field_boost: impl ::planus::WriteAsDefault<u32, u32>,
                    field_spawn_id: impl ::planus::WriteAsDefault<i32, i32>,
                    field_accolades: impl ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    field_last_input: impl ::planus::WriteAs<self::ControllerState>,
                    field_last_spectated: impl ::planus::WriteAsDefault<bool, bool>,
                    field_has_jumped: impl ::planus::WriteAsDefault<bool, bool>,
                    field_has_double_jumped: impl ::planus::WriteAsDefault<bool, bool>,
                    field_has_dodged: impl ::planus::WriteAsDefault<bool, bool>,
                    field_dodge_elapsed: impl ::planus::WriteAsDefault<f32, f32>,
                    field_dodge_dir: impl ::planus::WriteAs<self::Vector2>,
                ) -> ::planus::Offset<Self> {
                    let prepared_physics = field_physics.prepare(builder);
                    let prepared_score_info = field_score_info.prepare(builder);
                    let prepared_hitbox = field_hitbox.prepare(builder);
                    let prepared_hitbox_offset = field_hitbox_offset.prepare(builder);
                    let prepared_latest_touch = field_latest_touch.prepare(builder);
                    let prepared_air_state =
                        field_air_state.prepare(builder, &self::AirState::OnGround);
                    let prepared_dodge_timeout = field_dodge_timeout.prepare(builder, &0.0);
                    let prepared_demolished_timeout =
                        field_demolished_timeout.prepare(builder, &0.0);
                    let prepared_is_supersonic = field_is_supersonic.prepare(builder, &false);
                    let prepared_is_bot = field_is_bot.prepare(builder, &false);
                    let prepared_name = field_name.prepare(builder);
                    let prepared_team = field_team.prepare(builder, &0);
                    let prepared_boost = field_boost.prepare(builder, &0);
                    let prepared_spawn_id = field_spawn_id.prepare(builder, &0);
                    let prepared_accolades = field_accolades.prepare(builder);
                    let prepared_last_input = field_last_input.prepare(builder);
                    let prepared_last_spectated = field_last_spectated.prepare(builder, &false);
                    let prepared_has_jumped = field_has_jumped.prepare(builder, &false);
                    let prepared_has_double_jumped =
                        field_has_double_jumped.prepare(builder, &false);
                    let prepared_has_dodged = field_has_dodged.prepare(builder, &false);
                    let prepared_dodge_elapsed = field_dodge_elapsed.prepare(builder, &0.0);
                    let prepared_dodge_dir = field_dodge_dir.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<48> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<self::Physics>(0);
                    table_writer.write_entry::<self::ScoreInfo>(1);
                    table_writer.write_entry::<::planus::Offset<self::BoxShape>>(2);
                    table_writer.write_entry::<self::Vector3>(3);
                    if prepared_latest_touch.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::Touch>>(4);
                    }
                    if prepared_dodge_timeout.is_some() {
                        table_writer.write_entry::<f32>(6);
                    }
                    if prepared_demolished_timeout.is_some() {
                        table_writer.write_entry::<f32>(7);
                    }
                    table_writer.write_entry::<::planus::Offset<str>>(10);
                    if prepared_team.is_some() {
                        table_writer.write_entry::<u32>(11);
                    }
                    if prepared_boost.is_some() {
                        table_writer.write_entry::<u32>(12);
                    }
                    if prepared_spawn_id.is_some() {
                        table_writer.write_entry::<i32>(13);
                    }
                    table_writer.write_entry::<::planus::Offset<[::planus::Offset<str>]>>(14);
                    table_writer.write_entry::<self::ControllerState>(15);
                    if prepared_dodge_elapsed.is_some() {
                        table_writer.write_entry::<f32>(20);
                    }
                    table_writer.write_entry::<self::Vector2>(21);
                    if prepared_air_state.is_some() {
                        table_writer.write_entry::<self::AirState>(5);
                    }
                    if prepared_is_supersonic.is_some() {
                        table_writer.write_entry::<bool>(8);
                    }
                    if prepared_is_bot.is_some() {
                        table_writer.write_entry::<bool>(9);
                    }
                    if prepared_last_spectated.is_some() {
                        table_writer.write_entry::<bool>(16);
                    }
                    if prepared_has_jumped.is_some() {
                        table_writer.write_entry::<bool>(17);
                    }
                    if prepared_has_double_jumped.is_some() {
                        table_writer.write_entry::<bool>(18);
                    }
                    if prepared_has_dodged.is_some() {
                        table_writer.write_entry::<bool>(19);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 48>(&prepared_physics);
                            object_writer.write::<_, _, 28>(&prepared_score_info);
                            object_writer.write::<_, _, 4>(&prepared_hitbox);
                            object_writer.write::<_, _, 12>(&prepared_hitbox_offset);
                            if let ::core::option::Option::Some(prepared_latest_touch) =
                                prepared_latest_touch
                            {
                                object_writer.write::<_, _, 4>(&prepared_latest_touch);
                            }
                            if let ::core::option::Option::Some(prepared_dodge_timeout) =
                                prepared_dodge_timeout
                            {
                                object_writer.write::<_, _, 4>(&prepared_dodge_timeout);
                            }
                            if let ::core::option::Option::Some(prepared_demolished_timeout) =
                                prepared_demolished_timeout
                            {
                                object_writer.write::<_, _, 4>(&prepared_demolished_timeout);
                            }
                            object_writer.write::<_, _, 4>(&prepared_name);
                            if let ::core::option::Option::Some(prepared_team) = prepared_team {
                                object_writer.write::<_, _, 4>(&prepared_team);
                            }
                            if let ::core::option::Option::Some(prepared_boost) = prepared_boost {
                                object_writer.write::<_, _, 4>(&prepared_boost);
                            }
                            if let ::core::option::Option::Some(prepared_spawn_id) =
                                prepared_spawn_id
                            {
                                object_writer.write::<_, _, 4>(&prepared_spawn_id);
                            }
                            object_writer.write::<_, _, 4>(&prepared_accolades);
                            object_writer.write::<_, _, 24>(&prepared_last_input);
                            if let ::core::option::Option::Some(prepared_dodge_elapsed) =
                                prepared_dodge_elapsed
                            {
                                object_writer.write::<_, _, 4>(&prepared_dodge_elapsed);
                            }
                            object_writer.write::<_, _, 8>(&prepared_dodge_dir);
                            if let ::core::option::Option::Some(prepared_air_state) =
                                prepared_air_state
                            {
                                object_writer.write::<_, _, 1>(&prepared_air_state);
                            }
                            if let ::core::option::Option::Some(prepared_is_supersonic) =
                                prepared_is_supersonic
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_supersonic);
                            }
                            if let ::core::option::Option::Some(prepared_is_bot) = prepared_is_bot {
                                object_writer.write::<_, _, 1>(&prepared_is_bot);
                            }
                            if let ::core::option::Option::Some(prepared_last_spectated) =
                                prepared_last_spectated
                            {
                                object_writer.write::<_, _, 1>(&prepared_last_spectated);
                            }
                            if let ::core::option::Option::Some(prepared_has_jumped) =
                                prepared_has_jumped
                            {
                                object_writer.write::<_, _, 1>(&prepared_has_jumped);
                            }
                            if let ::core::option::Option::Some(prepared_has_double_jumped) =
                                prepared_has_double_jumped
                            {
                                object_writer.write::<_, _, 1>(&prepared_has_double_jumped);
                            }
                            if let ::core::option::Option::Some(prepared_has_dodged) =
                                prepared_has_dodged
                            {
                                object_writer.write::<_, _, 1>(&prepared_has_dodged);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PlayerInfo>> for PlayerInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PlayerInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PlayerInfo>> for PlayerInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PlayerInfo> for PlayerInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PlayerInfo> {
                    PlayerInfo::create(
                        builder,
                        self.physics,
                        self.score_info,
                        &self.hitbox,
                        self.hitbox_offset,
                        &self.latest_touch,
                        self.air_state,
                        self.dodge_timeout,
                        self.demolished_timeout,
                        self.is_supersonic,
                        self.is_bot,
                        &self.name,
                        self.team,
                        self.boost,
                        self.spawn_id,
                        &self.accolades,
                        self.last_input,
                        self.last_spectated,
                        self.has_jumped,
                        self.has_double_jumped,
                        self.has_dodged,
                        self.dodge_elapsed,
                        self.dodge_dir,
                    )
                }
            }

            /// Builder for serializing an instance of the [PlayerInfo] type.
            ///
            /// Can be created using the [PlayerInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PlayerInfoBuilder<State>(State);

            impl PlayerInfoBuilder<()> {
                /// Setter for the [`physics` field](PlayerInfo#structfield.physics).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn physics<T0>(self, value: T0) -> PlayerInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<self::Physics>,
                {
                    PlayerInfoBuilder((value,))
                }
            }

            impl<T0> PlayerInfoBuilder<(T0,)> {
                /// Setter for the [`score_info` field](PlayerInfo#structfield.score_info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn score_info<T1>(self, value: T1) -> PlayerInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::ScoreInfo>,
                {
                    let (v0,) = self.0;
                    PlayerInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> PlayerInfoBuilder<(T0, T1)> {
                /// Setter for the [`hitbox` field](PlayerInfo#structfield.hitbox).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hitbox<T2>(self, value: T2) -> PlayerInfoBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<self::BoxShape>>,
                {
                    let (v0, v1) = self.0;
                    PlayerInfoBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> PlayerInfoBuilder<(T0, T1, T2)> {
                /// Setter for the [`hitbox_offset` field](PlayerInfo#structfield.hitbox_offset).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn hitbox_offset<T3>(self, value: T3) -> PlayerInfoBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0, v1, v2) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> PlayerInfoBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`latest_touch` field](PlayerInfo#structfield.latest_touch).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn latest_touch<T4>(self, value: T4) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsOptional<::planus::Offset<self::Touch>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`latest_touch` field](PlayerInfo#structfield.latest_touch) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn latest_touch_as_null(self) -> PlayerInfoBuilder<(T0, T1, T2, T3, ())> {
                    self.latest_touch(())
                }
            }

            impl<T0, T1, T2, T3, T4> PlayerInfoBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`air_state` field](PlayerInfo#structfield.air_state).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn air_state<T5>(self, value: T5) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<self::AirState, self::AirState>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`air_state` field](PlayerInfo#structfield.air_state) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn air_state_as_default(
                    self,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)>
                {
                    self.air_state(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`dodge_timeout` field](PlayerInfo#structfield.dodge_timeout).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dodge_timeout<T6>(
                    self,
                    value: T6,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`dodge_timeout` field](PlayerInfo#structfield.dodge_timeout) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dodge_timeout_as_default(
                    self,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.dodge_timeout(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`demolished_timeout` field](PlayerInfo#structfield.demolished_timeout).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn demolished_timeout<T7>(
                    self,
                    value: T7,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`demolished_timeout` field](PlayerInfo#structfield.demolished_timeout) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn demolished_timeout_as_default(
                    self,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.demolished_timeout(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Setter for the [`is_supersonic` field](PlayerInfo#structfield.is_supersonic).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_supersonic<T8>(
                    self,
                    value: T8,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)>
                where
                    T8: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, v7, value))
                }

                /// Sets the [`is_supersonic` field](PlayerInfo#structfield.is_supersonic) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_supersonic_as_default(
                    self,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, ::planus::DefaultValue)>
                {
                    self.is_supersonic(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8)> {
                /// Setter for the [`is_bot` field](PlayerInfo#structfield.is_bot).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_bot<T9>(
                    self,
                    value: T9,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
                where
                    T9: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, value))
                }

                /// Sets the [`is_bot` field](PlayerInfo#structfield.is_bot) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_bot_as_default(
                    self,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, ::planus::DefaultValue)>
                {
                    self.is_bot(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
                PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9)>
            {
                /// Setter for the [`name` field](PlayerInfo#structfield.name).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn name<T10>(
                    self,
                    value: T10,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
                where
                    T10: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>
                PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
            {
                /// Setter for the [`team` field](PlayerInfo#structfield.team).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team<T11>(
                    self,
                    value: T11,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
                where
                    T11: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, value))
                }

                /// Sets the [`team` field](PlayerInfo#structfield.team) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    ::planus::DefaultValue,
                )> {
                    self.team(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
                PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)>
            {
                /// Setter for the [`boost` field](PlayerInfo#structfield.boost).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost<T12>(
                    self,
                    value: T12,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
                where
                    T12: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) = self.0;
                    PlayerInfoBuilder((v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, value))
                }

                /// Sets the [`boost` field](PlayerInfo#structfield.boost) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    ::planus::DefaultValue,
                )> {
                    self.boost(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>
                PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)>
            {
                /// Setter for the [`spawn_id` field](PlayerInfo#structfield.spawn_id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id<T13>(
                    self,
                    value: T13,
                ) -> PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
                where
                    T13: ::planus::WriteAsDefault<i32, i32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, value,
                    ))
                }

                /// Sets the [`spawn_id` field](PlayerInfo#structfield.spawn_id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn spawn_id_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    ::planus::DefaultValue,
                )> {
                    self.spawn_id(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>
                PlayerInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)>
            {
                /// Setter for the [`accolades` field](PlayerInfo#structfield.accolades).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn accolades<T14>(
                    self,
                    value: T14,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
                where
                    T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, value,
                    ))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                )>
            {
                /// Setter for the [`last_input` field](PlayerInfo#structfield.last_input).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn last_input<T15>(
                    self,
                    value: T15,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
                where
                    T15: ::planus::WriteAs<self::ControllerState>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, value,
                    ))
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                )>
            {
                /// Setter for the [`last_spectated` field](PlayerInfo#structfield.last_spectated).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn last_spectated<T16>(
                    self,
                    value: T16,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
                where
                    T16: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) =
                        self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, value,
                    ))
                }

                /// Sets the [`last_spectated` field](PlayerInfo#structfield.last_spectated) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn last_spectated_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    ::planus::DefaultValue,
                )> {
                    self.last_spectated(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                )>
            {
                /// Setter for the [`has_jumped` field](PlayerInfo#structfield.has_jumped).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_jumped<T17>(
                    self,
                    value: T17,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
                where
                    T17: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) =
                        self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        value,
                    ))
                }

                /// Sets the [`has_jumped` field](PlayerInfo#structfield.has_jumped) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_jumped_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    ::planus::DefaultValue,
                )> {
                    self.has_jumped(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                >
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                )>
            {
                /// Setter for the [`has_double_jumped` field](PlayerInfo#structfield.has_double_jumped).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_double_jumped<T18>(
                    self,
                    value: T18,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
                where
                    T18: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                    ) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, value,
                    ))
                }

                /// Sets the [`has_double_jumped` field](PlayerInfo#structfield.has_double_jumped) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_double_jumped_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    ::planus::DefaultValue,
                )> {
                    self.has_double_jumped(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                >
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                )>
            {
                /// Setter for the [`has_dodged` field](PlayerInfo#structfield.has_dodged).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_dodged<T19>(
                    self,
                    value: T19,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
                where
                    T19: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                    ) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, value,
                    ))
                }

                /// Sets the [`has_dodged` field](PlayerInfo#structfield.has_dodged) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn has_dodged_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    ::planus::DefaultValue,
                )> {
                    self.has_dodged(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                >
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                )>
            {
                /// Setter for the [`dodge_elapsed` field](PlayerInfo#structfield.dodge_elapsed).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dodge_elapsed<T20>(
                    self,
                    value: T20,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                )>
                where
                    T20: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                    ) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, value,
                    ))
                }

                /// Sets the [`dodge_elapsed` field](PlayerInfo#structfield.dodge_elapsed) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dodge_elapsed_as_default(
                    self,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    ::planus::DefaultValue,
                )> {
                    self.dodge_elapsed(::planus::DefaultValue)
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                >
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                )>
            {
                /// Setter for the [`dodge_dir` field](PlayerInfo#structfield.dodge_dir).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn dodge_dir<T21>(
                    self,
                    value: T21,
                ) -> PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
                where
                    T21: ::planus::WriteAs<self::Vector2>,
                {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                    ) = self.0;
                    PlayerInfoBuilder((
                        v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,
                        v17, v18, v19, v20, value,
                    ))
                }
            }

            impl<
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                >
                PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
            {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PlayerInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PlayerInfo>
                where
                    Self: ::planus::WriteAsOffset<PlayerInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAs<self::ScoreInfo>,
                    T2: ::planus::WriteAs<::planus::Offset<self::BoxShape>>,
                    T3: ::planus::WriteAs<self::Vector3>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<self::Touch>>,
                    T5: ::planus::WriteAsDefault<self::AirState, self::AirState>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<f32, f32>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAs<::planus::Offset<str>>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<i32, i32>,
                    T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T15: ::planus::WriteAs<self::ControllerState>,
                    T16: ::planus::WriteAsDefault<bool, bool>,
                    T17: ::planus::WriteAsDefault<bool, bool>,
                    T18: ::planus::WriteAsDefault<bool, bool>,
                    T19: ::planus::WriteAsDefault<bool, bool>,
                    T20: ::planus::WriteAsDefault<f32, f32>,
                    T21: ::planus::WriteAs<self::Vector2>,
                > ::planus::WriteAs<::planus::Offset<PlayerInfo>>
                for PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
            {
                type Prepared = ::planus::Offset<PlayerInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PlayerInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAs<self::ScoreInfo>,
                    T2: ::planus::WriteAs<::planus::Offset<self::BoxShape>>,
                    T3: ::planus::WriteAs<self::Vector3>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<self::Touch>>,
                    T5: ::planus::WriteAsDefault<self::AirState, self::AirState>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<f32, f32>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAs<::planus::Offset<str>>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<i32, i32>,
                    T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T15: ::planus::WriteAs<self::ControllerState>,
                    T16: ::planus::WriteAsDefault<bool, bool>,
                    T17: ::planus::WriteAsDefault<bool, bool>,
                    T18: ::planus::WriteAsDefault<bool, bool>,
                    T19: ::planus::WriteAsDefault<bool, bool>,
                    T20: ::planus::WriteAsDefault<f32, f32>,
                    T21: ::planus::WriteAs<self::Vector2>,
                > ::planus::WriteAsOptional<::planus::Offset<PlayerInfo>>
                for PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
            {
                type Prepared = ::planus::Offset<PlayerInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PlayerInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAs<self::ScoreInfo>,
                    T2: ::planus::WriteAs<::planus::Offset<self::BoxShape>>,
                    T3: ::planus::WriteAs<self::Vector3>,
                    T4: ::planus::WriteAsOptional<::planus::Offset<self::Touch>>,
                    T5: ::planus::WriteAsDefault<self::AirState, self::AirState>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<f32, f32>,
                    T8: ::planus::WriteAsDefault<bool, bool>,
                    T9: ::planus::WriteAsDefault<bool, bool>,
                    T10: ::planus::WriteAs<::planus::Offset<str>>,
                    T11: ::planus::WriteAsDefault<u32, u32>,
                    T12: ::planus::WriteAsDefault<u32, u32>,
                    T13: ::planus::WriteAsDefault<i32, i32>,
                    T14: ::planus::WriteAs<::planus::Offset<[::planus::Offset<str>]>>,
                    T15: ::planus::WriteAs<self::ControllerState>,
                    T16: ::planus::WriteAsDefault<bool, bool>,
                    T17: ::planus::WriteAsDefault<bool, bool>,
                    T18: ::planus::WriteAsDefault<bool, bool>,
                    T19: ::planus::WriteAsDefault<bool, bool>,
                    T20: ::planus::WriteAsDefault<f32, f32>,
                    T21: ::planus::WriteAs<self::Vector2>,
                > ::planus::WriteAsOffset<PlayerInfo>
                for PlayerInfoBuilder<(
                    T0,
                    T1,
                    T2,
                    T3,
                    T4,
                    T5,
                    T6,
                    T7,
                    T8,
                    T9,
                    T10,
                    T11,
                    T12,
                    T13,
                    T14,
                    T15,
                    T16,
                    T17,
                    T18,
                    T19,
                    T20,
                    T21,
                )>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PlayerInfo> {
                    let (
                        v0,
                        v1,
                        v2,
                        v3,
                        v4,
                        v5,
                        v6,
                        v7,
                        v8,
                        v9,
                        v10,
                        v11,
                        v12,
                        v13,
                        v14,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20,
                        v21,
                    ) = &self.0;
                    PlayerInfo::create(
                        builder, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
                        v15, v16, v17, v18, v19, v20, v21,
                    )
                }
            }

            /// Reference to a deserialized [PlayerInfo].
            #[derive(Copy, Clone)]
            pub struct PlayerInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PlayerInfoRef<'a> {
                /// Getter for the [`physics` field](PlayerInfo#structfield.physics).
                #[inline]
                pub fn physics(&self) -> ::planus::Result<self::PhysicsRef<'a>> {
                    self.0.access_required(0, "PlayerInfo", "physics")
                }

                /// Getter for the [`score_info` field](PlayerInfo#structfield.score_info).
                #[inline]
                pub fn score_info(&self) -> ::planus::Result<self::ScoreInfoRef<'a>> {
                    self.0.access_required(1, "PlayerInfo", "score_info")
                }

                /// Getter for the [`hitbox` field](PlayerInfo#structfield.hitbox).
                #[inline]
                pub fn hitbox(&self) -> ::planus::Result<self::BoxShapeRef<'a>> {
                    self.0.access_required(2, "PlayerInfo", "hitbox")
                }

                /// Getter for the [`hitbox_offset` field](PlayerInfo#structfield.hitbox_offset).
                #[inline]
                pub fn hitbox_offset(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(3, "PlayerInfo", "hitbox_offset")
                }

                /// Getter for the [`latest_touch` field](PlayerInfo#structfield.latest_touch).
                #[inline]
                pub fn latest_touch(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::TouchRef<'a>>> {
                    self.0.access(4, "PlayerInfo", "latest_touch")
                }

                /// Getter for the [`air_state` field](PlayerInfo#structfield.air_state).
                #[inline]
                pub fn air_state(&self) -> ::planus::Result<self::AirState> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "PlayerInfo", "air_state")?
                            .unwrap_or(self::AirState::OnGround),
                    )
                }

                /// Getter for the [`dodge_timeout` field](PlayerInfo#structfield.dodge_timeout).
                #[inline]
                pub fn dodge_timeout(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "PlayerInfo", "dodge_timeout")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`demolished_timeout` field](PlayerInfo#structfield.demolished_timeout).
                #[inline]
                pub fn demolished_timeout(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "PlayerInfo", "demolished_timeout")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`is_supersonic` field](PlayerInfo#structfield.is_supersonic).
                #[inline]
                pub fn is_supersonic(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(8, "PlayerInfo", "is_supersonic")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`is_bot` field](PlayerInfo#structfield.is_bot).
                #[inline]
                pub fn is_bot(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(9, "PlayerInfo", "is_bot")?.unwrap_or(false),
                    )
                }

                /// Getter for the [`name` field](PlayerInfo#structfield.name).
                #[inline]
                pub fn name(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(10, "PlayerInfo", "name")
                }

                /// Getter for the [`team` field](PlayerInfo#structfield.team).
                #[inline]
                pub fn team(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(11, "PlayerInfo", "team")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`boost` field](PlayerInfo#structfield.boost).
                #[inline]
                pub fn boost(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(12, "PlayerInfo", "boost")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`spawn_id` field](PlayerInfo#structfield.spawn_id).
                #[inline]
                pub fn spawn_id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0.access(13, "PlayerInfo", "spawn_id")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`accolades` field](PlayerInfo#structfield.accolades).
                #[inline]
                pub fn accolades(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<&'a ::core::primitive::str>>,
                > {
                    self.0.access_required(14, "PlayerInfo", "accolades")
                }

                /// Getter for the [`last_input` field](PlayerInfo#structfield.last_input).
                #[inline]
                pub fn last_input(&self) -> ::planus::Result<self::ControllerStateRef<'a>> {
                    self.0.access_required(15, "PlayerInfo", "last_input")
                }

                /// Getter for the [`last_spectated` field](PlayerInfo#structfield.last_spectated).
                #[inline]
                pub fn last_spectated(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(16, "PlayerInfo", "last_spectated")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`has_jumped` field](PlayerInfo#structfield.has_jumped).
                #[inline]
                pub fn has_jumped(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(17, "PlayerInfo", "has_jumped")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`has_double_jumped` field](PlayerInfo#structfield.has_double_jumped).
                #[inline]
                pub fn has_double_jumped(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(18, "PlayerInfo", "has_double_jumped")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`has_dodged` field](PlayerInfo#structfield.has_dodged).
                #[inline]
                pub fn has_dodged(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(19, "PlayerInfo", "has_dodged")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`dodge_elapsed` field](PlayerInfo#structfield.dodge_elapsed).
                #[inline]
                pub fn dodge_elapsed(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(20, "PlayerInfo", "dodge_elapsed")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`dodge_dir` field](PlayerInfo#structfield.dodge_dir).
                #[inline]
                pub fn dodge_dir(&self) -> ::planus::Result<self::Vector2Ref<'a>> {
                    self.0.access_required(21, "PlayerInfo", "dodge_dir")
                }
            }

            impl<'a> ::core::fmt::Debug for PlayerInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PlayerInfoRef");
                    f.field("physics", &self.physics());
                    f.field("score_info", &self.score_info());
                    f.field("hitbox", &self.hitbox());
                    f.field("hitbox_offset", &self.hitbox_offset());
                    if let ::core::option::Option::Some(field_latest_touch) =
                        self.latest_touch().transpose()
                    {
                        f.field("latest_touch", &field_latest_touch);
                    }
                    f.field("air_state", &self.air_state());
                    f.field("dodge_timeout", &self.dodge_timeout());
                    f.field("demolished_timeout", &self.demolished_timeout());
                    f.field("is_supersonic", &self.is_supersonic());
                    f.field("is_bot", &self.is_bot());
                    f.field("name", &self.name());
                    f.field("team", &self.team());
                    f.field("boost", &self.boost());
                    f.field("spawn_id", &self.spawn_id());
                    f.field("accolades", &self.accolades());
                    f.field("last_input", &self.last_input());
                    f.field("last_spectated", &self.last_spectated());
                    f.field("has_jumped", &self.has_jumped());
                    f.field("has_double_jumped", &self.has_double_jumped());
                    f.field("has_dodged", &self.has_dodged());
                    f.field("dodge_elapsed", &self.dodge_elapsed());
                    f.field("dodge_dir", &self.dodge_dir());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PlayerInfoRef<'a>> for PlayerInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PlayerInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        physics: ::core::convert::Into::into(value.physics()?),
                        score_info: ::core::convert::Into::into(value.score_info()?),
                        hitbox: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.hitbox()?)?,
                        ),
                        hitbox_offset: ::core::convert::Into::into(value.hitbox_offset()?),
                        latest_touch: if let ::core::option::Option::Some(latest_touch) =
                            value.latest_touch()?
                        {
                            ::core::option::Option::Some(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryInto::try_into(latest_touch)?,
                            ))
                        } else {
                            ::core::option::Option::None
                        },
                        air_state: ::core::convert::TryInto::try_into(value.air_state()?)?,
                        dodge_timeout: ::core::convert::TryInto::try_into(value.dodge_timeout()?)?,
                        demolished_timeout: ::core::convert::TryInto::try_into(
                            value.demolished_timeout()?,
                        )?,
                        is_supersonic: ::core::convert::TryInto::try_into(value.is_supersonic()?)?,
                        is_bot: ::core::convert::TryInto::try_into(value.is_bot()?)?,
                        name: ::core::convert::Into::into(value.name()?),
                        team: ::core::convert::TryInto::try_into(value.team()?)?,
                        boost: ::core::convert::TryInto::try_into(value.boost()?)?,
                        spawn_id: ::core::convert::TryInto::try_into(value.spawn_id()?)?,
                        accolades: value.accolades()?.to_vec_result()?,
                        last_input: ::core::convert::Into::into(value.last_input()?),
                        last_spectated: ::core::convert::TryInto::try_into(
                            value.last_spectated()?,
                        )?,
                        has_jumped: ::core::convert::TryInto::try_into(value.has_jumped()?)?,
                        has_double_jumped: ::core::convert::TryInto::try_into(
                            value.has_double_jumped()?,
                        )?,
                        has_dodged: ::core::convert::TryInto::try_into(value.has_dodged()?)?,
                        dodge_elapsed: ::core::convert::TryInto::try_into(value.dodge_elapsed()?)?,
                        dodge_dir: ::core::convert::Into::into(value.dodge_dir()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PlayerInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PlayerInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PlayerInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PlayerInfo>> for PlayerInfo {
                type Value = ::planus::Offset<PlayerInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PlayerInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PlayerInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PlayerInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `BallInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `BallInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:184`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BallInfo {
                /// The field `physics` in the table `BallInfo`
                pub physics: self::Physics,
                /// The field `shape` in the table `BallInfo`
                pub shape: self::CollisionShape,
            }

            impl BallInfo {
                /// Creates a [BallInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BallInfoBuilder<()> {
                    BallInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_physics: impl ::planus::WriteAs<self::Physics>,
                    field_shape: impl ::planus::WriteAsUnion<self::CollisionShape>,
                ) -> ::planus::Offset<Self> {
                    let prepared_physics = field_physics.prepare(builder);
                    let prepared_shape = field_shape.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<self::Physics>(0);
                    table_writer.write_entry::<::planus::Offset<self::CollisionShape>>(2);
                    table_writer.write_entry::<u8>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 48>(&prepared_physics);
                            object_writer.write::<_, _, 4>(&prepared_shape.offset());
                            object_writer.write::<_, _, 1>(&prepared_shape.tag());
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BallInfo>> for BallInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BallInfo>> for BallInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BallInfo> for BallInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallInfo> {
                    BallInfo::create(builder, self.physics, &self.shape)
                }
            }

            /// Builder for serializing an instance of the [BallInfo] type.
            ///
            /// Can be created using the [BallInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BallInfoBuilder<State>(State);

            impl BallInfoBuilder<()> {
                /// Setter for the [`physics` field](BallInfo#structfield.physics).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn physics<T0>(self, value: T0) -> BallInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<self::Physics>,
                {
                    BallInfoBuilder((value,))
                }
            }

            impl<T0> BallInfoBuilder<(T0,)> {
                /// Setter for the [`shape` field](BallInfo#structfield.shape).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn shape<T1>(self, value: T1) -> BallInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsUnion<self::CollisionShape>,
                {
                    let (v0,) = self.0;
                    BallInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> BallInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BallInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallInfo>
                where
                    Self: ::planus::WriteAsOffset<BallInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAsUnion<self::CollisionShape>,
                > ::planus::WriteAs<::planus::Offset<BallInfo>> for BallInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BallInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAsUnion<self::CollisionShape>,
                > ::planus::WriteAsOptional<::planus::Offset<BallInfo>>
                for BallInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BallInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Physics>,
                    T1: ::planus::WriteAsUnion<self::CollisionShape>,
                > ::planus::WriteAsOffset<BallInfo> for BallInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallInfo> {
                    let (v0, v1) = &self.0;
                    BallInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [BallInfo].
            #[derive(Copy, Clone)]
            pub struct BallInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BallInfoRef<'a> {
                /// Getter for the [`physics` field](BallInfo#structfield.physics).
                #[inline]
                pub fn physics(&self) -> ::planus::Result<self::PhysicsRef<'a>> {
                    self.0.access_required(0, "BallInfo", "physics")
                }

                /// Getter for the [`shape` field](BallInfo#structfield.shape).
                #[inline]
                pub fn shape(&self) -> ::planus::Result<self::CollisionShapeRef<'a>> {
                    self.0.access_union_required(1, "BallInfo", "shape")
                }
            }

            impl<'a> ::core::fmt::Debug for BallInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BallInfoRef");
                    f.field("physics", &self.physics());
                    f.field("shape", &self.shape());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BallInfoRef<'a>> for BallInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BallInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        physics: ::core::convert::Into::into(value.physics()?),
                        shape: ::core::convert::TryInto::try_into(value.shape()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BallInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BallInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BallInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BallInfo>> for BallInfo {
                type Value = ::planus::Offset<BallInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BallInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BallInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BallInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `BoostPadState` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `BoostPadState` in the file `rlbot/flatbuffers-schema/rlbot.fbs:189`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct BoostPadState {
                ///  True if the boost can be picked up
                pub is_active: bool,

                ///  The number of seconds since the boost has been picked up, or 0.0 if the boost is active.
                pub timer: f32,
            }

            impl ::planus::Primitive for BoostPadState {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 8;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<BoostPadState> for BoostPadState {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<1, 7>();
                    self.is_active.write(cur, buffer_position - 0);
                    let cursor = cursor.write::<3, 4>([0; 3]);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.timer.write(cur, buffer_position - 4);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<BoostPadState> for BoostPadState {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BoostPadState> {
                    unsafe {
                        builder.write_with(8, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 8]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<BoostPadState> for BoostPadState {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<BoostPadState> for BoostPadState {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [BoostPadState].
            #[derive(Copy, Clone)]
            pub struct BoostPadStateRef<'a>(::planus::ArrayWithStartOffset<'a, 8>);

            impl<'a> BoostPadStateRef<'a> {
                /// Getter for the [`is_active` field](BoostPadState#structfield.is_active).
                pub fn is_active(&self) -> bool {
                    let buffer = self.0.advance_as_array::<1>(0).unwrap();

                    buffer.as_array()[0] != 0
                }

                /// Getter for the [`timer` field](BoostPadState#structfield.timer).
                pub fn timer(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for BoostPadStateRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BoostPadStateRef");
                    f.field("is_active", &self.is_active());
                    f.field("timer", &self.timer());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 8>> for BoostPadStateRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 8>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<BoostPadStateRef<'a>> for BoostPadState {
                #[allow(unreachable_code)]
                fn from(value: BoostPadStateRef<'a>) -> Self {
                    Self {
                        is_active: value.is_active(),
                        timer: value.timer(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<BoostPadStateRef<'a>> for BoostPadStateRef<'b> {
                fn eq(&self, other: &BoostPadStateRef<'_>) -> bool {
                    self.is_active() == other.is_active() && self.timer() == other.timer()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<BoostPadStateRef<'a>> for BoostPadStateRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &BoostPadStateRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.is_active().partial_cmp(&other.is_active()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.timer().partial_cmp(&other.timer())
                }
            }

            impl<'a> ::planus::TableRead<'a> for BoostPadStateRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<8>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for BoostPadStateRef<'a> {
                const STRIDE: usize = 8;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<BoostPadState> for BoostPadState {
                const STRIDE: usize = 8;

                type Value = BoostPadState;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[BoostPadState],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 8];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (8 * i) as u32,
                        );
                    }
                }
            }

            /// The enum `GameStatus` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `GameStatus` in the file `rlbot/flatbuffers-schema/rlbot.fbs:196`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum GameStatus {
                ///  Game has not been created yet
                Inactive = 0,

                ///  3-2-1 countdown
                Countdown = 1,

                ///  After countdown, but before ball has been hit
                Kickoff = 2,

                ///  Ball has been hit
                Active = 3,

                ///  A goal was scored. Waiting for replay.
                GoalScored = 4,

                ///  Watching replay
                Replay = 5,

                ///  Game paused
                Paused = 6,

                ///  Match has ended
                Ended = 7,
            }

            impl GameStatus {
                /// Array containing all valid variants of GameStatus
                pub const ENUM_VALUES: [Self; 8] = [
                    Self::Inactive,
                    Self::Countdown,
                    Self::Kickoff,
                    Self::Active,
                    Self::GoalScored,
                    Self::Replay,
                    Self::Paused,
                    Self::Ended,
                ];
            }

            impl ::core::convert::TryFrom<u8> for GameStatus {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(GameStatus::Inactive),
                        1 => ::core::result::Result::Ok(GameStatus::Countdown),
                        2 => ::core::result::Result::Ok(GameStatus::Kickoff),
                        3 => ::core::result::Result::Ok(GameStatus::Active),
                        4 => ::core::result::Result::Ok(GameStatus::GoalScored),
                        5 => ::core::result::Result::Ok(GameStatus::Replay),
                        6 => ::core::result::Result::Ok(GameStatus::Paused),
                        7 => ::core::result::Result::Ok(GameStatus::Ended),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<GameStatus> for u8 {
                #[inline]
                fn from(value: GameStatus) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for GameStatus {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<GameStatus> for GameStatus {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<GameStatus> for GameStatus {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> GameStatus {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<GameStatus, GameStatus> for GameStatus {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &GameStatus,
                ) -> ::core::option::Option<GameStatus> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<GameStatus> for GameStatus {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<GameStatus> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for GameStatus {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for GameStatus {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "GameStatus",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<GameStatus> for GameStatus {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The table `GameInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `GameInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:215`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GameInfo {
                /// The field `seconds_elapsed` in the table `GameInfo`
                pub seconds_elapsed: f32,
                /// The field `game_time_remaining` in the table `GameInfo`
                pub game_time_remaining: f32,
                /// The field `is_overtime` in the table `GameInfo`
                pub is_overtime: bool,
                /// The field `is_unlimited_time` in the table `GameInfo`
                pub is_unlimited_time: bool,
                /// The field `game_status` in the table `GameInfo`
                pub game_status: self::GameStatus,
                /// The field `world_gravity_z` in the table `GameInfo`
                pub world_gravity_z: f32,
                ///  Game speed multiplier, 1.0 is regular game speed.
                pub game_speed: f32,
                ///  Tracks the number of physics frames the game has computed.
                ///  May increase by more than one across consecutive packets.
                ///  Data type will roll over after 207 days at 120Hz.
                pub frame_num: u32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GameInfo {
                fn default() -> Self {
                    Self {
                        seconds_elapsed: 0.0,
                        game_time_remaining: 0.0,
                        is_overtime: false,
                        is_unlimited_time: false,
                        game_status: self::GameStatus::Inactive,
                        world_gravity_z: 0.0,
                        game_speed: 0.0,
                        frame_num: 0,
                    }
                }
            }

            impl GameInfo {
                /// Creates a [GameInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GameInfoBuilder<()> {
                    GameInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_seconds_elapsed: impl ::planus::WriteAsDefault<f32, f32>,
                    field_game_time_remaining: impl ::planus::WriteAsDefault<f32, f32>,
                    field_is_overtime: impl ::planus::WriteAsDefault<bool, bool>,
                    field_is_unlimited_time: impl ::planus::WriteAsDefault<bool, bool>,
                    field_game_status: impl ::planus::WriteAsDefault<self::GameStatus, self::GameStatus>,
                    field_world_gravity_z: impl ::planus::WriteAsDefault<f32, f32>,
                    field_game_speed: impl ::planus::WriteAsDefault<f32, f32>,
                    field_frame_num: impl ::planus::WriteAsDefault<u32, u32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_seconds_elapsed = field_seconds_elapsed.prepare(builder, &0.0);
                    let prepared_game_time_remaining =
                        field_game_time_remaining.prepare(builder, &0.0);
                    let prepared_is_overtime = field_is_overtime.prepare(builder, &false);
                    let prepared_is_unlimited_time =
                        field_is_unlimited_time.prepare(builder, &false);
                    let prepared_game_status =
                        field_game_status.prepare(builder, &self::GameStatus::Inactive);
                    let prepared_world_gravity_z = field_world_gravity_z.prepare(builder, &0.0);
                    let prepared_game_speed = field_game_speed.prepare(builder, &0.0);
                    let prepared_frame_num = field_frame_num.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    if prepared_seconds_elapsed.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }
                    if prepared_game_time_remaining.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }
                    if prepared_world_gravity_z.is_some() {
                        table_writer.write_entry::<f32>(5);
                    }
                    if prepared_game_speed.is_some() {
                        table_writer.write_entry::<f32>(6);
                    }
                    if prepared_frame_num.is_some() {
                        table_writer.write_entry::<u32>(7);
                    }
                    if prepared_is_overtime.is_some() {
                        table_writer.write_entry::<bool>(2);
                    }
                    if prepared_is_unlimited_time.is_some() {
                        table_writer.write_entry::<bool>(3);
                    }
                    if prepared_game_status.is_some() {
                        table_writer.write_entry::<self::GameStatus>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_seconds_elapsed) =
                                prepared_seconds_elapsed
                            {
                                object_writer.write::<_, _, 4>(&prepared_seconds_elapsed);
                            }
                            if let ::core::option::Option::Some(prepared_game_time_remaining) =
                                prepared_game_time_remaining
                            {
                                object_writer.write::<_, _, 4>(&prepared_game_time_remaining);
                            }
                            if let ::core::option::Option::Some(prepared_world_gravity_z) =
                                prepared_world_gravity_z
                            {
                                object_writer.write::<_, _, 4>(&prepared_world_gravity_z);
                            }
                            if let ::core::option::Option::Some(prepared_game_speed) =
                                prepared_game_speed
                            {
                                object_writer.write::<_, _, 4>(&prepared_game_speed);
                            }
                            if let ::core::option::Option::Some(prepared_frame_num) =
                                prepared_frame_num
                            {
                                object_writer.write::<_, _, 4>(&prepared_frame_num);
                            }
                            if let ::core::option::Option::Some(prepared_is_overtime) =
                                prepared_is_overtime
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_overtime);
                            }
                            if let ::core::option::Option::Some(prepared_is_unlimited_time) =
                                prepared_is_unlimited_time
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_unlimited_time);
                            }
                            if let ::core::option::Option::Some(prepared_game_status) =
                                prepared_game_status
                            {
                                object_writer.write::<_, _, 1>(&prepared_game_status);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GameInfo>> for GameInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GameInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GameInfo>> for GameInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GameInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GameInfo> for GameInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GameInfo> {
                    GameInfo::create(
                        builder,
                        self.seconds_elapsed,
                        self.game_time_remaining,
                        self.is_overtime,
                        self.is_unlimited_time,
                        self.game_status,
                        self.world_gravity_z,
                        self.game_speed,
                        self.frame_num,
                    )
                }
            }

            /// Builder for serializing an instance of the [GameInfo] type.
            ///
            /// Can be created using the [GameInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GameInfoBuilder<State>(State);

            impl GameInfoBuilder<()> {
                /// Setter for the [`seconds_elapsed` field](GameInfo#structfield.seconds_elapsed).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn seconds_elapsed<T0>(self, value: T0) -> GameInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    GameInfoBuilder((value,))
                }

                /// Sets the [`seconds_elapsed` field](GameInfo#structfield.seconds_elapsed) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn seconds_elapsed_as_default(
                    self,
                ) -> GameInfoBuilder<(::planus::DefaultValue,)> {
                    self.seconds_elapsed(::planus::DefaultValue)
                }
            }

            impl<T0> GameInfoBuilder<(T0,)> {
                /// Setter for the [`game_time_remaining` field](GameInfo#structfield.game_time_remaining).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_time_remaining<T1>(self, value: T1) -> GameInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    GameInfoBuilder((v0, value))
                }

                /// Sets the [`game_time_remaining` field](GameInfo#structfield.game_time_remaining) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_time_remaining_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, ::planus::DefaultValue)> {
                    self.game_time_remaining(::planus::DefaultValue)
                }
            }

            impl<T0, T1> GameInfoBuilder<(T0, T1)> {
                /// Setter for the [`is_overtime` field](GameInfo#structfield.is_overtime).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_overtime<T2>(self, value: T2) -> GameInfoBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1) = self.0;
                    GameInfoBuilder((v0, v1, value))
                }

                /// Sets the [`is_overtime` field](GameInfo#structfield.is_overtime) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_overtime_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.is_overtime(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> GameInfoBuilder<(T0, T1, T2)> {
                /// Setter for the [`is_unlimited_time` field](GameInfo#structfield.is_unlimited_time).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_unlimited_time<T3>(self, value: T3) -> GameInfoBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2) = self.0;
                    GameInfoBuilder((v0, v1, v2, value))
                }

                /// Sets the [`is_unlimited_time` field](GameInfo#structfield.is_unlimited_time) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_unlimited_time_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.is_unlimited_time(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> GameInfoBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`game_status` field](GameInfo#structfield.game_status).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_status<T4>(self, value: T4) -> GameInfoBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<self::GameStatus, self::GameStatus>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GameInfoBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`game_status` field](GameInfo#structfield.game_status) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_status_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.game_status(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> GameInfoBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`world_gravity_z` field](GameInfo#structfield.world_gravity_z).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn world_gravity_z<T5>(
                    self,
                    value: T5,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    GameInfoBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`world_gravity_z` field](GameInfo#structfield.world_gravity_z) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn world_gravity_z_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.world_gravity_z(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> GameInfoBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`game_speed` field](GameInfo#structfield.game_speed).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed<T6>(
                    self,
                    value: T6,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    GameInfoBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`game_speed` field](GameInfo#structfield.game_speed) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_speed_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.game_speed(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`frame_num` field](GameInfo#structfield.frame_num).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn frame_num<T7>(
                    self,
                    value: T7,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<u32, u32>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    GameInfoBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`frame_num` field](GameInfo#structfield.frame_num) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn frame_num_as_default(
                    self,
                ) -> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.frame_num(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GameInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<GameInfo>
                where
                    Self: ::planus::WriteAsOffset<GameInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<self::GameStatus, self::GameStatus>,
                    T5: ::planus::WriteAsDefault<f32, f32>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAs<::planus::Offset<GameInfo>>
                for GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<GameInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GameInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<self::GameStatus, self::GameStatus>,
                    T5: ::planus::WriteAsDefault<f32, f32>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOptional<::planus::Offset<GameInfo>>
                for GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<GameInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GameInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<bool, bool>,
                    T3: ::planus::WriteAsDefault<bool, bool>,
                    T4: ::planus::WriteAsDefault<self::GameStatus, self::GameStatus>,
                    T5: ::planus::WriteAsDefault<f32, f32>,
                    T6: ::planus::WriteAsDefault<f32, f32>,
                    T7: ::planus::WriteAsDefault<u32, u32>,
                > ::planus::WriteAsOffset<GameInfo>
                for GameInfoBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GameInfo> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    GameInfo::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [GameInfo].
            #[derive(Copy, Clone)]
            pub struct GameInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GameInfoRef<'a> {
                /// Getter for the [`seconds_elapsed` field](GameInfo#structfield.seconds_elapsed).
                #[inline]
                pub fn seconds_elapsed(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(0, "GameInfo", "seconds_elapsed")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`game_time_remaining` field](GameInfo#structfield.game_time_remaining).
                #[inline]
                pub fn game_time_remaining(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "GameInfo", "game_time_remaining")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`is_overtime` field](GameInfo#structfield.is_overtime).
                #[inline]
                pub fn is_overtime(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(2, "GameInfo", "is_overtime")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`is_unlimited_time` field](GameInfo#structfield.is_unlimited_time).
                #[inline]
                pub fn is_unlimited_time(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(3, "GameInfo", "is_unlimited_time")?
                            .unwrap_or(false),
                    )
                }

                /// Getter for the [`game_status` field](GameInfo#structfield.game_status).
                #[inline]
                pub fn game_status(&self) -> ::planus::Result<self::GameStatus> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(4, "GameInfo", "game_status")?
                            .unwrap_or(self::GameStatus::Inactive),
                    )
                }

                /// Getter for the [`world_gravity_z` field](GameInfo#structfield.world_gravity_z).
                #[inline]
                pub fn world_gravity_z(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "GameInfo", "world_gravity_z")?
                            .unwrap_or(0.0),
                    )
                }

                /// Getter for the [`game_speed` field](GameInfo#structfield.game_speed).
                #[inline]
                pub fn game_speed(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(6, "GameInfo", "game_speed")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`frame_num` field](GameInfo#structfield.frame_num).
                #[inline]
                pub fn frame_num(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(7, "GameInfo", "frame_num")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GameInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GameInfoRef");
                    f.field("seconds_elapsed", &self.seconds_elapsed());
                    f.field("game_time_remaining", &self.game_time_remaining());
                    f.field("is_overtime", &self.is_overtime());
                    f.field("is_unlimited_time", &self.is_unlimited_time());
                    f.field("game_status", &self.game_status());
                    f.field("world_gravity_z", &self.world_gravity_z());
                    f.field("game_speed", &self.game_speed());
                    f.field("frame_num", &self.frame_num());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GameInfoRef<'a>> for GameInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GameInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        seconds_elapsed: ::core::convert::TryInto::try_into(
                            value.seconds_elapsed()?,
                        )?,
                        game_time_remaining: ::core::convert::TryInto::try_into(
                            value.game_time_remaining()?,
                        )?,
                        is_overtime: ::core::convert::TryInto::try_into(value.is_overtime()?)?,
                        is_unlimited_time: ::core::convert::TryInto::try_into(
                            value.is_unlimited_time()?,
                        )?,
                        game_status: ::core::convert::TryInto::try_into(value.game_status()?)?,
                        world_gravity_z: ::core::convert::TryInto::try_into(
                            value.world_gravity_z()?,
                        )?,
                        game_speed: ::core::convert::TryInto::try_into(value.game_speed()?)?,
                        frame_num: ::core::convert::TryInto::try_into(value.frame_num()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GameInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GameInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GameInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GameInfo>> for GameInfo {
                type Value = ::planus::Offset<GameInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GameInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GameInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GameInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `TeamInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `TeamInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:230`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct TeamInfo {
                /// The field `team_index` in the struct `TeamInfo`
                pub team_index: u32,

                ///  number of goals scored.
                pub score: u32,
            }

            impl ::planus::Primitive for TeamInfo {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 8;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<TeamInfo> for TeamInfo {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 4>();
                    self.team_index.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<4, 0>();
                    self.score.write(cur, buffer_position - 4);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<TeamInfo> for TeamInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<TeamInfo> {
                    unsafe {
                        builder.write_with(8, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 8]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<TeamInfo> for TeamInfo {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<TeamInfo> for TeamInfo {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [TeamInfo].
            #[derive(Copy, Clone)]
            pub struct TeamInfoRef<'a>(::planus::ArrayWithStartOffset<'a, 8>);

            impl<'a> TeamInfoRef<'a> {
                /// Getter for the [`team_index` field](TeamInfo#structfield.team_index).
                pub fn team_index(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`score` field](TeamInfo#structfield.score).
                pub fn score(&self) -> u32 {
                    let buffer = self.0.advance_as_array::<4>(4).unwrap();

                    u32::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for TeamInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("TeamInfoRef");
                    f.field("team_index", &self.team_index());
                    f.field("score", &self.score());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 8>> for TeamInfoRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 8>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<TeamInfoRef<'a>> for TeamInfo {
                #[allow(unreachable_code)]
                fn from(value: TeamInfoRef<'a>) -> Self {
                    Self {
                        team_index: value.team_index(),
                        score: value.score(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<TeamInfoRef<'a>> for TeamInfoRef<'b> {
                fn eq(&self, other: &TeamInfoRef<'_>) -> bool {
                    self.team_index() == other.team_index() && self.score() == other.score()
                }
            }

            impl<'a> ::core::cmp::Eq for TeamInfoRef<'a> {}
            impl<'a, 'b> ::core::cmp::PartialOrd<TeamInfoRef<'a>> for TeamInfoRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &TeamInfoRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::option::Option::Some(::core::cmp::Ord::cmp(self, other))
                }
            }

            impl<'a> ::core::cmp::Ord for TeamInfoRef<'a> {
                fn cmp(&self, other: &TeamInfoRef<'_>) -> ::core::cmp::Ordering {
                    self.team_index()
                        .cmp(&other.team_index())
                        .then_with(|| self.score().cmp(&other.score()))
                }
            }

            impl<'a> ::core::hash::Hash for TeamInfoRef<'a> {
                fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
                    self.team_index().hash(state);
                    self.score().hash(state);
                }
            }

            impl<'a> ::planus::TableRead<'a> for TeamInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<8>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for TeamInfoRef<'a> {
                const STRIDE: usize = 8;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<TeamInfo> for TeamInfo {
                const STRIDE: usize = 8;

                type Value = TeamInfo;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[TeamInfo],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 8];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (8 * i) as u32,
                        );
                    }
                }
            }

            /// The table `GamePacket` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `GamePacket` in the file `rlbot/flatbuffers-schema/rlbot.fbs:236`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GamePacket {
                /// The field `players` in the table `GamePacket`
                pub players: ::planus::alloc::vec::Vec<self::PlayerInfo>,
                /// The field `boost_pads` in the table `GamePacket`
                pub boost_pads: ::planus::alloc::vec::Vec<self::BoostPadState>,
                /// The field `balls` in the table `GamePacket`
                pub balls: ::planus::alloc::vec::Vec<self::BallInfo>,
                /// The field `game_info` in the table `GamePacket`
                pub game_info: ::planus::alloc::boxed::Box<self::GameInfo>,
                /// The field `teams` in the table `GamePacket`
                pub teams: ::planus::alloc::vec::Vec<self::TeamInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GamePacket {
                fn default() -> Self {
                    Self {
                        players: ::core::default::Default::default(),
                        boost_pads: ::core::default::Default::default(),
                        balls: ::core::default::Default::default(),
                        game_info: ::core::default::Default::default(),
                        teams: ::core::default::Default::default(),
                    }
                }
            }

            impl GamePacket {
                /// Creates a [GamePacketBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GamePacketBuilder<()> {
                    GamePacketBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_players: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::PlayerInfo>]>,
                    >,
                    field_boost_pads: impl ::planus::WriteAs<::planus::Offset<[self::BoostPadState]>>,
                    field_balls: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::BallInfo>]>,
                    >,
                    field_game_info: impl ::planus::WriteAs<::planus::Offset<self::GameInfo>>,
                    field_teams: impl ::planus::WriteAs<::planus::Offset<[self::TeamInfo]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_players = field_players.prepare(builder);
                    let prepared_boost_pads = field_boost_pads.prepare(builder);
                    let prepared_balls = field_balls.prepare(builder);
                    let prepared_game_info = field_game_info.prepare(builder);
                    let prepared_teams = field_teams.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::PlayerInfo>]>>(0);
                    table_writer.write_entry::<::planus::Offset<[self::BoostPadState]>>(1);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::BallInfo>]>>(2);
                    table_writer.write_entry::<::planus::Offset<self::GameInfo>>(3);
                    table_writer.write_entry::<::planus::Offset<[self::TeamInfo]>>(4);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_players);
                            object_writer.write::<_, _, 4>(&prepared_boost_pads);
                            object_writer.write::<_, _, 4>(&prepared_balls);
                            object_writer.write::<_, _, 4>(&prepared_game_info);
                            object_writer.write::<_, _, 4>(&prepared_teams);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GamePacket>> for GamePacket {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GamePacket> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GamePacket>> for GamePacket {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GamePacket>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GamePacket> for GamePacket {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GamePacket> {
                    GamePacket::create(
                        builder,
                        &self.players,
                        &self.boost_pads,
                        &self.balls,
                        &self.game_info,
                        &self.teams,
                    )
                }
            }

            /// Builder for serializing an instance of the [GamePacket] type.
            ///
            /// Can be created using the [GamePacket::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GamePacketBuilder<State>(State);

            impl GamePacketBuilder<()> {
                /// Setter for the [`players` field](GamePacket#structfield.players).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn players<T0>(self, value: T0) -> GamePacketBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PlayerInfo>]>>,
                {
                    GamePacketBuilder((value,))
                }
            }

            impl<T0> GamePacketBuilder<(T0,)> {
                /// Setter for the [`boost_pads` field](GamePacket#structfield.boost_pads).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_pads<T1>(self, value: T1) -> GamePacketBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[self::BoostPadState]>>,
                {
                    let (v0,) = self.0;
                    GamePacketBuilder((v0, value))
                }
            }

            impl<T0, T1> GamePacketBuilder<(T0, T1)> {
                /// Setter for the [`balls` field](GamePacket#structfield.balls).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn balls<T2>(self, value: T2) -> GamePacketBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BallInfo>]>>,
                {
                    let (v0, v1) = self.0;
                    GamePacketBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> GamePacketBuilder<(T0, T1, T2)> {
                /// Setter for the [`game_info` field](GamePacket#structfield.game_info).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn game_info<T3>(self, value: T3) -> GamePacketBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<::planus::Offset<self::GameInfo>>,
                {
                    let (v0, v1, v2) = self.0;
                    GamePacketBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> GamePacketBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`teams` field](GamePacket#structfield.teams).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn teams<T4>(self, value: T4) -> GamePacketBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<::planus::Offset<[self::TeamInfo]>>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GamePacketBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> GamePacketBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GamePacket].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<GamePacket>
                where
                    Self: ::planus::WriteAsOffset<GamePacket>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PlayerInfo>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[self::BoostPadState]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BallInfo>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::GameInfo>>,
                    T4: ::planus::WriteAs<::planus::Offset<[self::TeamInfo]>>,
                > ::planus::WriteAs<::planus::Offset<GamePacket>>
                for GamePacketBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GamePacket>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GamePacket> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PlayerInfo>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[self::BoostPadState]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BallInfo>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::GameInfo>>,
                    T4: ::planus::WriteAs<::planus::Offset<[self::TeamInfo]>>,
                > ::planus::WriteAsOptional<::planus::Offset<GamePacket>>
                for GamePacketBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GamePacket>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GamePacket>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::PlayerInfo>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[self::BoostPadState]>>,
                    T2: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BallInfo>]>>,
                    T3: ::planus::WriteAs<::planus::Offset<self::GameInfo>>,
                    T4: ::planus::WriteAs<::planus::Offset<[self::TeamInfo]>>,
                > ::planus::WriteAsOffset<GamePacket> for GamePacketBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GamePacket> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    GamePacket::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [GamePacket].
            #[derive(Copy, Clone)]
            pub struct GamePacketRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GamePacketRef<'a> {
                /// Getter for the [`players` field](GamePacket#structfield.players).
                #[inline]
                pub fn players(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::PlayerInfoRef<'a>>>>
                {
                    self.0.access_required(0, "GamePacket", "players")
                }

                /// Getter for the [`boost_pads` field](GamePacket#structfield.boost_pads).
                #[inline]
                pub fn boost_pads(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, self::BoostPadStateRef<'a>>>
                {
                    self.0.access_required(1, "GamePacket", "boost_pads")
                }

                /// Getter for the [`balls` field](GamePacket#structfield.balls).
                #[inline]
                pub fn balls(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::BallInfoRef<'a>>>>
                {
                    self.0.access_required(2, "GamePacket", "balls")
                }

                /// Getter for the [`game_info` field](GamePacket#structfield.game_info).
                #[inline]
                pub fn game_info(&self) -> ::planus::Result<self::GameInfoRef<'a>> {
                    self.0.access_required(3, "GamePacket", "game_info")
                }

                /// Getter for the [`teams` field](GamePacket#structfield.teams).
                #[inline]
                pub fn teams(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, self::TeamInfoRef<'a>>> {
                    self.0.access_required(4, "GamePacket", "teams")
                }
            }

            impl<'a> ::core::fmt::Debug for GamePacketRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GamePacketRef");
                    f.field("players", &self.players());
                    f.field("boost_pads", &self.boost_pads());
                    f.field("balls", &self.balls());
                    f.field("game_info", &self.game_info());
                    f.field("teams", &self.teams());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GamePacketRef<'a>> for GamePacket {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GamePacketRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        players: value.players()?.to_vec_result()?,
                        boost_pads: value.boost_pads()?.to_vec()?,
                        balls: value.balls()?.to_vec_result()?,
                        game_info: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.game_info()?)?,
                        ),
                        teams: value.teams()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GamePacketRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GamePacketRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GamePacketRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GamePacket>> for GamePacket {
                type Value = ::planus::Offset<GamePacket>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GamePacket>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GamePacketRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GamePacketRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `GoalInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `GoalInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:248`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct GoalInfo {
                /// The field `team_num` in the table `GoalInfo`
                pub team_num: i32,
                /// The field `location` in the table `GoalInfo`
                pub location: self::Vector3,
                /// The field `direction` in the table `GoalInfo`
                pub direction: self::Vector3,
                /// The field `width` in the table `GoalInfo`
                pub width: f32,
                /// The field `height` in the table `GoalInfo`
                pub height: f32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for GoalInfo {
                fn default() -> Self {
                    Self {
                        team_num: 0,
                        location: ::core::default::Default::default(),
                        direction: ::core::default::Default::default(),
                        width: 0.0,
                        height: 0.0,
                    }
                }
            }

            impl GoalInfo {
                /// Creates a [GoalInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> GoalInfoBuilder<()> {
                    GoalInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_team_num: impl ::planus::WriteAsDefault<i32, i32>,
                    field_location: impl ::planus::WriteAs<self::Vector3>,
                    field_direction: impl ::planus::WriteAs<self::Vector3>,
                    field_width: impl ::planus::WriteAsDefault<f32, f32>,
                    field_height: impl ::planus::WriteAsDefault<f32, f32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_team_num = field_team_num.prepare(builder, &0);
                    let prepared_location = field_location.prepare(builder);
                    let prepared_direction = field_direction.prepare(builder);
                    let prepared_width = field_width.prepare(builder, &0.0);
                    let prepared_height = field_height.prepare(builder, &0.0);

                    let mut table_writer: ::planus::table_writer::TableWriter<14> =
                        ::core::default::Default::default();
                    if prepared_team_num.is_some() {
                        table_writer.write_entry::<i32>(0);
                    }
                    table_writer.write_entry::<self::Vector3>(1);
                    table_writer.write_entry::<self::Vector3>(2);
                    if prepared_width.is_some() {
                        table_writer.write_entry::<f32>(3);
                    }
                    if prepared_height.is_some() {
                        table_writer.write_entry::<f32>(4);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_team_num) =
                                prepared_team_num
                            {
                                object_writer.write::<_, _, 4>(&prepared_team_num);
                            }
                            object_writer.write::<_, _, 12>(&prepared_location);
                            object_writer.write::<_, _, 12>(&prepared_direction);
                            if let ::core::option::Option::Some(prepared_width) = prepared_width {
                                object_writer.write::<_, _, 4>(&prepared_width);
                            }
                            if let ::core::option::Option::Some(prepared_height) = prepared_height {
                                object_writer.write::<_, _, 4>(&prepared_height);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<GoalInfo>> for GoalInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GoalInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<GoalInfo>> for GoalInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GoalInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<GoalInfo> for GoalInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GoalInfo> {
                    GoalInfo::create(
                        builder,
                        self.team_num,
                        self.location,
                        self.direction,
                        self.width,
                        self.height,
                    )
                }
            }

            /// Builder for serializing an instance of the [GoalInfo] type.
            ///
            /// Can be created using the [GoalInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct GoalInfoBuilder<State>(State);

            impl GoalInfoBuilder<()> {
                /// Setter for the [`team_num` field](GoalInfo#structfield.team_num).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_num<T0>(self, value: T0) -> GoalInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<i32, i32>,
                {
                    GoalInfoBuilder((value,))
                }

                /// Sets the [`team_num` field](GoalInfo#structfield.team_num) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn team_num_as_default(self) -> GoalInfoBuilder<(::planus::DefaultValue,)> {
                    self.team_num(::planus::DefaultValue)
                }
            }

            impl<T0> GoalInfoBuilder<(T0,)> {
                /// Setter for the [`location` field](GoalInfo#structfield.location).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location<T1>(self, value: T1) -> GoalInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0,) = self.0;
                    GoalInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> GoalInfoBuilder<(T0, T1)> {
                /// Setter for the [`direction` field](GoalInfo#structfield.direction).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn direction<T2>(self, value: T2) -> GoalInfoBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0, v1) = self.0;
                    GoalInfoBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> GoalInfoBuilder<(T0, T1, T2)> {
                /// Setter for the [`width` field](GoalInfo#structfield.width).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width<T3>(self, value: T3) -> GoalInfoBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2) = self.0;
                    GoalInfoBuilder((v0, v1, v2, value))
                }

                /// Sets the [`width` field](GoalInfo#structfield.width) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width_as_default(
                    self,
                ) -> GoalInfoBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.width(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> GoalInfoBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`height` field](GoalInfo#structfield.height).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height<T4>(self, value: T4) -> GoalInfoBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    GoalInfoBuilder((v0, v1, v2, v3, value))
                }

                /// Sets the [`height` field](GoalInfo#structfield.height) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height_as_default(
                    self,
                ) -> GoalInfoBuilder<(T0, T1, T2, T3, ::planus::DefaultValue)> {
                    self.height(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4> GoalInfoBuilder<(T0, T1, T2, T3, T4)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [GoalInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<GoalInfo>
                where
                    Self: ::planus::WriteAsOffset<GoalInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<i32, i32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAs<::planus::Offset<GoalInfo>>
                for GoalInfoBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GoalInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GoalInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<i32, i32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOptional<::planus::Offset<GoalInfo>>
                for GoalInfoBuilder<(T0, T1, T2, T3, T4)>
            {
                type Prepared = ::planus::Offset<GoalInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<GoalInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<i32, i32>,
                    T1: ::planus::WriteAs<self::Vector3>,
                    T2: ::planus::WriteAs<self::Vector3>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAsDefault<f32, f32>,
                > ::planus::WriteAsOffset<GoalInfo> for GoalInfoBuilder<(T0, T1, T2, T3, T4)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<GoalInfo> {
                    let (v0, v1, v2, v3, v4) = &self.0;
                    GoalInfo::create(builder, v0, v1, v2, v3, v4)
                }
            }

            /// Reference to a deserialized [GoalInfo].
            #[derive(Copy, Clone)]
            pub struct GoalInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> GoalInfoRef<'a> {
                /// Getter for the [`team_num` field](GoalInfo#structfield.team_num).
                #[inline]
                pub fn team_num(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "GoalInfo", "team_num")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`location` field](GoalInfo#structfield.location).
                #[inline]
                pub fn location(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(1, "GoalInfo", "location")
                }

                /// Getter for the [`direction` field](GoalInfo#structfield.direction).
                #[inline]
                pub fn direction(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(2, "GoalInfo", "direction")
                }

                /// Getter for the [`width` field](GoalInfo#structfield.width).
                #[inline]
                pub fn width(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "GoalInfo", "width")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`height` field](GoalInfo#structfield.height).
                #[inline]
                pub fn height(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(4, "GoalInfo", "height")?.unwrap_or(0.0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for GoalInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("GoalInfoRef");
                    f.field("team_num", &self.team_num());
                    f.field("location", &self.location());
                    f.field("direction", &self.direction());
                    f.field("width", &self.width());
                    f.field("height", &self.height());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<GoalInfoRef<'a>> for GoalInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: GoalInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        team_num: ::core::convert::TryInto::try_into(value.team_num()?)?,
                        location: ::core::convert::Into::into(value.location()?),
                        direction: ::core::convert::Into::into(value.direction()?),
                        width: ::core::convert::TryInto::try_into(value.width()?)?,
                        height: ::core::convert::TryInto::try_into(value.height()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for GoalInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for GoalInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[GoalInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<GoalInfo>> for GoalInfo {
                type Value = ::planus::Offset<GoalInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<GoalInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for GoalInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[GoalInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `BoostPad` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `BoostPad` in the file `rlbot/flatbuffers-schema/rlbot.fbs:256`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BoostPad {
                /// The field `location` in the table `BoostPad`
                pub location: self::Vector3,
                /// The field `is_full_boost` in the table `BoostPad`
                pub is_full_boost: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BoostPad {
                fn default() -> Self {
                    Self {
                        location: ::core::default::Default::default(),
                        is_full_boost: false,
                    }
                }
            }

            impl BoostPad {
                /// Creates a [BoostPadBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BoostPadBuilder<()> {
                    BoostPadBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_location: impl ::planus::WriteAs<self::Vector3>,
                    field_is_full_boost: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_location = field_location.prepare(builder);
                    let prepared_is_full_boost = field_is_full_boost.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<self::Vector3>(0);
                    if prepared_is_full_boost.is_some() {
                        table_writer.write_entry::<bool>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 12>(&prepared_location);
                            if let ::core::option::Option::Some(prepared_is_full_boost) =
                                prepared_is_full_boost
                            {
                                object_writer.write::<_, _, 1>(&prepared_is_full_boost);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BoostPad>> for BoostPad {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoostPad> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BoostPad>> for BoostPad {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BoostPad>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BoostPad> for BoostPad {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoostPad> {
                    BoostPad::create(builder, self.location, self.is_full_boost)
                }
            }

            /// Builder for serializing an instance of the [BoostPad] type.
            ///
            /// Can be created using the [BoostPad::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BoostPadBuilder<State>(State);

            impl BoostPadBuilder<()> {
                /// Setter for the [`location` field](BoostPad#structfield.location).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn location<T0>(self, value: T0) -> BoostPadBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<self::Vector3>,
                {
                    BoostPadBuilder((value,))
                }
            }

            impl<T0> BoostPadBuilder<(T0,)> {
                /// Setter for the [`is_full_boost` field](BoostPad#structfield.is_full_boost).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_full_boost<T1>(self, value: T1) -> BoostPadBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0,) = self.0;
                    BoostPadBuilder((v0, value))
                }

                /// Sets the [`is_full_boost` field](BoostPad#structfield.is_full_boost) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn is_full_boost_as_default(
                    self,
                ) -> BoostPadBuilder<(T0, ::planus::DefaultValue)> {
                    self.is_full_boost(::planus::DefaultValue)
                }
            }

            impl<T0, T1> BoostPadBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BoostPad].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoostPad>
                where
                    Self: ::planus::WriteAsOffset<BoostPad>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<BoostPad>> for BoostPadBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BoostPad>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoostPad> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<BoostPad>>
                for BoostPadBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BoostPad>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BoostPad>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<BoostPad> for BoostPadBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BoostPad> {
                    let (v0, v1) = &self.0;
                    BoostPad::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [BoostPad].
            #[derive(Copy, Clone)]
            pub struct BoostPadRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BoostPadRef<'a> {
                /// Getter for the [`location` field](BoostPad#structfield.location).
                #[inline]
                pub fn location(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(0, "BoostPad", "location")
                }

                /// Getter for the [`is_full_boost` field](BoostPad#structfield.is_full_boost).
                #[inline]
                pub fn is_full_boost(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(1, "BoostPad", "is_full_boost")?
                            .unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for BoostPadRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BoostPadRef");
                    f.field("location", &self.location());
                    f.field("is_full_boost", &self.is_full_boost());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BoostPadRef<'a>> for BoostPad {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BoostPadRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        location: ::core::convert::Into::into(value.location()?),
                        is_full_boost: ::core::convert::TryInto::try_into(value.is_full_boost()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BoostPadRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BoostPadRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BoostPadRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BoostPad>> for BoostPad {
                type Value = ::planus::Offset<BoostPad>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BoostPad>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BoostPadRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BoostPadRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `FieldInfo` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `FieldInfo` in the file `rlbot/flatbuffers-schema/rlbot.fbs:261`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct FieldInfo {
                ///  BoostInfo will be provided in the same order.
                pub boost_pads: ::planus::alloc::vec::Vec<self::BoostPad>,
                /// The field `goals` in the table `FieldInfo`
                pub goals: ::planus::alloc::vec::Vec<self::GoalInfo>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for FieldInfo {
                fn default() -> Self {
                    Self {
                        boost_pads: ::core::default::Default::default(),
                        goals: ::core::default::Default::default(),
                    }
                }
            }

            impl FieldInfo {
                /// Creates a [FieldInfoBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> FieldInfoBuilder<()> {
                    FieldInfoBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_boost_pads: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::BoostPad>]>,
                    >,
                    field_goals: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::GoalInfo>]>,
                    >,
                ) -> ::planus::Offset<Self> {
                    let prepared_boost_pads = field_boost_pads.prepare(builder);
                    let prepared_goals = field_goals.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::BoostPad>]>>(0);
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::GoalInfo>]>>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_boost_pads);
                            object_writer.write::<_, _, 4>(&prepared_goals);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<FieldInfo>> for FieldInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FieldInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<FieldInfo>> for FieldInfo {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FieldInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<FieldInfo> for FieldInfo {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FieldInfo> {
                    FieldInfo::create(builder, &self.boost_pads, &self.goals)
                }
            }

            /// Builder for serializing an instance of the [FieldInfo] type.
            ///
            /// Can be created using the [FieldInfo::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct FieldInfoBuilder<State>(State);

            impl FieldInfoBuilder<()> {
                /// Setter for the [`boost_pads` field](FieldInfo#structfield.boost_pads).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn boost_pads<T0>(self, value: T0) -> FieldInfoBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BoostPad>]>>,
                {
                    FieldInfoBuilder((value,))
                }
            }

            impl<T0> FieldInfoBuilder<(T0,)> {
                /// Setter for the [`goals` field](FieldInfo#structfield.goals).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn goals<T1>(self, value: T1) -> FieldInfoBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::GoalInfo>]>>,
                {
                    let (v0,) = self.0;
                    FieldInfoBuilder((v0, value))
                }
            }

            impl<T0, T1> FieldInfoBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [FieldInfo].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<FieldInfo>
                where
                    Self: ::planus::WriteAsOffset<FieldInfo>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BoostPad>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::GoalInfo>]>>,
                > ::planus::WriteAs<::planus::Offset<FieldInfo>> for FieldInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<FieldInfo>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FieldInfo> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BoostPad>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::GoalInfo>]>>,
                > ::planus::WriteAsOptional<::planus::Offset<FieldInfo>>
                for FieldInfoBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<FieldInfo>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<FieldInfo>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::BoostPad>]>>,
                    T1: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::GoalInfo>]>>,
                > ::planus::WriteAsOffset<FieldInfo> for FieldInfoBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<FieldInfo> {
                    let (v0, v1) = &self.0;
                    FieldInfo::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [FieldInfo].
            #[derive(Copy, Clone)]
            pub struct FieldInfoRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> FieldInfoRef<'a> {
                /// Getter for the [`boost_pads` field](FieldInfo#structfield.boost_pads).
                #[inline]
                pub fn boost_pads(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::BoostPadRef<'a>>>>
                {
                    self.0.access_required(0, "FieldInfo", "boost_pads")
                }

                /// Getter for the [`goals` field](FieldInfo#structfield.goals).
                #[inline]
                pub fn goals(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, ::planus::Result<self::GoalInfoRef<'a>>>>
                {
                    self.0.access_required(1, "FieldInfo", "goals")
                }
            }

            impl<'a> ::core::fmt::Debug for FieldInfoRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("FieldInfoRef");
                    f.field("boost_pads", &self.boost_pads());
                    f.field("goals", &self.goals());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<FieldInfoRef<'a>> for FieldInfo {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: FieldInfoRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        boost_pads: value.boost_pads()?.to_vec_result()?,
                        goals: value.goals()?.to_vec_result()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for FieldInfoRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for FieldInfoRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[FieldInfoRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<FieldInfo>> for FieldInfo {
                type Value = ::planus::Offset<FieldInfo>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<FieldInfo>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for FieldInfoRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[FieldInfoRef]", "read_as_root", 0)
                    })
                }
            }

            /// The struct `PredictionSlice` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `PredictionSlice` in the file `rlbot/flatbuffers-schema/rlbot.fbs:269`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct PredictionSlice {
                ///  The moment in game time that this prediction corresponds to.
                ///  This corresponds to 'secondsElapsed' in the GameInfo table.
                pub game_seconds: f32,

                ///  The predicted location and motion of the object.
                pub physics: self::Physics,
            }

            impl ::planus::Primitive for PredictionSlice {
                const ALIGNMENT: usize = 4;
                const SIZE: usize = 52;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<PredictionSlice> for PredictionSlice {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<4, 48>();
                    self.game_seconds.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<48, 0>();
                    self.physics.write(cur, buffer_position - 4);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<PredictionSlice> for PredictionSlice {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<PredictionSlice> {
                    unsafe {
                        builder.write_with(52, 4, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 52]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<PredictionSlice> for PredictionSlice {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<PredictionSlice> for PredictionSlice {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [PredictionSlice].
            #[derive(Copy, Clone)]
            pub struct PredictionSliceRef<'a>(::planus::ArrayWithStartOffset<'a, 52>);

            impl<'a> PredictionSliceRef<'a> {
                /// Getter for the [`game_seconds` field](PredictionSlice#structfield.game_seconds).
                pub fn game_seconds(&self) -> f32 {
                    let buffer = self.0.advance_as_array::<4>(0).unwrap();

                    f32::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`physics` field](PredictionSlice#structfield.physics).
                pub fn physics(&self) -> self::PhysicsRef<'a> {
                    let buffer = self.0.advance_as_array::<48>(4).unwrap();

                    ::core::convert::From::from(buffer)
                }
            }

            impl<'a> ::core::fmt::Debug for PredictionSliceRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PredictionSliceRef");
                    f.field("game_seconds", &self.game_seconds());
                    f.field("physics", &self.physics());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 52>> for PredictionSliceRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 52>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<PredictionSliceRef<'a>> for PredictionSlice {
                #[allow(unreachable_code)]
                fn from(value: PredictionSliceRef<'a>) -> Self {
                    Self {
                        game_seconds: value.game_seconds(),
                        physics: ::core::convert::From::from(value.physics()),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<PredictionSliceRef<'a>> for PredictionSliceRef<'b> {
                fn eq(&self, other: &PredictionSliceRef<'_>) -> bool {
                    self.game_seconds() == other.game_seconds() && self.physics() == other.physics()
                }
            }

            impl<'a, 'b> ::core::cmp::PartialOrd<PredictionSliceRef<'a>> for PredictionSliceRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &PredictionSliceRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    match self.game_seconds().partial_cmp(&other.game_seconds()) {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => (),
                        o => return o,
                    }

                    self.physics().partial_cmp(&other.physics())
                }
            }

            impl<'a> ::planus::TableRead<'a> for PredictionSliceRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<52>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for PredictionSliceRef<'a> {
                const STRIDE: usize = 52;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<PredictionSlice> for PredictionSlice {
                const STRIDE: usize = 52;

                type Value = PredictionSlice;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[PredictionSlice],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 52];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (52 * i) as u32,
                        );
                    }
                }
            }

            /// The table `BallPrediction` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `BallPrediction` in the file `rlbot/flatbuffers-schema/rlbot.fbs:277`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BallPrediction {
                ///  A list of places the ball will be at specific times in the future.
                ///  It is guaranteed to sorted so that time increases with each slice.
                ///  It is NOT guaranteed to have a consistent amount of time between slices.
                pub slices: ::planus::alloc::vec::Vec<self::PredictionSlice>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BallPrediction {
                fn default() -> Self {
                    Self {
                        slices: ::core::default::Default::default(),
                    }
                }
            }

            impl BallPrediction {
                /// Creates a [BallPredictionBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BallPredictionBuilder<()> {
                    BallPredictionBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_slices: impl ::planus::WriteAs<::planus::Offset<[self::PredictionSlice]>>,
                ) -> ::planus::Offset<Self> {
                    let prepared_slices = field_slices.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[self::PredictionSlice]>>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_slices);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BallPrediction>> for BallPrediction {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BallPrediction> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BallPrediction>> for BallPrediction {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallPrediction>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BallPrediction> for BallPrediction {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BallPrediction> {
                    BallPrediction::create(builder, &self.slices)
                }
            }

            /// Builder for serializing an instance of the [BallPrediction] type.
            ///
            /// Can be created using the [BallPrediction::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BallPredictionBuilder<State>(State);

            impl BallPredictionBuilder<()> {
                /// Setter for the [`slices` field](BallPrediction#structfield.slices).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn slices<T0>(self, value: T0) -> BallPredictionBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[self::PredictionSlice]>>,
                {
                    BallPredictionBuilder((value,))
                }
            }

            impl<T0> BallPredictionBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BallPrediction].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BallPrediction>
                where
                    Self: ::planus::WriteAsOffset<BallPrediction>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::PredictionSlice]>>>
                ::planus::WriteAs<::planus::Offset<BallPrediction>>
                for BallPredictionBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<BallPrediction>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BallPrediction> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::PredictionSlice]>>>
                ::planus::WriteAsOptional<::planus::Offset<BallPrediction>>
                for BallPredictionBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<BallPrediction>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallPrediction>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAs<::planus::Offset<[self::PredictionSlice]>>>
                ::planus::WriteAsOffset<BallPrediction> for BallPredictionBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<BallPrediction> {
                    let (v0,) = &self.0;
                    BallPrediction::create(builder, v0)
                }
            }

            /// Reference to a deserialized [BallPrediction].
            #[derive(Copy, Clone)]
            pub struct BallPredictionRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BallPredictionRef<'a> {
                /// Getter for the [`slices` field](BallPrediction#structfield.slices).
                #[inline]
                pub fn slices(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, self::PredictionSliceRef<'a>>>
                {
                    self.0.access_required(0, "BallPrediction", "slices")
                }
            }

            impl<'a> ::core::fmt::Debug for BallPredictionRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BallPredictionRef");
                    f.field("slices", &self.slices());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BallPredictionRef<'a>> for BallPrediction {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BallPredictionRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        slices: value.slices()?.to_vec()?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BallPredictionRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BallPredictionRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BallPredictionRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BallPrediction>> for BallPrediction {
                type Value = ::planus::Offset<BallPrediction>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BallPrediction>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BallPredictionRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BallPredictionRef]", "read_as_root", 0)
                    })
                }
            }

            /// The enum `TextHAlign` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `TextHAlign` in the file `rlbot/flatbuffers-schema/rendering.fbs:3`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TextHAlign {
                /// The variant `Left` in the enum `TextHAlign`
                Left = 0,

                /// The variant `Center` in the enum `TextHAlign`
                Center = 1,

                /// The variant `Right` in the enum `TextHAlign`
                Right = 2,
            }

            impl TextHAlign {
                /// Array containing all valid variants of TextHAlign
                pub const ENUM_VALUES: [Self; 3] = [Self::Left, Self::Center, Self::Right];
            }

            impl ::core::convert::TryFrom<u8> for TextHAlign {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TextHAlign::Left),
                        1 => ::core::result::Result::Ok(TextHAlign::Center),
                        2 => ::core::result::Result::Ok(TextHAlign::Right),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TextHAlign> for u8 {
                #[inline]
                fn from(value: TextHAlign) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TextHAlign {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TextHAlign> for TextHAlign {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TextHAlign> for TextHAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TextHAlign {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TextHAlign, TextHAlign> for TextHAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TextHAlign,
                ) -> ::core::option::Option<TextHAlign> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TextHAlign> for TextHAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TextHAlign> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TextHAlign {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TextHAlign {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TextHAlign",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TextHAlign> for TextHAlign {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The enum `TextVAlign` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Enum `TextVAlign` in the file `rlbot/flatbuffers-schema/rendering.fbs:9`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                Eq,
                PartialOrd,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            #[repr(u8)]
            pub enum TextVAlign {
                /// The variant `Top` in the enum `TextVAlign`
                Top = 0,

                /// The variant `Center` in the enum `TextVAlign`
                Center = 1,

                /// The variant `Bottom` in the enum `TextVAlign`
                Bottom = 2,
            }

            impl TextVAlign {
                /// Array containing all valid variants of TextVAlign
                pub const ENUM_VALUES: [Self; 3] = [Self::Top, Self::Center, Self::Bottom];
            }

            impl ::core::convert::TryFrom<u8> for TextVAlign {
                type Error = ::planus::errors::UnknownEnumTagKind;
                #[inline]
                fn try_from(
                    value: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTagKind>
                {
                    #[allow(clippy::match_single_binding)]
                    match value {
                        0 => ::core::result::Result::Ok(TextVAlign::Top),
                        1 => ::core::result::Result::Ok(TextVAlign::Center),
                        2 => ::core::result::Result::Ok(TextVAlign::Bottom),

                        _ => ::core::result::Result::Err(::planus::errors::UnknownEnumTagKind {
                            tag: value as i128,
                        }),
                    }
                }
            }

            impl ::core::convert::From<TextVAlign> for u8 {
                #[inline]
                fn from(value: TextVAlign) -> Self {
                    value as u8
                }
            }

            impl ::planus::Primitive for TextVAlign {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 1;
            }

            impl ::planus::WriteAsPrimitive<TextVAlign> for TextVAlign {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    (*self as u8).write(cursor, buffer_position);
                }
            }

            impl ::planus::WriteAs<TextVAlign> for TextVAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> TextVAlign {
                    *self
                }
            }

            impl ::planus::WriteAsDefault<TextVAlign, TextVAlign> for TextVAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                    default: &TextVAlign,
                ) -> ::core::option::Option<TextVAlign> {
                    if self == default {
                        ::core::option::Option::None
                    } else {
                        ::core::option::Option::Some(*self)
                    }
                }
            }

            impl ::planus::WriteAsOptional<TextVAlign> for TextVAlign {
                type Prepared = Self;

                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<TextVAlign> {
                    ::core::option::Option::Some(*self)
                }
            }

            impl<'buf> ::planus::TableRead<'buf> for TextVAlign {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let n: u8 = ::planus::TableRead::from_buffer(buffer, offset)?;
                    ::core::result::Result::Ok(::core::convert::TryInto::try_into(n)?)
                }
            }

            impl<'buf> ::planus::VectorReadInner<'buf> for TextVAlign {
                type Error = ::planus::errors::UnknownEnumTag;
                const STRIDE: usize = 1;
                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'buf>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::UnknownEnumTag>
                {
                    let value = *buffer.buffer.get_unchecked(offset);
                    let value: ::core::result::Result<Self, _> =
                        ::core::convert::TryInto::try_into(value);
                    value.map_err(|error_kind| {
                        error_kind.with_error_location(
                            "TextVAlign",
                            "VectorRead::from_buffer",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<TextVAlign> for TextVAlign {
                const STRIDE: usize = 1;

                type Value = Self;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Self],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 1];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - i as u32,
                        );
                    }
                }
            }

            /// The struct `Color` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Struct `Color` in the file `rlbot/flatbuffers-schema/rendering.fbs:15`
            #[derive(
                Copy,
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                Default,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct Color {
                /// The field `r` in the struct `Color`
                pub r: u8,

                /// The field `g` in the struct `Color`
                pub g: u8,

                /// The field `b` in the struct `Color`
                pub b: u8,

                /// The field `a` in the struct `Color`
                pub a: u8,
            }

            impl ::planus::Primitive for Color {
                const ALIGNMENT: usize = 1;
                const SIZE: usize = 4;
            }

            #[allow(clippy::identity_op)]
            impl ::planus::WriteAsPrimitive<Color> for Color {
                #[inline]
                fn write<const N: usize>(
                    &self,
                    cursor: ::planus::Cursor<'_, N>,
                    buffer_position: u32,
                ) {
                    let (cur, cursor) = cursor.split::<1, 3>();
                    self.r.write(cur, buffer_position - 0);
                    let (cur, cursor) = cursor.split::<1, 2>();
                    self.g.write(cur, buffer_position - 1);
                    let (cur, cursor) = cursor.split::<1, 1>();
                    self.b.write(cur, buffer_position - 2);
                    let (cur, cursor) = cursor.split::<1, 0>();
                    self.a.write(cur, buffer_position - 3);
                    cursor.finish([]);
                }
            }

            impl ::planus::WriteAsOffset<Color> for Color {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Color> {
                    unsafe {
                        builder.write_with(4, 1, |buffer_position, bytes| {
                            let bytes = bytes.as_mut_ptr();

                            ::planus::WriteAsPrimitive::write(
                                self,
                                ::planus::Cursor::new(
                                    &mut *(bytes as *mut [::core::mem::MaybeUninit<u8>; 4]),
                                ),
                                buffer_position,
                            );
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<Color> for Color {
                type Prepared = Self;
                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self {
                    *self
                }
            }

            impl ::planus::WriteAsOptional<Color> for Color {
                type Prepared = Self;
                #[inline]
                fn prepare(
                    &self,
                    _builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<Self> {
                    ::core::option::Option::Some(*self)
                }
            }

            /// Reference to a deserialized [Color].
            #[derive(Copy, Clone)]
            pub struct ColorRef<'a>(::planus::ArrayWithStartOffset<'a, 4>);

            impl<'a> ColorRef<'a> {
                /// Getter for the [`r` field](Color#structfield.r).
                pub fn r(&self) -> u8 {
                    let buffer = self.0.advance_as_array::<1>(0).unwrap();

                    u8::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`g` field](Color#structfield.g).
                pub fn g(&self) -> u8 {
                    let buffer = self.0.advance_as_array::<1>(1).unwrap();

                    u8::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`b` field](Color#structfield.b).
                pub fn b(&self) -> u8 {
                    let buffer = self.0.advance_as_array::<1>(2).unwrap();

                    u8::from_le_bytes(*buffer.as_array())
                }

                /// Getter for the [`a` field](Color#structfield.a).
                pub fn a(&self) -> u8 {
                    let buffer = self.0.advance_as_array::<1>(3).unwrap();

                    u8::from_le_bytes(*buffer.as_array())
                }
            }

            impl<'a> ::core::fmt::Debug for ColorRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("ColorRef");
                    f.field("r", &self.r());
                    f.field("g", &self.g());
                    f.field("b", &self.b());
                    f.field("a", &self.a());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::From<::planus::ArrayWithStartOffset<'a, 4>> for ColorRef<'a> {
                fn from(array: ::planus::ArrayWithStartOffset<'a, 4>) -> Self {
                    Self(array)
                }
            }

            impl<'a> ::core::convert::From<ColorRef<'a>> for Color {
                #[allow(unreachable_code)]
                fn from(value: ColorRef<'a>) -> Self {
                    Self {
                        r: value.r(),
                        g: value.g(),
                        b: value.b(),
                        a: value.a(),
                    }
                }
            }

            impl<'a, 'b> ::core::cmp::PartialEq<ColorRef<'a>> for ColorRef<'b> {
                fn eq(&self, other: &ColorRef<'_>) -> bool {
                    self.r() == other.r()
                        && self.g() == other.g()
                        && self.b() == other.b()
                        && self.a() == other.a()
                }
            }

            impl<'a> ::core::cmp::Eq for ColorRef<'a> {}
            impl<'a, 'b> ::core::cmp::PartialOrd<ColorRef<'a>> for ColorRef<'b> {
                fn partial_cmp(
                    &self,
                    other: &ColorRef<'_>,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::option::Option::Some(::core::cmp::Ord::cmp(self, other))
                }
            }

            impl<'a> ::core::cmp::Ord for ColorRef<'a> {
                fn cmp(&self, other: &ColorRef<'_>) -> ::core::cmp::Ordering {
                    self.r()
                        .cmp(&other.r())
                        .then_with(|| self.g().cmp(&other.g()))
                        .then_with(|| self.b().cmp(&other.b()))
                        .then_with(|| self.a().cmp(&other.a()))
                }
            }

            impl<'a> ::core::hash::Hash for ColorRef<'a> {
                fn hash<H: ::core::hash::Hasher>(&self, state: &mut H) {
                    self.r().hash(state);
                    self.g().hash(state);
                    self.b().hash(state);
                    self.a().hash(state);
                }
            }

            impl<'a> ::planus::TableRead<'a> for ColorRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    let buffer = buffer.advance_as_array::<4>(offset)?;
                    ::core::result::Result::Ok(Self(buffer))
                }
            }

            impl<'a> ::planus::VectorRead<'a> for ColorRef<'a> {
                const STRIDE: usize = 4;

                #[inline]
                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> Self {
                    Self(buffer.unchecked_advance_as_array(offset))
                }
            }

            impl ::planus::VectorWrite<Color> for Color {
                const STRIDE: usize = 4;

                type Value = Color;

                #[inline]
                fn prepare(&self, _builder: &mut ::planus::Builder) -> Self::Value {
                    *self
                }

                #[inline]
                unsafe fn write_values(
                    values: &[Color],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (4 * i) as u32,
                        );
                    }
                }
            }

            /// The table `BallAnchor` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `BallAnchor` in the file `rlbot/flatbuffers-schema/rendering.fbs:22`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct BallAnchor {
                /// The field `index` in the table `BallAnchor`
                pub index: u32,
                /// The field `local` in the table `BallAnchor`
                pub local: self::Vector3,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for BallAnchor {
                fn default() -> Self {
                    Self {
                        index: 0,
                        local: ::core::default::Default::default(),
                    }
                }
            }

            impl BallAnchor {
                /// Creates a [BallAnchorBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> BallAnchorBuilder<()> {
                    BallAnchorBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_local: impl ::planus::WriteAs<self::Vector3>,
                ) -> ::planus::Offset<Self> {
                    let prepared_index = field_index.prepare(builder, &0);
                    let prepared_local = field_local.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<self::Vector3>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_index) = prepared_index {
                                object_writer.write::<_, _, 4>(&prepared_index);
                            }
                            object_writer.write::<_, _, 12>(&prepared_local);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<BallAnchor>> for BallAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<BallAnchor>> for BallAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<BallAnchor> for BallAnchor {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallAnchor> {
                    BallAnchor::create(builder, self.index, self.local)
                }
            }

            /// Builder for serializing an instance of the [BallAnchor] type.
            ///
            /// Can be created using the [BallAnchor::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct BallAnchorBuilder<State>(State);

            impl BallAnchorBuilder<()> {
                /// Setter for the [`index` field](BallAnchor#structfield.index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index<T0>(self, value: T0) -> BallAnchorBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    BallAnchorBuilder((value,))
                }

                /// Sets the [`index` field](BallAnchor#structfield.index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index_as_default(self) -> BallAnchorBuilder<(::planus::DefaultValue,)> {
                    self.index(::planus::DefaultValue)
                }
            }

            impl<T0> BallAnchorBuilder<(T0,)> {
                /// Setter for the [`local` field](BallAnchor#structfield.local).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local<T1>(self, value: T1) -> BallAnchorBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0,) = self.0;
                    BallAnchorBuilder((v0, value))
                }
            }

            impl<T0, T1> BallAnchorBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [BallAnchor].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallAnchor>
                where
                    Self: ::planus::WriteAsOffset<BallAnchor>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAs<::planus::Offset<BallAnchor>> for BallAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BallAnchor>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAsOptional<::planus::Offset<BallAnchor>>
                for BallAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<BallAnchor>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<BallAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAsOffset<BallAnchor> for BallAnchorBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<BallAnchor> {
                    let (v0, v1) = &self.0;
                    BallAnchor::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [BallAnchor].
            #[derive(Copy, Clone)]
            pub struct BallAnchorRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> BallAnchorRef<'a> {
                /// Getter for the [`index` field](BallAnchor#structfield.index).
                #[inline]
                pub fn index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "BallAnchor", "index")?.unwrap_or(0),
                    )
                }

                /// Getter for the [`local` field](BallAnchor#structfield.local).
                #[inline]
                pub fn local(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(1, "BallAnchor", "local")
                }
            }

            impl<'a> ::core::fmt::Debug for BallAnchorRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("BallAnchorRef");
                    f.field("index", &self.index());
                    f.field("local", &self.local());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<BallAnchorRef<'a>> for BallAnchor {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: BallAnchorRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        index: ::core::convert::TryInto::try_into(value.index()?)?,
                        local: ::core::convert::Into::into(value.local()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for BallAnchorRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for BallAnchorRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[BallAnchorRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<BallAnchor>> for BallAnchor {
                type Value = ::planus::Offset<BallAnchor>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<BallAnchor>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for BallAnchorRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[BallAnchorRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `CarAnchor` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `CarAnchor` in the file `rlbot/flatbuffers-schema/rendering.fbs:27`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct CarAnchor {
                /// The field `index` in the table `CarAnchor`
                pub index: u32,
                /// The field `local` in the table `CarAnchor`
                pub local: self::Vector3,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for CarAnchor {
                fn default() -> Self {
                    Self {
                        index: 0,
                        local: ::core::default::Default::default(),
                    }
                }
            }

            impl CarAnchor {
                /// Creates a [CarAnchorBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> CarAnchorBuilder<()> {
                    CarAnchorBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_index: impl ::planus::WriteAsDefault<u32, u32>,
                    field_local: impl ::planus::WriteAs<self::Vector3>,
                ) -> ::planus::Offset<Self> {
                    let prepared_index = field_index.prepare(builder, &0);
                    let prepared_local = field_local.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    if prepared_index.is_some() {
                        table_writer.write_entry::<u32>(0);
                    }
                    table_writer.write_entry::<self::Vector3>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_index) = prepared_index {
                                object_writer.write::<_, _, 4>(&prepared_index);
                            }
                            object_writer.write::<_, _, 12>(&prepared_local);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<CarAnchor>> for CarAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CarAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<CarAnchor>> for CarAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CarAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<CarAnchor> for CarAnchor {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CarAnchor> {
                    CarAnchor::create(builder, self.index, self.local)
                }
            }

            /// Builder for serializing an instance of the [CarAnchor] type.
            ///
            /// Can be created using the [CarAnchor::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct CarAnchorBuilder<State>(State);

            impl CarAnchorBuilder<()> {
                /// Setter for the [`index` field](CarAnchor#structfield.index).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index<T0>(self, value: T0) -> CarAnchorBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<u32, u32>,
                {
                    CarAnchorBuilder((value,))
                }

                /// Sets the [`index` field](CarAnchor#structfield.index) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn index_as_default(self) -> CarAnchorBuilder<(::planus::DefaultValue,)> {
                    self.index(::planus::DefaultValue)
                }
            }

            impl<T0> CarAnchorBuilder<(T0,)> {
                /// Setter for the [`local` field](CarAnchor#structfield.local).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn local<T1>(self, value: T1) -> CarAnchorBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::Vector3>,
                {
                    let (v0,) = self.0;
                    CarAnchorBuilder((v0, value))
                }
            }

            impl<T0, T1> CarAnchorBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [CarAnchor].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<CarAnchor>
                where
                    Self: ::planus::WriteAsOffset<CarAnchor>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAs<::planus::Offset<CarAnchor>> for CarAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CarAnchor>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CarAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAsOptional<::planus::Offset<CarAnchor>>
                for CarAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<CarAnchor>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<CarAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<u32, u32>, T1: ::planus::WriteAs<self::Vector3>>
                ::planus::WriteAsOffset<CarAnchor> for CarAnchorBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<CarAnchor> {
                    let (v0, v1) = &self.0;
                    CarAnchor::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [CarAnchor].
            #[derive(Copy, Clone)]
            pub struct CarAnchorRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> CarAnchorRef<'a> {
                /// Getter for the [`index` field](CarAnchor#structfield.index).
                #[inline]
                pub fn index(&self) -> ::planus::Result<u32> {
                    ::core::result::Result::Ok(self.0.access(0, "CarAnchor", "index")?.unwrap_or(0))
                }

                /// Getter for the [`local` field](CarAnchor#structfield.local).
                #[inline]
                pub fn local(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(1, "CarAnchor", "local")
                }
            }

            impl<'a> ::core::fmt::Debug for CarAnchorRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("CarAnchorRef");
                    f.field("index", &self.index());
                    f.field("local", &self.local());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<CarAnchorRef<'a>> for CarAnchor {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: CarAnchorRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        index: ::core::convert::TryInto::try_into(value.index()?)?,
                        local: ::core::convert::Into::into(value.local()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for CarAnchorRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for CarAnchorRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[CarAnchorRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<CarAnchor>> for CarAnchor {
                type Value = ::planus::Offset<CarAnchor>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<CarAnchor>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for CarAnchorRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[CarAnchorRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `RelativeAnchor` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Union `RelativeAnchor` in the file `rlbot/flatbuffers-schema/rendering.fbs:32`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum RelativeAnchor {
                /// The variant of type `BallAnchor` in the union `RelativeAnchor`
                BallAnchor(::planus::alloc::boxed::Box<self::BallAnchor>),

                /// The variant of type `CarAnchor` in the union `RelativeAnchor`
                CarAnchor(::planus::alloc::boxed::Box<self::CarAnchor>),
            }

            impl RelativeAnchor {
                /// Creates a [RelativeAnchorBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RelativeAnchorBuilder<::planus::Uninitialized> {
                    RelativeAnchorBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_ball_anchor(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::BallAnchor>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_car_anchor(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::CarAnchor>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<RelativeAnchor> for RelativeAnchor {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::BallAnchor(value) => Self::create_ball_anchor(builder, value),
                        Self::CarAnchor(value) => Self::create_car_anchor(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<RelativeAnchor> for RelativeAnchor {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [RelativeAnchor] type.
            ///
            /// Can be created using the [RelativeAnchor::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RelativeAnchorBuilder<T>(T);

            impl RelativeAnchorBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`BallAnchor` variant](RelativeAnchor#variant.BallAnchor).
                #[inline]
                pub fn ball_anchor<T>(
                    self,
                    value: T,
                ) -> RelativeAnchorBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::BallAnchor>,
                {
                    RelativeAnchorBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`CarAnchor` variant](RelativeAnchor#variant.CarAnchor).
                #[inline]
                pub fn car_anchor<T>(
                    self,
                    value: T,
                ) -> RelativeAnchorBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::CarAnchor>,
                {
                    RelativeAnchorBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> RelativeAnchorBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [RelativeAnchor].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RelativeAnchor>
                where
                    Self: ::planus::WriteAsUnion<RelativeAnchor>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<RelativeAnchor>
                for RelativeAnchorBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BallAnchor>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RelativeAnchor> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RelativeAnchor>
                for RelativeAnchorBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::BallAnchor>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RelativeAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RelativeAnchor>
                for RelativeAnchorBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::CarAnchor>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RelativeAnchor> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RelativeAnchor>
                for RelativeAnchorBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::CarAnchor>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RelativeAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [RelativeAnchor].
            #[derive(Copy, Clone, Debug)]
            pub enum RelativeAnchorRef<'a> {
                BallAnchor(self::BallAnchorRef<'a>),
                CarAnchor(self::CarAnchorRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<RelativeAnchorRef<'a>> for RelativeAnchor {
                type Error = ::planus::Error;

                fn try_from(value: RelativeAnchorRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        RelativeAnchorRef::BallAnchor(value) => {
                            Self::BallAnchor(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RelativeAnchorRef::CarAnchor(value) => {
                            Self::CarAnchor(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for RelativeAnchorRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::BallAnchor(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::CarAnchor(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `RenderAnchor` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `RenderAnchor` in the file `rlbot/flatbuffers-schema/rendering.fbs:37`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RenderAnchor {
                /// The field `world` in the table `RenderAnchor`
                pub world: self::Vector3,
                /// The field `relative` in the table `RenderAnchor`
                pub relative: ::core::option::Option<self::RelativeAnchor>,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RenderAnchor {
                fn default() -> Self {
                    Self {
                        world: ::core::default::Default::default(),
                        relative: ::core::default::Default::default(),
                    }
                }
            }

            impl RenderAnchor {
                /// Creates a [RenderAnchorBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RenderAnchorBuilder<()> {
                    RenderAnchorBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_world: impl ::planus::WriteAs<self::Vector3>,
                    field_relative: impl ::planus::WriteAsOptionalUnion<self::RelativeAnchor>,
                ) -> ::planus::Offset<Self> {
                    let prepared_world = field_world.prepare(builder);
                    let prepared_relative = field_relative.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<self::Vector3>(0);
                    if prepared_relative.is_some() {
                        table_writer.write_entry::<::planus::Offset<self::RelativeAnchor>>(2);
                    }
                    if prepared_relative.is_some() {
                        table_writer.write_entry::<u8>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 12>(&prepared_world);
                            if let ::core::option::Option::Some(prepared_relative) =
                                prepared_relative
                            {
                                object_writer.write::<_, _, 4>(&prepared_relative.offset());
                            }
                            if let ::core::option::Option::Some(prepared_relative) =
                                prepared_relative
                            {
                                object_writer.write::<_, _, 1>(&prepared_relative.tag());
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RenderAnchor>> for RenderAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RenderAnchor>> for RenderAnchor {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RenderAnchor> for RenderAnchor {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderAnchor> {
                    RenderAnchor::create(builder, self.world, &self.relative)
                }
            }

            /// Builder for serializing an instance of the [RenderAnchor] type.
            ///
            /// Can be created using the [RenderAnchor::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RenderAnchorBuilder<State>(State);

            impl RenderAnchorBuilder<()> {
                /// Setter for the [`world` field](RenderAnchor#structfield.world).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn world<T0>(self, value: T0) -> RenderAnchorBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<self::Vector3>,
                {
                    RenderAnchorBuilder((value,))
                }
            }

            impl<T0> RenderAnchorBuilder<(T0,)> {
                /// Setter for the [`relative` field](RenderAnchor#structfield.relative).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn relative<T1>(self, value: T1) -> RenderAnchorBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsOptionalUnion<self::RelativeAnchor>,
                {
                    let (v0,) = self.0;
                    RenderAnchorBuilder((v0, value))
                }

                /// Sets the [`relative` field](RenderAnchor#structfield.relative) to null.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn relative_as_null(self) -> RenderAnchorBuilder<(T0, ())> {
                    self.relative(())
                }
            }

            impl<T0, T1> RenderAnchorBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RenderAnchor].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderAnchor>
                where
                    Self: ::planus::WriteAsOffset<RenderAnchor>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsOptionalUnion<self::RelativeAnchor>,
                > ::planus::WriteAs<::planus::Offset<RenderAnchor>>
                for RenderAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RenderAnchor>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderAnchor> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsOptionalUnion<self::RelativeAnchor>,
                > ::planus::WriteAsOptional<::planus::Offset<RenderAnchor>>
                for RenderAnchorBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RenderAnchor>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderAnchor>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<self::Vector3>,
                    T1: ::planus::WriteAsOptionalUnion<self::RelativeAnchor>,
                > ::planus::WriteAsOffset<RenderAnchor> for RenderAnchorBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderAnchor> {
                    let (v0, v1) = &self.0;
                    RenderAnchor::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RenderAnchor].
            #[derive(Copy, Clone)]
            pub struct RenderAnchorRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RenderAnchorRef<'a> {
                /// Getter for the [`world` field](RenderAnchor#structfield.world).
                #[inline]
                pub fn world(&self) -> ::planus::Result<self::Vector3Ref<'a>> {
                    self.0.access_required(0, "RenderAnchor", "world")
                }

                /// Getter for the [`relative` field](RenderAnchor#structfield.relative).
                #[inline]
                pub fn relative(
                    &self,
                ) -> ::planus::Result<::core::option::Option<self::RelativeAnchorRef<'a>>>
                {
                    self.0.access_union(1, "RenderAnchor", "relative")
                }
            }

            impl<'a> ::core::fmt::Debug for RenderAnchorRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RenderAnchorRef");
                    f.field("world", &self.world());
                    if let ::core::option::Option::Some(field_relative) =
                        self.relative().transpose()
                    {
                        f.field("relative", &field_relative);
                    }
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RenderAnchorRef<'a>> for RenderAnchor {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RenderAnchorRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        world: ::core::convert::Into::into(value.world()?),
                        relative: if let ::core::option::Option::Some(relative) =
                            value.relative()?
                        {
                            ::core::option::Option::Some(::core::convert::TryInto::try_into(
                                relative,
                            )?)
                        } else {
                            ::core::option::Option::None
                        },
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RenderAnchorRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RenderAnchorRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RenderAnchorRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RenderAnchor>> for RenderAnchor {
                type Value = ::planus::Offset<RenderAnchor>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RenderAnchor>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RenderAnchorRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RenderAnchorRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Line3D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `Line3D` in the file `rlbot/flatbuffers-schema/rendering.fbs:42`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Line3D {
                /// The field `start` in the table `Line3D`
                pub start: ::planus::alloc::boxed::Box<self::RenderAnchor>,
                /// The field `end` in the table `Line3D`
                pub end: ::planus::alloc::boxed::Box<self::RenderAnchor>,
                /// The field `color` in the table `Line3D`
                pub color: self::Color,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Line3D {
                fn default() -> Self {
                    Self {
                        start: ::core::default::Default::default(),
                        end: ::core::default::Default::default(),
                        color: ::core::default::Default::default(),
                    }
                }
            }

            impl Line3D {
                /// Creates a [Line3DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Line3DBuilder<()> {
                    Line3DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_start: impl ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    field_end: impl ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    field_color: impl ::planus::WriteAs<self::Color>,
                ) -> ::planus::Offset<Self> {
                    let prepared_start = field_start.prepare(builder);
                    let prepared_end = field_end.prepare(builder);
                    let prepared_color = field_color.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<10> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::RenderAnchor>>(0);
                    table_writer.write_entry::<::planus::Offset<self::RenderAnchor>>(1);
                    table_writer.write_entry::<self::Color>(2);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_start);
                            object_writer.write::<_, _, 4>(&prepared_end);
                            object_writer.write::<_, _, 4>(&prepared_color);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Line3D>> for Line3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Line3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Line3D>> for Line3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Line3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Line3D> for Line3D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Line3D> {
                    Line3D::create(builder, &self.start, &self.end, self.color)
                }
            }

            /// Builder for serializing an instance of the [Line3D] type.
            ///
            /// Can be created using the [Line3D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Line3DBuilder<State>(State);

            impl Line3DBuilder<()> {
                /// Setter for the [`start` field](Line3D#structfield.start).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn start<T0>(self, value: T0) -> Line3DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                {
                    Line3DBuilder((value,))
                }
            }

            impl<T0> Line3DBuilder<(T0,)> {
                /// Setter for the [`end` field](Line3D#structfield.end).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn end<T1>(self, value: T1) -> Line3DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                {
                    let (v0,) = self.0;
                    Line3DBuilder((v0, value))
                }
            }

            impl<T0, T1> Line3DBuilder<(T0, T1)> {
                /// Setter for the [`color` field](Line3D#structfield.color).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn color<T2>(self, value: T2) -> Line3DBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1) = self.0;
                    Line3DBuilder((v0, v1, value))
                }
            }

            impl<T0, T1, T2> Line3DBuilder<(T0, T1, T2)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Line3D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Line3D>
                where
                    Self: ::planus::WriteAsOffset<Line3D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAs<::planus::Offset<Line3D>> for Line3DBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Line3D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Line3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOptional<::planus::Offset<Line3D>>
                for Line3DBuilder<(T0, T1, T2)>
            {
                type Prepared = ::planus::Offset<Line3D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Line3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOffset<Line3D> for Line3DBuilder<(T0, T1, T2)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Line3D> {
                    let (v0, v1, v2) = &self.0;
                    Line3D::create(builder, v0, v1, v2)
                }
            }

            /// Reference to a deserialized [Line3D].
            #[derive(Copy, Clone)]
            pub struct Line3DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Line3DRef<'a> {
                /// Getter for the [`start` field](Line3D#structfield.start).
                #[inline]
                pub fn start(&self) -> ::planus::Result<self::RenderAnchorRef<'a>> {
                    self.0.access_required(0, "Line3D", "start")
                }

                /// Getter for the [`end` field](Line3D#structfield.end).
                #[inline]
                pub fn end(&self) -> ::planus::Result<self::RenderAnchorRef<'a>> {
                    self.0.access_required(1, "Line3D", "end")
                }

                /// Getter for the [`color` field](Line3D#structfield.color).
                #[inline]
                pub fn color(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(2, "Line3D", "color")
                }
            }

            impl<'a> ::core::fmt::Debug for Line3DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Line3DRef");
                    f.field("start", &self.start());
                    f.field("end", &self.end());
                    f.field("color", &self.color());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Line3DRef<'a>> for Line3D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Line3DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        start: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.start()?)?,
                        ),
                        end: ::planus::alloc::boxed::Box::new(::core::convert::TryInto::try_into(
                            value.end()?,
                        )?),
                        color: ::core::convert::Into::into(value.color()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Line3DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Line3DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Line3DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Line3D>> for Line3D {
                type Value = ::planus::Offset<Line3D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Line3D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Line3DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Line3DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `PolyLine3D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `PolyLine3D` in the file `rlbot/flatbuffers-schema/rendering.fbs:48`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct PolyLine3D {
                /// The field `points` in the table `PolyLine3D`
                pub points: ::planus::alloc::vec::Vec<self::Vector3>,
                /// The field `color` in the table `PolyLine3D`
                pub color: self::Color,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for PolyLine3D {
                fn default() -> Self {
                    Self {
                        points: ::core::default::Default::default(),
                        color: ::core::default::Default::default(),
                    }
                }
            }

            impl PolyLine3D {
                /// Creates a [PolyLine3DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> PolyLine3DBuilder<()> {
                    PolyLine3DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_points: impl ::planus::WriteAs<::planus::Offset<[self::Vector3]>>,
                    field_color: impl ::planus::WriteAs<self::Color>,
                ) -> ::planus::Offset<Self> {
                    let prepared_points = field_points.prepare(builder);
                    let prepared_color = field_color.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<[self::Vector3]>>(0);
                    table_writer.write_entry::<self::Color>(1);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_points);
                            object_writer.write::<_, _, 4>(&prepared_color);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<PolyLine3D>> for PolyLine3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PolyLine3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<PolyLine3D>> for PolyLine3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PolyLine3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<PolyLine3D> for PolyLine3D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PolyLine3D> {
                    PolyLine3D::create(builder, &self.points, self.color)
                }
            }

            /// Builder for serializing an instance of the [PolyLine3D] type.
            ///
            /// Can be created using the [PolyLine3D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct PolyLine3DBuilder<State>(State);

            impl PolyLine3DBuilder<()> {
                /// Setter for the [`points` field](PolyLine3D#structfield.points).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn points<T0>(self, value: T0) -> PolyLine3DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<[self::Vector3]>>,
                {
                    PolyLine3DBuilder((value,))
                }
            }

            impl<T0> PolyLine3DBuilder<(T0,)> {
                /// Setter for the [`color` field](PolyLine3D#structfield.color).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn color<T1>(self, value: T1) -> PolyLine3DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<self::Color>,
                {
                    let (v0,) = self.0;
                    PolyLine3DBuilder((v0, value))
                }
            }

            impl<T0, T1> PolyLine3DBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [PolyLine3D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<PolyLine3D>
                where
                    Self: ::planus::WriteAsOffset<PolyLine3D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[self::Vector3]>>,
                    T1: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAs<::planus::Offset<PolyLine3D>> for PolyLine3DBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<PolyLine3D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PolyLine3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[self::Vector3]>>,
                    T1: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOptional<::planus::Offset<PolyLine3D>>
                for PolyLine3DBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<PolyLine3D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<PolyLine3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[self::Vector3]>>,
                    T1: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOffset<PolyLine3D> for PolyLine3DBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<PolyLine3D> {
                    let (v0, v1) = &self.0;
                    PolyLine3D::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [PolyLine3D].
            #[derive(Copy, Clone)]
            pub struct PolyLine3DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> PolyLine3DRef<'a> {
                /// Getter for the [`points` field](PolyLine3D#structfield.points).
                #[inline]
                pub fn points(
                    &self,
                ) -> ::planus::Result<::planus::Vector<'a, self::Vector3Ref<'a>>> {
                    self.0.access_required(0, "PolyLine3D", "points")
                }

                /// Getter for the [`color` field](PolyLine3D#structfield.color).
                #[inline]
                pub fn color(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(1, "PolyLine3D", "color")
                }
            }

            impl<'a> ::core::fmt::Debug for PolyLine3DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("PolyLine3DRef");
                    f.field("points", &self.points());
                    f.field("color", &self.color());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<PolyLine3DRef<'a>> for PolyLine3D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: PolyLine3DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        points: value.points()?.to_vec()?,
                        color: ::core::convert::Into::into(value.color()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for PolyLine3DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for PolyLine3DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[PolyLine3DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<PolyLine3D>> for PolyLine3D {
                type Value = ::planus::Offset<PolyLine3D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<PolyLine3D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for PolyLine3DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[PolyLine3DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `String2D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `String2D` in the file `rlbot/flatbuffers-schema/rendering.fbs:53`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct String2D {
                /// The field `text` in the table `String2D`
                pub text: ::planus::alloc::string::String,
                ///  Screen-space coordinates such that x=0 is left edge and x=1 is right edge of window.
                pub x: f32,
                ///  Screen-space coordinates such that y=0 is top edge and y=1 is bottom edge of window.
                pub y: f32,
                /// The field `scale` in the table `String2D`
                pub scale: f32,
                /// The field `foreground` in the table `String2D`
                pub foreground: self::Color,
                /// The field `background` in the table `String2D`
                pub background: self::Color,
                /// The field `h_align` in the table `String2D`
                pub h_align: self::TextHAlign,
                /// The field `v_align` in the table `String2D`
                pub v_align: self::TextVAlign,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for String2D {
                fn default() -> Self {
                    Self {
                        text: ::core::default::Default::default(),
                        x: 0.0,
                        y: 0.0,
                        scale: 0.0,
                        foreground: ::core::default::Default::default(),
                        background: ::core::default::Default::default(),
                        h_align: self::TextHAlign::Left,
                        v_align: self::TextVAlign::Top,
                    }
                }
            }

            impl String2D {
                /// Creates a [String2DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> String2DBuilder<()> {
                    String2DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_text: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_x: impl ::planus::WriteAsDefault<f32, f32>,
                    field_y: impl ::planus::WriteAsDefault<f32, f32>,
                    field_scale: impl ::planus::WriteAsDefault<f32, f32>,
                    field_foreground: impl ::planus::WriteAs<self::Color>,
                    field_background: impl ::planus::WriteAs<self::Color>,
                    field_h_align: impl ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    field_v_align: impl ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                ) -> ::planus::Offset<Self> {
                    let prepared_text = field_text.prepare(builder);
                    let prepared_x = field_x.prepare(builder, &0.0);
                    let prepared_y = field_y.prepare(builder, &0.0);
                    let prepared_scale = field_scale.prepare(builder, &0.0);
                    let prepared_foreground = field_foreground.prepare(builder);
                    let prepared_background = field_background.prepare(builder);
                    let prepared_h_align = field_h_align.prepare(builder, &self::TextHAlign::Left);
                    let prepared_v_align = field_v_align.prepare(builder, &self::TextVAlign::Top);

                    let mut table_writer: ::planus::table_writer::TableWriter<20> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    if prepared_x.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }
                    if prepared_y.is_some() {
                        table_writer.write_entry::<f32>(2);
                    }
                    if prepared_scale.is_some() {
                        table_writer.write_entry::<f32>(3);
                    }
                    table_writer.write_entry::<self::Color>(4);
                    table_writer.write_entry::<self::Color>(5);
                    if prepared_h_align.is_some() {
                        table_writer.write_entry::<self::TextHAlign>(6);
                    }
                    if prepared_v_align.is_some() {
                        table_writer.write_entry::<self::TextVAlign>(7);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_text);
                            if let ::core::option::Option::Some(prepared_x) = prepared_x {
                                object_writer.write::<_, _, 4>(&prepared_x);
                            }
                            if let ::core::option::Option::Some(prepared_y) = prepared_y {
                                object_writer.write::<_, _, 4>(&prepared_y);
                            }
                            if let ::core::option::Option::Some(prepared_scale) = prepared_scale {
                                object_writer.write::<_, _, 4>(&prepared_scale);
                            }
                            object_writer.write::<_, _, 4>(&prepared_foreground);
                            object_writer.write::<_, _, 4>(&prepared_background);
                            if let ::core::option::Option::Some(prepared_h_align) = prepared_h_align
                            {
                                object_writer.write::<_, _, 1>(&prepared_h_align);
                            }
                            if let ::core::option::Option::Some(prepared_v_align) = prepared_v_align
                            {
                                object_writer.write::<_, _, 1>(&prepared_v_align);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String2D>> for String2D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String2D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String2D>> for String2D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String2D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String2D> for String2D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String2D> {
                    String2D::create(
                        builder,
                        &self.text,
                        self.x,
                        self.y,
                        self.scale,
                        self.foreground,
                        self.background,
                        self.h_align,
                        self.v_align,
                    )
                }
            }

            /// Builder for serializing an instance of the [String2D] type.
            ///
            /// Can be created using the [String2D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct String2DBuilder<State>(State);

            impl String2DBuilder<()> {
                /// Setter for the [`text` field](String2D#structfield.text).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn text<T0>(self, value: T0) -> String2DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    String2DBuilder((value,))
                }
            }

            impl<T0> String2DBuilder<(T0,)> {
                /// Setter for the [`x` field](String2D#structfield.x).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x<T1>(self, value: T1) -> String2DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    String2DBuilder((v0, value))
                }

                /// Sets the [`x` field](String2D#structfield.x) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x_as_default(self) -> String2DBuilder<(T0, ::planus::DefaultValue)> {
                    self.x(::planus::DefaultValue)
                }
            }

            impl<T0, T1> String2DBuilder<(T0, T1)> {
                /// Setter for the [`y` field](String2D#structfield.y).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y<T2>(self, value: T2) -> String2DBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1) = self.0;
                    String2DBuilder((v0, v1, value))
                }

                /// Sets the [`y` field](String2D#structfield.y) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y_as_default(self) -> String2DBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.y(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> String2DBuilder<(T0, T1, T2)> {
                /// Setter for the [`scale` field](String2D#structfield.scale).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scale<T3>(self, value: T3) -> String2DBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2) = self.0;
                    String2DBuilder((v0, v1, v2, value))
                }

                /// Sets the [`scale` field](String2D#structfield.scale) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scale_as_default(
                    self,
                ) -> String2DBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.scale(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> String2DBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`foreground` field](String2D#structfield.foreground).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn foreground<T4>(self, value: T4) -> String2DBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    String2DBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> String2DBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`background` field](String2D#structfield.background).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn background<T5>(self, value: T5) -> String2DBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    String2DBuilder((v0, v1, v2, v3, v4, value))
                }
            }

            impl<T0, T1, T2, T3, T4, T5> String2DBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`h_align` field](String2D#structfield.h_align).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn h_align<T6>(self, value: T6) -> String2DBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    String2DBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`h_align` field](String2D#structfield.h_align) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn h_align_as_default(
                    self,
                ) -> String2DBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.h_align(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> String2DBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Setter for the [`v_align` field](String2D#structfield.v_align).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn v_align<T7>(
                    self,
                    value: T7,
                ) -> String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
                where
                    T7: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                {
                    let (v0, v1, v2, v3, v4, v5, v6) = self.0;
                    String2DBuilder((v0, v1, v2, v3, v4, v5, v6, value))
                }

                /// Sets the [`v_align` field](String2D#structfield.v_align) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn v_align_as_default(
                    self,
                ) -> String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, ::planus::DefaultValue)>
                {
                    self.v_align(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6, T7> String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [String2D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<String2D>
                where
                    Self: ::planus::WriteAsOffset<String2D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAs<self::Color>,
                    T6: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T7: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAs<::planus::Offset<String2D>>
                for String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<String2D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String2D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAs<self::Color>,
                    T6: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T7: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAsOptional<::planus::Offset<String2D>>
                for String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                type Prepared = ::planus::Offset<String2D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String2D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAs<self::Color>,
                    T6: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T7: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAsOffset<String2D>
                for String2DBuilder<(T0, T1, T2, T3, T4, T5, T6, T7)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String2D> {
                    let (v0, v1, v2, v3, v4, v5, v6, v7) = &self.0;
                    String2D::create(builder, v0, v1, v2, v3, v4, v5, v6, v7)
                }
            }

            /// Reference to a deserialized [String2D].
            #[derive(Copy, Clone)]
            pub struct String2DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> String2DRef<'a> {
                /// Getter for the [`text` field](String2D#structfield.text).
                #[inline]
                pub fn text(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String2D", "text")
                }

                /// Getter for the [`x` field](String2D#structfield.x).
                #[inline]
                pub fn x(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(1, "String2D", "x")?.unwrap_or(0.0))
                }

                /// Getter for the [`y` field](String2D#structfield.y).
                #[inline]
                pub fn y(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(2, "String2D", "y")?.unwrap_or(0.0))
                }

                /// Getter for the [`scale` field](String2D#structfield.scale).
                #[inline]
                pub fn scale(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(3, "String2D", "scale")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`foreground` field](String2D#structfield.foreground).
                #[inline]
                pub fn foreground(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(4, "String2D", "foreground")
                }

                /// Getter for the [`background` field](String2D#structfield.background).
                #[inline]
                pub fn background(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(5, "String2D", "background")
                }

                /// Getter for the [`h_align` field](String2D#structfield.h_align).
                #[inline]
                pub fn h_align(&self) -> ::planus::Result<self::TextHAlign> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "String2D", "h_align")?
                            .unwrap_or(self::TextHAlign::Left),
                    )
                }

                /// Getter for the [`v_align` field](String2D#structfield.v_align).
                #[inline]
                pub fn v_align(&self) -> ::planus::Result<self::TextVAlign> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(7, "String2D", "v_align")?
                            .unwrap_or(self::TextVAlign::Top),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for String2DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("String2DRef");
                    f.field("text", &self.text());
                    f.field("x", &self.x());
                    f.field("y", &self.y());
                    f.field("scale", &self.scale());
                    f.field("foreground", &self.foreground());
                    f.field("background", &self.background());
                    f.field("h_align", &self.h_align());
                    f.field("v_align", &self.v_align());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<String2DRef<'a>> for String2D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: String2DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        text: ::core::convert::Into::into(value.text()?),
                        x: ::core::convert::TryInto::try_into(value.x()?)?,
                        y: ::core::convert::TryInto::try_into(value.y()?)?,
                        scale: ::core::convert::TryInto::try_into(value.scale()?)?,
                        foreground: ::core::convert::Into::into(value.foreground()?),
                        background: ::core::convert::Into::into(value.background()?),
                        h_align: ::core::convert::TryInto::try_into(value.h_align()?)?,
                        v_align: ::core::convert::TryInto::try_into(value.v_align()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for String2DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for String2DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[String2DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String2D>> for String2D {
                type Value = ::planus::Offset<String2D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String2D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for String2DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[String2DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `String3D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `String3D` in the file `rlbot/flatbuffers-schema/rendering.fbs:66`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct String3D {
                /// The field `text` in the table `String3D`
                pub text: ::planus::alloc::string::String,
                /// The field `anchor` in the table `String3D`
                pub anchor: ::planus::alloc::boxed::Box<self::RenderAnchor>,
                /// The field `scale` in the table `String3D`
                pub scale: f32,
                /// The field `foreground` in the table `String3D`
                pub foreground: self::Color,
                /// The field `background` in the table `String3D`
                pub background: self::Color,
                /// The field `h_align` in the table `String3D`
                pub h_align: self::TextHAlign,
                /// The field `v_align` in the table `String3D`
                pub v_align: self::TextVAlign,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for String3D {
                fn default() -> Self {
                    Self {
                        text: ::core::default::Default::default(),
                        anchor: ::core::default::Default::default(),
                        scale: 0.0,
                        foreground: ::core::default::Default::default(),
                        background: ::core::default::Default::default(),
                        h_align: self::TextHAlign::Left,
                        v_align: self::TextVAlign::Top,
                    }
                }
            }

            impl String3D {
                /// Creates a [String3DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> String3DBuilder<()> {
                    String3DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_text: impl ::planus::WriteAs<::planus::Offset<str>>,
                    field_anchor: impl ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    field_scale: impl ::planus::WriteAsDefault<f32, f32>,
                    field_foreground: impl ::planus::WriteAs<self::Color>,
                    field_background: impl ::planus::WriteAs<self::Color>,
                    field_h_align: impl ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    field_v_align: impl ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                ) -> ::planus::Offset<Self> {
                    let prepared_text = field_text.prepare(builder);
                    let prepared_anchor = field_anchor.prepare(builder);
                    let prepared_scale = field_scale.prepare(builder, &0.0);
                    let prepared_foreground = field_foreground.prepare(builder);
                    let prepared_background = field_background.prepare(builder);
                    let prepared_h_align = field_h_align.prepare(builder, &self::TextHAlign::Left);
                    let prepared_v_align = field_v_align.prepare(builder, &self::TextVAlign::Top);

                    let mut table_writer: ::planus::table_writer::TableWriter<18> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<str>>(0);
                    table_writer.write_entry::<::planus::Offset<self::RenderAnchor>>(1);
                    if prepared_scale.is_some() {
                        table_writer.write_entry::<f32>(2);
                    }
                    table_writer.write_entry::<self::Color>(3);
                    table_writer.write_entry::<self::Color>(4);
                    if prepared_h_align.is_some() {
                        table_writer.write_entry::<self::TextHAlign>(5);
                    }
                    if prepared_v_align.is_some() {
                        table_writer.write_entry::<self::TextVAlign>(6);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_text);
                            object_writer.write::<_, _, 4>(&prepared_anchor);
                            if let ::core::option::Option::Some(prepared_scale) = prepared_scale {
                                object_writer.write::<_, _, 4>(&prepared_scale);
                            }
                            object_writer.write::<_, _, 4>(&prepared_foreground);
                            object_writer.write::<_, _, 4>(&prepared_background);
                            if let ::core::option::Option::Some(prepared_h_align) = prepared_h_align
                            {
                                object_writer.write::<_, _, 1>(&prepared_h_align);
                            }
                            if let ::core::option::Option::Some(prepared_v_align) = prepared_v_align
                            {
                                object_writer.write::<_, _, 1>(&prepared_v_align);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<String3D>> for String3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<String3D>> for String3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<String3D> for String3D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String3D> {
                    String3D::create(
                        builder,
                        &self.text,
                        &self.anchor,
                        self.scale,
                        self.foreground,
                        self.background,
                        self.h_align,
                        self.v_align,
                    )
                }
            }

            /// Builder for serializing an instance of the [String3D] type.
            ///
            /// Can be created using the [String3D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct String3DBuilder<State>(State);

            impl String3DBuilder<()> {
                /// Setter for the [`text` field](String3D#structfield.text).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn text<T0>(self, value: T0) -> String3DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                {
                    String3DBuilder((value,))
                }
            }

            impl<T0> String3DBuilder<(T0,)> {
                /// Setter for the [`anchor` field](String3D#structfield.anchor).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn anchor<T1>(self, value: T1) -> String3DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                {
                    let (v0,) = self.0;
                    String3DBuilder((v0, value))
                }
            }

            impl<T0, T1> String3DBuilder<(T0, T1)> {
                /// Setter for the [`scale` field](String3D#structfield.scale).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scale<T2>(self, value: T2) -> String3DBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1) = self.0;
                    String3DBuilder((v0, v1, value))
                }

                /// Sets the [`scale` field](String3D#structfield.scale) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn scale_as_default(self) -> String3DBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.scale(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> String3DBuilder<(T0, T1, T2)> {
                /// Setter for the [`foreground` field](String3D#structfield.foreground).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn foreground<T3>(self, value: T3) -> String3DBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2) = self.0;
                    String3DBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> String3DBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`background` field](String3D#structfield.background).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn background<T4>(self, value: T4) -> String3DBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    String3DBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> String3DBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`h_align` field](String3D#structfield.h_align).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn h_align<T5>(self, value: T5) -> String3DBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    String3DBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`h_align` field](String3D#structfield.h_align) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn h_align_as_default(
                    self,
                ) -> String3DBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.h_align(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> String3DBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Setter for the [`v_align` field](String3D#structfield.v_align).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn v_align<T6>(self, value: T6) -> String3DBuilder<(T0, T1, T2, T3, T4, T5, T6)>
                where
                    T6: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                {
                    let (v0, v1, v2, v3, v4, v5) = self.0;
                    String3DBuilder((v0, v1, v2, v3, v4, v5, value))
                }

                /// Sets the [`v_align` field](String3D#structfield.v_align) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn v_align_as_default(
                    self,
                ) -> String3DBuilder<(T0, T1, T2, T3, T4, T5, ::planus::DefaultValue)>
                {
                    self.v_align(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5, T6> String3DBuilder<(T0, T1, T2, T3, T4, T5, T6)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [String3D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<String3D>
                where
                    Self: ::planus::WriteAsOffset<String3D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T6: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAs<::planus::Offset<String3D>>
                for String3DBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<String3D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T6: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAsOptional<::planus::Offset<String3D>>
                for String3DBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                type Prepared = ::planus::Offset<String3D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<String3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<str>>,
                    T1: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<self::TextHAlign, self::TextHAlign>,
                    T6: ::planus::WriteAsDefault<self::TextVAlign, self::TextVAlign>,
                > ::planus::WriteAsOffset<String3D>
                for String3DBuilder<(T0, T1, T2, T3, T4, T5, T6)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<String3D> {
                    let (v0, v1, v2, v3, v4, v5, v6) = &self.0;
                    String3D::create(builder, v0, v1, v2, v3, v4, v5, v6)
                }
            }

            /// Reference to a deserialized [String3D].
            #[derive(Copy, Clone)]
            pub struct String3DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> String3DRef<'a> {
                /// Getter for the [`text` field](String3D#structfield.text).
                #[inline]
                pub fn text(&self) -> ::planus::Result<&'a ::core::primitive::str> {
                    self.0.access_required(0, "String3D", "text")
                }

                /// Getter for the [`anchor` field](String3D#structfield.anchor).
                #[inline]
                pub fn anchor(&self) -> ::planus::Result<self::RenderAnchorRef<'a>> {
                    self.0.access_required(1, "String3D", "anchor")
                }

                /// Getter for the [`scale` field](String3D#structfield.scale).
                #[inline]
                pub fn scale(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(
                        self.0.access(2, "String3D", "scale")?.unwrap_or(0.0),
                    )
                }

                /// Getter for the [`foreground` field](String3D#structfield.foreground).
                #[inline]
                pub fn foreground(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(3, "String3D", "foreground")
                }

                /// Getter for the [`background` field](String3D#structfield.background).
                #[inline]
                pub fn background(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(4, "String3D", "background")
                }

                /// Getter for the [`h_align` field](String3D#structfield.h_align).
                #[inline]
                pub fn h_align(&self) -> ::planus::Result<self::TextHAlign> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(5, "String3D", "h_align")?
                            .unwrap_or(self::TextHAlign::Left),
                    )
                }

                /// Getter for the [`v_align` field](String3D#structfield.v_align).
                #[inline]
                pub fn v_align(&self) -> ::planus::Result<self::TextVAlign> {
                    ::core::result::Result::Ok(
                        self.0
                            .access(6, "String3D", "v_align")?
                            .unwrap_or(self::TextVAlign::Top),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for String3DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("String3DRef");
                    f.field("text", &self.text());
                    f.field("anchor", &self.anchor());
                    f.field("scale", &self.scale());
                    f.field("foreground", &self.foreground());
                    f.field("background", &self.background());
                    f.field("h_align", &self.h_align());
                    f.field("v_align", &self.v_align());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<String3DRef<'a>> for String3D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: String3DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        text: ::core::convert::Into::into(value.text()?),
                        anchor: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.anchor()?)?,
                        ),
                        scale: ::core::convert::TryInto::try_into(value.scale()?)?,
                        foreground: ::core::convert::Into::into(value.foreground()?),
                        background: ::core::convert::Into::into(value.background()?),
                        h_align: ::core::convert::TryInto::try_into(value.h_align()?)?,
                        v_align: ::core::convert::TryInto::try_into(value.v_align()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for String3DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for String3DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[String3DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<String3D>> for String3D {
                type Value = ::planus::Offset<String3D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<String3D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for String3DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[String3DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Rect2D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `Rect2D` in the file `rlbot/flatbuffers-schema/rendering.fbs:76`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Rect2D {
                ///  Screen-space coordinates such that x=0 is left edge and x=1 is right edge of window.
                pub x: f32,
                ///  Screen-space coordinates such that y=0 is top edge and y=1 is bottom edge of window.
                pub y: f32,
                ///  Screen-space size such that width=0.1 is 10% of window width.
                pub width: f32,
                ///  Screen-space size such that height=0.1 is 10% of window height.
                pub height: f32,
                /// The field `color` in the table `Rect2D`
                pub color: self::Color,
                /// The field `centered` in the table `Rect2D`
                pub centered: bool,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Rect2D {
                fn default() -> Self {
                    Self {
                        x: 0.0,
                        y: 0.0,
                        width: 0.0,
                        height: 0.0,
                        color: ::core::default::Default::default(),
                        centered: false,
                    }
                }
            }

            impl Rect2D {
                /// Creates a [Rect2DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Rect2DBuilder<()> {
                    Rect2DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_x: impl ::planus::WriteAsDefault<f32, f32>,
                    field_y: impl ::planus::WriteAsDefault<f32, f32>,
                    field_width: impl ::planus::WriteAsDefault<f32, f32>,
                    field_height: impl ::planus::WriteAsDefault<f32, f32>,
                    field_color: impl ::planus::WriteAs<self::Color>,
                    field_centered: impl ::planus::WriteAsDefault<bool, bool>,
                ) -> ::planus::Offset<Self> {
                    let prepared_x = field_x.prepare(builder, &0.0);
                    let prepared_y = field_y.prepare(builder, &0.0);
                    let prepared_width = field_width.prepare(builder, &0.0);
                    let prepared_height = field_height.prepare(builder, &0.0);
                    let prepared_color = field_color.prepare(builder);
                    let prepared_centered = field_centered.prepare(builder, &false);

                    let mut table_writer: ::planus::table_writer::TableWriter<16> =
                        ::core::default::Default::default();
                    if prepared_x.is_some() {
                        table_writer.write_entry::<f32>(0);
                    }
                    if prepared_y.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }
                    if prepared_width.is_some() {
                        table_writer.write_entry::<f32>(2);
                    }
                    if prepared_height.is_some() {
                        table_writer.write_entry::<f32>(3);
                    }
                    table_writer.write_entry::<self::Color>(4);
                    if prepared_centered.is_some() {
                        table_writer.write_entry::<bool>(5);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_x) = prepared_x {
                                object_writer.write::<_, _, 4>(&prepared_x);
                            }
                            if let ::core::option::Option::Some(prepared_y) = prepared_y {
                                object_writer.write::<_, _, 4>(&prepared_y);
                            }
                            if let ::core::option::Option::Some(prepared_width) = prepared_width {
                                object_writer.write::<_, _, 4>(&prepared_width);
                            }
                            if let ::core::option::Option::Some(prepared_height) = prepared_height {
                                object_writer.write::<_, _, 4>(&prepared_height);
                            }
                            object_writer.write::<_, _, 4>(&prepared_color);
                            if let ::core::option::Option::Some(prepared_centered) =
                                prepared_centered
                            {
                                object_writer.write::<_, _, 1>(&prepared_centered);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Rect2D>> for Rect2D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect2D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Rect2D>> for Rect2D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rect2D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Rect2D> for Rect2D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect2D> {
                    Rect2D::create(
                        builder,
                        self.x,
                        self.y,
                        self.width,
                        self.height,
                        self.color,
                        self.centered,
                    )
                }
            }

            /// Builder for serializing an instance of the [Rect2D] type.
            ///
            /// Can be created using the [Rect2D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Rect2DBuilder<State>(State);

            impl Rect2DBuilder<()> {
                /// Setter for the [`x` field](Rect2D#structfield.x).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x<T0>(self, value: T0) -> Rect2DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<f32, f32>,
                {
                    Rect2DBuilder((value,))
                }

                /// Sets the [`x` field](Rect2D#structfield.x) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn x_as_default(self) -> Rect2DBuilder<(::planus::DefaultValue,)> {
                    self.x(::planus::DefaultValue)
                }
            }

            impl<T0> Rect2DBuilder<(T0,)> {
                /// Setter for the [`y` field](Rect2D#structfield.y).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y<T1>(self, value: T1) -> Rect2DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    Rect2DBuilder((v0, value))
                }

                /// Sets the [`y` field](Rect2D#structfield.y) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn y_as_default(self) -> Rect2DBuilder<(T0, ::planus::DefaultValue)> {
                    self.y(::planus::DefaultValue)
                }
            }

            impl<T0, T1> Rect2DBuilder<(T0, T1)> {
                /// Setter for the [`width` field](Rect2D#structfield.width).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width<T2>(self, value: T2) -> Rect2DBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1) = self.0;
                    Rect2DBuilder((v0, v1, value))
                }

                /// Sets the [`width` field](Rect2D#structfield.width) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width_as_default(self) -> Rect2DBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.width(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> Rect2DBuilder<(T0, T1, T2)> {
                /// Setter for the [`height` field](Rect2D#structfield.height).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height<T3>(self, value: T3) -> Rect2DBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1, v2) = self.0;
                    Rect2DBuilder((v0, v1, v2, value))
                }

                /// Sets the [`height` field](Rect2D#structfield.height) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height_as_default(
                    self,
                ) -> Rect2DBuilder<(T0, T1, T2, ::planus::DefaultValue)> {
                    self.height(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3> Rect2DBuilder<(T0, T1, T2, T3)> {
                /// Setter for the [`color` field](Rect2D#structfield.color).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn color<T4>(self, value: T4) -> Rect2DBuilder<(T0, T1, T2, T3, T4)>
                where
                    T4: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2, v3) = self.0;
                    Rect2DBuilder((v0, v1, v2, v3, value))
                }
            }

            impl<T0, T1, T2, T3, T4> Rect2DBuilder<(T0, T1, T2, T3, T4)> {
                /// Setter for the [`centered` field](Rect2D#structfield.centered).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn centered<T5>(self, value: T5) -> Rect2DBuilder<(T0, T1, T2, T3, T4, T5)>
                where
                    T5: ::planus::WriteAsDefault<bool, bool>,
                {
                    let (v0, v1, v2, v3, v4) = self.0;
                    Rect2DBuilder((v0, v1, v2, v3, v4, value))
                }

                /// Sets the [`centered` field](Rect2D#structfield.centered) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn centered_as_default(
                    self,
                ) -> Rect2DBuilder<(T0, T1, T2, T3, T4, ::planus::DefaultValue)> {
                    self.centered(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2, T3, T4, T5> Rect2DBuilder<(T0, T1, T2, T3, T4, T5)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Rect2D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect2D>
                where
                    Self: ::planus::WriteAsOffset<Rect2D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAs<::planus::Offset<Rect2D>>
                for Rect2DBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<Rect2D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect2D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOptional<::planus::Offset<Rect2D>>
                for Rect2DBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                type Prepared = ::planus::Offset<Rect2D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rect2D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAsDefault<f32, f32>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAsDefault<f32, f32>,
                    T4: ::planus::WriteAs<self::Color>,
                    T5: ::planus::WriteAsDefault<bool, bool>,
                > ::planus::WriteAsOffset<Rect2D> for Rect2DBuilder<(T0, T1, T2, T3, T4, T5)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect2D> {
                    let (v0, v1, v2, v3, v4, v5) = &self.0;
                    Rect2D::create(builder, v0, v1, v2, v3, v4, v5)
                }
            }

            /// Reference to a deserialized [Rect2D].
            #[derive(Copy, Clone)]
            pub struct Rect2DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Rect2DRef<'a> {
                /// Getter for the [`x` field](Rect2D#structfield.x).
                #[inline]
                pub fn x(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(0, "Rect2D", "x")?.unwrap_or(0.0))
                }

                /// Getter for the [`y` field](Rect2D#structfield.y).
                #[inline]
                pub fn y(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(1, "Rect2D", "y")?.unwrap_or(0.0))
                }

                /// Getter for the [`width` field](Rect2D#structfield.width).
                #[inline]
                pub fn width(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(2, "Rect2D", "width")?.unwrap_or(0.0))
                }

                /// Getter for the [`height` field](Rect2D#structfield.height).
                #[inline]
                pub fn height(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(3, "Rect2D", "height")?.unwrap_or(0.0))
                }

                /// Getter for the [`color` field](Rect2D#structfield.color).
                #[inline]
                pub fn color(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(4, "Rect2D", "color")
                }

                /// Getter for the [`centered` field](Rect2D#structfield.centered).
                #[inline]
                pub fn centered(&self) -> ::planus::Result<bool> {
                    ::core::result::Result::Ok(
                        self.0.access(5, "Rect2D", "centered")?.unwrap_or(false),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for Rect2DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Rect2DRef");
                    f.field("x", &self.x());
                    f.field("y", &self.y());
                    f.field("width", &self.width());
                    f.field("height", &self.height());
                    f.field("color", &self.color());
                    f.field("centered", &self.centered());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Rect2DRef<'a>> for Rect2D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Rect2DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        x: ::core::convert::TryInto::try_into(value.x()?)?,
                        y: ::core::convert::TryInto::try_into(value.y()?)?,
                        width: ::core::convert::TryInto::try_into(value.width()?)?,
                        height: ::core::convert::TryInto::try_into(value.height()?)?,
                        color: ::core::convert::Into::into(value.color()?),
                        centered: ::core::convert::TryInto::try_into(value.centered()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Rect2DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Rect2DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Rect2DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Rect2D>> for Rect2D {
                type Value = ::planus::Offset<Rect2D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Rect2D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Rect2DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Rect2DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `Rect3D` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `Rect3D` in the file `rlbot/flatbuffers-schema/rendering.fbs:89`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct Rect3D {
                /// The field `anchor` in the table `Rect3D`
                pub anchor: ::planus::alloc::boxed::Box<self::RenderAnchor>,
                ///  Screen-space size such that width=0.1 is 10% of window width.
                pub width: f32,
                ///  Screen-space size such that height=0.1 is 10% of window height.
                pub height: f32,
                /// The field `color` in the table `Rect3D`
                pub color: self::Color,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for Rect3D {
                fn default() -> Self {
                    Self {
                        anchor: ::core::default::Default::default(),
                        width: 0.0,
                        height: 0.0,
                        color: ::core::default::Default::default(),
                    }
                }
            }

            impl Rect3D {
                /// Creates a [Rect3DBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> Rect3DBuilder<()> {
                    Rect3DBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_anchor: impl ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    field_width: impl ::planus::WriteAsDefault<f32, f32>,
                    field_height: impl ::planus::WriteAsDefault<f32, f32>,
                    field_color: impl ::planus::WriteAs<self::Color>,
                ) -> ::planus::Offset<Self> {
                    let prepared_anchor = field_anchor.prepare(builder);
                    let prepared_width = field_width.prepare(builder, &0.0);
                    let prepared_height = field_height.prepare(builder, &0.0);
                    let prepared_color = field_color.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<12> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::RenderAnchor>>(0);
                    if prepared_width.is_some() {
                        table_writer.write_entry::<f32>(1);
                    }
                    if prepared_height.is_some() {
                        table_writer.write_entry::<f32>(2);
                    }
                    table_writer.write_entry::<self::Color>(3);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_anchor);
                            if let ::core::option::Option::Some(prepared_width) = prepared_width {
                                object_writer.write::<_, _, 4>(&prepared_width);
                            }
                            if let ::core::option::Option::Some(prepared_height) = prepared_height {
                                object_writer.write::<_, _, 4>(&prepared_height);
                            }
                            object_writer.write::<_, _, 4>(&prepared_color);
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<Rect3D>> for Rect3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<Rect3D>> for Rect3D {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rect3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<Rect3D> for Rect3D {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect3D> {
                    Rect3D::create(builder, &self.anchor, self.width, self.height, self.color)
                }
            }

            /// Builder for serializing an instance of the [Rect3D] type.
            ///
            /// Can be created using the [Rect3D::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct Rect3DBuilder<State>(State);

            impl Rect3DBuilder<()> {
                /// Setter for the [`anchor` field](Rect3D#structfield.anchor).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn anchor<T0>(self, value: T0) -> Rect3DBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                {
                    Rect3DBuilder((value,))
                }
            }

            impl<T0> Rect3DBuilder<(T0,)> {
                /// Setter for the [`width` field](Rect3D#structfield.width).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width<T1>(self, value: T1) -> Rect3DBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0,) = self.0;
                    Rect3DBuilder((v0, value))
                }

                /// Sets the [`width` field](Rect3D#structfield.width) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn width_as_default(self) -> Rect3DBuilder<(T0, ::planus::DefaultValue)> {
                    self.width(::planus::DefaultValue)
                }
            }

            impl<T0, T1> Rect3DBuilder<(T0, T1)> {
                /// Setter for the [`height` field](Rect3D#structfield.height).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height<T2>(self, value: T2) -> Rect3DBuilder<(T0, T1, T2)>
                where
                    T2: ::planus::WriteAsDefault<f32, f32>,
                {
                    let (v0, v1) = self.0;
                    Rect3DBuilder((v0, v1, value))
                }

                /// Sets the [`height` field](Rect3D#structfield.height) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn height_as_default(self) -> Rect3DBuilder<(T0, T1, ::planus::DefaultValue)> {
                    self.height(::planus::DefaultValue)
                }
            }

            impl<T0, T1, T2> Rect3DBuilder<(T0, T1, T2)> {
                /// Setter for the [`color` field](Rect3D#structfield.color).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn color<T3>(self, value: T3) -> Rect3DBuilder<(T0, T1, T2, T3)>
                where
                    T3: ::planus::WriteAs<self::Color>,
                {
                    let (v0, v1, v2) = self.0;
                    Rect3DBuilder((v0, v1, v2, value))
                }
            }

            impl<T0, T1, T2, T3> Rect3DBuilder<(T0, T1, T2, T3)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [Rect3D].
                #[inline]
                pub fn finish(self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect3D>
                where
                    Self: ::planus::WriteAsOffset<Rect3D>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAs<::planus::Offset<Rect3D>> for Rect3DBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Rect3D>;

                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect3D> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOptional<::planus::Offset<Rect3D>>
                for Rect3DBuilder<(T0, T1, T2, T3)>
            {
                type Prepared = ::planus::Offset<Rect3D>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<Rect3D>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<self::RenderAnchor>>,
                    T1: ::planus::WriteAsDefault<f32, f32>,
                    T2: ::planus::WriteAsDefault<f32, f32>,
                    T3: ::planus::WriteAs<self::Color>,
                > ::planus::WriteAsOffset<Rect3D> for Rect3DBuilder<(T0, T1, T2, T3)>
            {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::Offset<Rect3D> {
                    let (v0, v1, v2, v3) = &self.0;
                    Rect3D::create(builder, v0, v1, v2, v3)
                }
            }

            /// Reference to a deserialized [Rect3D].
            #[derive(Copy, Clone)]
            pub struct Rect3DRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> Rect3DRef<'a> {
                /// Getter for the [`anchor` field](Rect3D#structfield.anchor).
                #[inline]
                pub fn anchor(&self) -> ::planus::Result<self::RenderAnchorRef<'a>> {
                    self.0.access_required(0, "Rect3D", "anchor")
                }

                /// Getter for the [`width` field](Rect3D#structfield.width).
                #[inline]
                pub fn width(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(1, "Rect3D", "width")?.unwrap_or(0.0))
                }

                /// Getter for the [`height` field](Rect3D#structfield.height).
                #[inline]
                pub fn height(&self) -> ::planus::Result<f32> {
                    ::core::result::Result::Ok(self.0.access(2, "Rect3D", "height")?.unwrap_or(0.0))
                }

                /// Getter for the [`color` field](Rect3D#structfield.color).
                #[inline]
                pub fn color(&self) -> ::planus::Result<self::ColorRef<'a>> {
                    self.0.access_required(3, "Rect3D", "color")
                }
            }

            impl<'a> ::core::fmt::Debug for Rect3DRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("Rect3DRef");
                    f.field("anchor", &self.anchor());
                    f.field("width", &self.width());
                    f.field("height", &self.height());
                    f.field("color", &self.color());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<Rect3DRef<'a>> for Rect3D {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: Rect3DRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        anchor: ::planus::alloc::boxed::Box::new(
                            ::core::convert::TryInto::try_into(value.anchor()?)?,
                        ),
                        width: ::core::convert::TryInto::try_into(value.width()?)?,
                        height: ::core::convert::TryInto::try_into(value.height()?)?,
                        color: ::core::convert::Into::into(value.color()?),
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for Rect3DRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for Rect3DRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[Rect3DRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<Rect3D>> for Rect3D {
                type Value = ::planus::Offset<Rect3D>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<Rect3D>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for Rect3DRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[Rect3DRef]", "read_as_root", 0)
                    })
                }
            }

            /// The union `RenderType` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Union `RenderType` in the file `rlbot/flatbuffers-schema/rendering.fbs:98`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub enum RenderType {
                /// The variant of type `Line3D` in the union `RenderType`
                Line3D(::planus::alloc::boxed::Box<self::Line3D>),

                /// The variant of type `PolyLine3D` in the union `RenderType`
                PolyLine3D(::planus::alloc::boxed::Box<self::PolyLine3D>),

                /// The variant of type `String2D` in the union `RenderType`
                String2D(::planus::alloc::boxed::Box<self::String2D>),

                /// The variant of type `String3D` in the union `RenderType`
                String3D(::planus::alloc::boxed::Box<self::String3D>),

                /// The variant of type `Rect2D` in the union `RenderType`
                Rect2D(::planus::alloc::boxed::Box<self::Rect2D>),

                /// The variant of type `Rect3D` in the union `RenderType`
                Rect3D(::planus::alloc::boxed::Box<self::Rect3D>),
            }

            impl RenderType {
                /// Creates a [RenderTypeBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RenderTypeBuilder<::planus::Uninitialized> {
                    RenderTypeBuilder(::planus::Uninitialized)
                }

                #[inline]
                pub fn create_line3_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Line3D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(1, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_poly_line3_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::PolyLine3D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(2, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_string2_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String2D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(3, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_string3_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::String3D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(4, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rect2_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Rect2D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(5, value.prepare(builder).downcast())
                }

                #[inline]
                pub fn create_rect3_d(
                    builder: &mut ::planus::Builder,
                    value: impl ::planus::WriteAsOffset<self::Rect3D>,
                ) -> ::planus::UnionOffset<Self> {
                    ::planus::UnionOffset::new(6, value.prepare(builder).downcast())
                }
            }

            impl ::planus::WriteAsUnion<RenderType> for RenderType {
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> ::planus::UnionOffset<Self> {
                    match self {
                        Self::Line3D(value) => Self::create_line3_d(builder, value),
                        Self::PolyLine3D(value) => Self::create_poly_line3_d(builder, value),
                        Self::String2D(value) => Self::create_string2_d(builder, value),
                        Self::String3D(value) => Self::create_string3_d(builder, value),
                        Self::Rect2D(value) => Self::create_rect2_d(builder, value),
                        Self::Rect3D(value) => Self::create_rect3_d(builder, value),
                    }
                }
            }

            impl ::planus::WriteAsOptionalUnion<RenderType> for RenderType {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<Self>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Builder for serializing an instance of the [RenderType] type.
            ///
            /// Can be created using the [RenderType::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RenderTypeBuilder<T>(T);

            impl RenderTypeBuilder<::planus::Uninitialized> {
                /// Creates an instance of the [`Line3D` variant](RenderType#variant.Line3D).
                #[inline]
                pub fn line3_d<T>(self, value: T) -> RenderTypeBuilder<::planus::Initialized<1, T>>
                where
                    T: ::planus::WriteAsOffset<self::Line3D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`PolyLine3D` variant](RenderType#variant.PolyLine3D).
                #[inline]
                pub fn poly_line3_d<T>(
                    self,
                    value: T,
                ) -> RenderTypeBuilder<::planus::Initialized<2, T>>
                where
                    T: ::planus::WriteAsOffset<self::PolyLine3D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`String2D` variant](RenderType#variant.String2D).
                #[inline]
                pub fn string2_d<T>(
                    self,
                    value: T,
                ) -> RenderTypeBuilder<::planus::Initialized<3, T>>
                where
                    T: ::planus::WriteAsOffset<self::String2D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`String3D` variant](RenderType#variant.String3D).
                #[inline]
                pub fn string3_d<T>(
                    self,
                    value: T,
                ) -> RenderTypeBuilder<::planus::Initialized<4, T>>
                where
                    T: ::planus::WriteAsOffset<self::String3D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Rect2D` variant](RenderType#variant.Rect2D).
                #[inline]
                pub fn rect2_d<T>(self, value: T) -> RenderTypeBuilder<::planus::Initialized<5, T>>
                where
                    T: ::planus::WriteAsOffset<self::Rect2D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }

                /// Creates an instance of the [`Rect3D` variant](RenderType#variant.Rect3D).
                #[inline]
                pub fn rect3_d<T>(self, value: T) -> RenderTypeBuilder<::planus::Initialized<6, T>>
                where
                    T: ::planus::WriteAsOffset<self::Rect3D>,
                {
                    RenderTypeBuilder(::planus::Initialized(value))
                }
            }

            impl<const N: u8, T> RenderTypeBuilder<::planus::Initialized<N, T>> {
                /// Finish writing the builder to get an [UnionOffset](::planus::UnionOffset) to a serialized [RenderType].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType>
                where
                    Self: ::planus::WriteAsUnion<RenderType>,
                {
                    ::planus::WriteAsUnion::prepare(&self, builder)
                }
            }

            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::Line3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(1, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<1, T>>
            where
                T: ::planus::WriteAsOffset<self::Line3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::PolyLine3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(2, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<2, T>>
            where
                T: ::planus::WriteAsOffset<self::PolyLine3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::String2D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(3, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<3, T>>
            where
                T: ::planus::WriteAsOffset<self::String2D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::String3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(4, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<4, T>>
            where
                T: ::planus::WriteAsOffset<self::String3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::Rect2D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(5, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<5, T>>
            where
                T: ::planus::WriteAsOffset<self::Rect2D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }
            impl<T> ::planus::WriteAsUnion<RenderType> for RenderTypeBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::Rect3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::UnionOffset<RenderType> {
                    ::planus::UnionOffset::new(6, (self.0).0.prepare(builder).downcast())
                }
            }

            impl<T> ::planus::WriteAsOptionalUnion<RenderType>
                for RenderTypeBuilder<::planus::Initialized<6, T>>
            where
                T: ::planus::WriteAsOffset<self::Rect3D>,
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::UnionOffset<RenderType>> {
                    ::core::option::Option::Some(::planus::WriteAsUnion::prepare(self, builder))
                }
            }

            /// Reference to a deserialized [RenderType].
            #[derive(Copy, Clone, Debug)]
            pub enum RenderTypeRef<'a> {
                Line3D(self::Line3DRef<'a>),
                PolyLine3D(self::PolyLine3DRef<'a>),
                String2D(self::String2DRef<'a>),
                String3D(self::String3DRef<'a>),
                Rect2D(self::Rect2DRef<'a>),
                Rect3D(self::Rect3DRef<'a>),
            }

            impl<'a> ::core::convert::TryFrom<RenderTypeRef<'a>> for RenderType {
                type Error = ::planus::Error;

                fn try_from(value: RenderTypeRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(match value {
                        RenderTypeRef::Line3D(value) => {
                            Self::Line3D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RenderTypeRef::PolyLine3D(value) => {
                            Self::PolyLine3D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RenderTypeRef::String2D(value) => {
                            Self::String2D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RenderTypeRef::String3D(value) => {
                            Self::String3D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RenderTypeRef::Rect2D(value) => {
                            Self::Rect2D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }

                        RenderTypeRef::Rect3D(value) => {
                            Self::Rect3D(::planus::alloc::boxed::Box::new(
                                ::core::convert::TryFrom::try_from(value)?,
                            ))
                        }
                    })
                }
            }

            impl<'a> ::planus::TableReadUnion<'a> for RenderTypeRef<'a> {
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    field_offset: usize,
                    tag: u8,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    match tag {
                        1 => ::core::result::Result::Ok(Self::Line3D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        2 => ::core::result::Result::Ok(Self::PolyLine3D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        3 => ::core::result::Result::Ok(Self::String2D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        4 => ::core::result::Result::Ok(Self::String3D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        5 => ::core::result::Result::Ok(Self::Rect2D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        6 => ::core::result::Result::Ok(Self::Rect3D(
                            ::planus::TableRead::from_buffer(buffer, field_offset)?,
                        )),
                        _ => ::core::result::Result::Err(
                            ::planus::errors::ErrorKind::UnknownUnionTag { tag },
                        ),
                    }
                }
            }

            /// The table `RenderMessage` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `RenderMessage` in the file `rlbot/flatbuffers-schema/rendering.fbs:107`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RenderMessage {
                /// The field `variety` in the table `RenderMessage`
                pub variety: self::RenderType,
            }

            impl RenderMessage {
                /// Creates a [RenderMessageBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RenderMessageBuilder<()> {
                    RenderMessageBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_variety: impl ::planus::WriteAsUnion<self::RenderType>,
                ) -> ::planus::Offset<Self> {
                    let prepared_variety = field_variety.prepare(builder);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer.write_entry::<::planus::Offset<self::RenderType>>(1);
                    table_writer.write_entry::<u8>(0);

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_variety.offset());
                            object_writer.write::<_, _, 1>(&prepared_variety.tag());
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RenderMessage>> for RenderMessage {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderMessage> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RenderMessage>> for RenderMessage {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderMessage>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RenderMessage> for RenderMessage {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderMessage> {
                    RenderMessage::create(builder, &self.variety)
                }
            }

            /// Builder for serializing an instance of the [RenderMessage] type.
            ///
            /// Can be created using the [RenderMessage::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RenderMessageBuilder<State>(State);

            impl RenderMessageBuilder<()> {
                /// Setter for the [`variety` field](RenderMessage#structfield.variety).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn variety<T0>(self, value: T0) -> RenderMessageBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsUnion<self::RenderType>,
                {
                    RenderMessageBuilder((value,))
                }
            }

            impl<T0> RenderMessageBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RenderMessage].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderMessage>
                where
                    Self: ::planus::WriteAsOffset<RenderMessage>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::RenderType>>
                ::planus::WriteAs<::planus::Offset<RenderMessage>> for RenderMessageBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RenderMessage>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderMessage> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::RenderType>>
                ::planus::WriteAsOptional<::planus::Offset<RenderMessage>>
                for RenderMessageBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RenderMessage>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderMessage>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsUnion<self::RenderType>>
                ::planus::WriteAsOffset<RenderMessage> for RenderMessageBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderMessage> {
                    let (v0,) = &self.0;
                    RenderMessage::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RenderMessage].
            #[derive(Copy, Clone)]
            pub struct RenderMessageRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RenderMessageRef<'a> {
                /// Getter for the [`variety` field](RenderMessage#structfield.variety).
                #[inline]
                pub fn variety(&self) -> ::planus::Result<self::RenderTypeRef<'a>> {
                    self.0.access_union_required(0, "RenderMessage", "variety")
                }
            }

            impl<'a> ::core::fmt::Debug for RenderMessageRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RenderMessageRef");
                    f.field("variety", &self.variety());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RenderMessageRef<'a>> for RenderMessage {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RenderMessageRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        variety: ::core::convert::TryInto::try_into(value.variety()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RenderMessageRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RenderMessageRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RenderMessageRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RenderMessage>> for RenderMessage {
                type Value = ::planus::Offset<RenderMessage>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RenderMessage>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RenderMessageRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RenderMessageRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RenderGroup` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `RenderGroup` in the file `rlbot/flatbuffers-schema/rendering.fbs:111`
            #[derive(
                Clone, Debug, PartialEq, PartialOrd, ::serde::Serialize, ::serde::Deserialize,
            )]
            pub struct RenderGroup {
                /// The field `render_messages` in the table `RenderGroup`
                pub render_messages: ::planus::alloc::vec::Vec<self::RenderMessage>,
                ///  The id of the render group
                pub id: i32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RenderGroup {
                fn default() -> Self {
                    Self {
                        render_messages: ::core::default::Default::default(),
                        id: 0,
                    }
                }
            }

            impl RenderGroup {
                /// Creates a [RenderGroupBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RenderGroupBuilder<()> {
                    RenderGroupBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_render_messages: impl ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RenderMessage>]>,
                    >,
                    field_id: impl ::planus::WriteAsDefault<i32, i32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_render_messages = field_render_messages.prepare(builder);
                    let prepared_id = field_id.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<8> =
                        ::core::default::Default::default();
                    table_writer
                        .write_entry::<::planus::Offset<[::planus::Offset<self::RenderMessage>]>>(
                            0,
                        );
                    if prepared_id.is_some() {
                        table_writer.write_entry::<i32>(1);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            object_writer.write::<_, _, 4>(&prepared_render_messages);
                            if let ::core::option::Option::Some(prepared_id) = prepared_id {
                                object_writer.write::<_, _, 4>(&prepared_id);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RenderGroup>> for RenderGroup {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderGroup> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RenderGroup>> for RenderGroup {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderGroup>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RenderGroup> for RenderGroup {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderGroup> {
                    RenderGroup::create(builder, &self.render_messages, self.id)
                }
            }

            /// Builder for serializing an instance of the [RenderGroup] type.
            ///
            /// Can be created using the [RenderGroup::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RenderGroupBuilder<State>(State);

            impl RenderGroupBuilder<()> {
                /// Setter for the [`render_messages` field](RenderGroup#structfield.render_messages).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn render_messages<T0>(self, value: T0) -> RenderGroupBuilder<(T0,)>
                where
                    T0: ::planus::WriteAs<
                        ::planus::Offset<[::planus::Offset<self::RenderMessage>]>,
                    >,
                {
                    RenderGroupBuilder((value,))
                }
            }

            impl<T0> RenderGroupBuilder<(T0,)> {
                /// Setter for the [`id` field](RenderGroup#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T1>(self, value: T1) -> RenderGroupBuilder<(T0, T1)>
                where
                    T1: ::planus::WriteAsDefault<i32, i32>,
                {
                    let (v0,) = self.0;
                    RenderGroupBuilder((v0, value))
                }

                /// Sets the [`id` field](RenderGroup#structfield.id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id_as_default(self) -> RenderGroupBuilder<(T0, ::planus::DefaultValue)> {
                    self.id(::planus::DefaultValue)
                }
            }

            impl<T0, T1> RenderGroupBuilder<(T0, T1)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RenderGroup].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderGroup>
                where
                    Self: ::planus::WriteAsOffset<RenderGroup>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::RenderMessage>]>>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAs<::planus::Offset<RenderGroup>>
                for RenderGroupBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RenderGroup>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderGroup> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::RenderMessage>]>>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAsOptional<::planus::Offset<RenderGroup>>
                for RenderGroupBuilder<(T0, T1)>
            {
                type Prepared = ::planus::Offset<RenderGroup>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RenderGroup>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<
                    T0: ::planus::WriteAs<::planus::Offset<[::planus::Offset<self::RenderMessage>]>>,
                    T1: ::planus::WriteAsDefault<i32, i32>,
                > ::planus::WriteAsOffset<RenderGroup> for RenderGroupBuilder<(T0, T1)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RenderGroup> {
                    let (v0, v1) = &self.0;
                    RenderGroup::create(builder, v0, v1)
                }
            }

            /// Reference to a deserialized [RenderGroup].
            #[derive(Copy, Clone)]
            pub struct RenderGroupRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RenderGroupRef<'a> {
                /// Getter for the [`render_messages` field](RenderGroup#structfield.render_messages).
                #[inline]
                pub fn render_messages(
                    &self,
                ) -> ::planus::Result<
                    ::planus::Vector<'a, ::planus::Result<self::RenderMessageRef<'a>>>,
                > {
                    self.0.access_required(0, "RenderGroup", "render_messages")
                }

                /// Getter for the [`id` field](RenderGroup#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(self.0.access(1, "RenderGroup", "id")?.unwrap_or(0))
                }
            }

            impl<'a> ::core::fmt::Debug for RenderGroupRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RenderGroupRef");
                    f.field("render_messages", &self.render_messages());
                    f.field("id", &self.id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RenderGroupRef<'a>> for RenderGroup {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RenderGroupRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        render_messages: value.render_messages()?.to_vec_result()?,
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RenderGroupRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RenderGroupRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RenderGroupRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RenderGroup>> for RenderGroup {
                type Value = ::planus::Offset<RenderGroup>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RenderGroup>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RenderGroupRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RenderGroupRef]", "read_as_root", 0)
                    })
                }
            }

            /// The table `RemoveRenderGroup` in the namespace `rlbot.flat`
            ///
            /// Generated from these locations:
            /// * Table `RemoveRenderGroup` in the file `rlbot/flatbuffers-schema/rendering.fbs:119`
            #[derive(
                Clone,
                Debug,
                PartialEq,
                PartialOrd,
                Eq,
                Ord,
                Hash,
                ::serde::Serialize,
                ::serde::Deserialize,
            )]
            pub struct RemoveRenderGroup {
                /// The field `id` in the table `RemoveRenderGroup`
                pub id: i32,
            }

            #[allow(clippy::derivable_impls)]
            impl ::core::default::Default for RemoveRenderGroup {
                fn default() -> Self {
                    Self { id: 0 }
                }
            }

            impl RemoveRenderGroup {
                /// Creates a [RemoveRenderGroupBuilder] for serializing an instance of this table.
                #[inline]
                pub fn builder() -> RemoveRenderGroupBuilder<()> {
                    RemoveRenderGroupBuilder(())
                }

                #[allow(clippy::too_many_arguments)]
                pub fn create(
                    builder: &mut ::planus::Builder,
                    field_id: impl ::planus::WriteAsDefault<i32, i32>,
                ) -> ::planus::Offset<Self> {
                    let prepared_id = field_id.prepare(builder, &0);

                    let mut table_writer: ::planus::table_writer::TableWriter<6> =
                        ::core::default::Default::default();
                    if prepared_id.is_some() {
                        table_writer.write_entry::<i32>(0);
                    }

                    unsafe {
                        table_writer.finish(builder, |object_writer| {
                            if let ::core::option::Option::Some(prepared_id) = prepared_id {
                                object_writer.write::<_, _, 4>(&prepared_id);
                            }
                        });
                    }
                    builder.current_offset()
                }
            }

            impl ::planus::WriteAs<::planus::Offset<RemoveRenderGroup>> for RemoveRenderGroup {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveRenderGroup> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl ::planus::WriteAsOptional<::planus::Offset<RemoveRenderGroup>> for RemoveRenderGroup {
                type Prepared = ::planus::Offset<Self>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RemoveRenderGroup>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl ::planus::WriteAsOffset<RemoveRenderGroup> for RemoveRenderGroup {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveRenderGroup> {
                    RemoveRenderGroup::create(builder, self.id)
                }
            }

            /// Builder for serializing an instance of the [RemoveRenderGroup] type.
            ///
            /// Can be created using the [RemoveRenderGroup::builder] method.
            #[derive(Debug)]
            #[must_use]
            pub struct RemoveRenderGroupBuilder<State>(State);

            impl RemoveRenderGroupBuilder<()> {
                /// Setter for the [`id` field](RemoveRenderGroup#structfield.id).
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id<T0>(self, value: T0) -> RemoveRenderGroupBuilder<(T0,)>
                where
                    T0: ::planus::WriteAsDefault<i32, i32>,
                {
                    RemoveRenderGroupBuilder((value,))
                }

                /// Sets the [`id` field](RemoveRenderGroup#structfield.id) to the default value.
                #[inline]
                #[allow(clippy::type_complexity)]
                pub fn id_as_default(self) -> RemoveRenderGroupBuilder<(::planus::DefaultValue,)> {
                    self.id(::planus::DefaultValue)
                }
            }

            impl<T0> RemoveRenderGroupBuilder<(T0,)> {
                /// Finish writing the builder to get an [Offset](::planus::Offset) to a serialized [RemoveRenderGroup].
                #[inline]
                pub fn finish(
                    self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveRenderGroup>
                where
                    Self: ::planus::WriteAsOffset<RemoveRenderGroup>,
                {
                    ::planus::WriteAsOffset::prepare(&self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>>
                ::planus::WriteAs<::planus::Offset<RemoveRenderGroup>>
                for RemoveRenderGroupBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RemoveRenderGroup>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveRenderGroup> {
                    ::planus::WriteAsOffset::prepare(self, builder)
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>>
                ::planus::WriteAsOptional<::planus::Offset<RemoveRenderGroup>>
                for RemoveRenderGroupBuilder<(T0,)>
            {
                type Prepared = ::planus::Offset<RemoveRenderGroup>;

                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::core::option::Option<::planus::Offset<RemoveRenderGroup>> {
                    ::core::option::Option::Some(::planus::WriteAsOffset::prepare(self, builder))
                }
            }

            impl<T0: ::planus::WriteAsDefault<i32, i32>> ::planus::WriteAsOffset<RemoveRenderGroup>
                for RemoveRenderGroupBuilder<(T0,)>
            {
                #[inline]
                fn prepare(
                    &self,
                    builder: &mut ::planus::Builder,
                ) -> ::planus::Offset<RemoveRenderGroup> {
                    let (v0,) = &self.0;
                    RemoveRenderGroup::create(builder, v0)
                }
            }

            /// Reference to a deserialized [RemoveRenderGroup].
            #[derive(Copy, Clone)]
            pub struct RemoveRenderGroupRef<'a>(::planus::table_reader::Table<'a>);

            impl<'a> RemoveRenderGroupRef<'a> {
                /// Getter for the [`id` field](RemoveRenderGroup#structfield.id).
                #[inline]
                pub fn id(&self) -> ::planus::Result<i32> {
                    ::core::result::Result::Ok(
                        self.0.access(0, "RemoveRenderGroup", "id")?.unwrap_or(0),
                    )
                }
            }

            impl<'a> ::core::fmt::Debug for RemoveRenderGroupRef<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut f = f.debug_struct("RemoveRenderGroupRef");
                    f.field("id", &self.id());
                    f.finish()
                }
            }

            impl<'a> ::core::convert::TryFrom<RemoveRenderGroupRef<'a>> for RemoveRenderGroup {
                type Error = ::planus::Error;

                #[allow(unreachable_code)]
                fn try_from(value: RemoveRenderGroupRef<'a>) -> ::planus::Result<Self> {
                    ::core::result::Result::Ok(Self {
                        id: ::core::convert::TryInto::try_into(value.id()?)?,
                    })
                }
            }

            impl<'a> ::planus::TableRead<'a> for RemoveRenderGroupRef<'a> {
                #[inline]
                fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::core::result::Result<Self, ::planus::errors::ErrorKind> {
                    ::core::result::Result::Ok(Self(::planus::table_reader::Table::from_buffer(
                        buffer, offset,
                    )?))
                }
            }

            impl<'a> ::planus::VectorReadInner<'a> for RemoveRenderGroupRef<'a> {
                type Error = ::planus::Error;
                const STRIDE: usize = 4;

                unsafe fn from_buffer(
                    buffer: ::planus::SliceWithStartOffset<'a>,
                    offset: usize,
                ) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(buffer, offset).map_err(|error_kind| {
                        error_kind.with_error_location(
                            "[RemoveRenderGroupRef]",
                            "get",
                            buffer.offset_from_start,
                        )
                    })
                }
            }

            impl ::planus::VectorWrite<::planus::Offset<RemoveRenderGroup>> for RemoveRenderGroup {
                type Value = ::planus::Offset<RemoveRenderGroup>;
                const STRIDE: usize = 4;
                #[inline]
                fn prepare(&self, builder: &mut ::planus::Builder) -> Self::Value {
                    ::planus::WriteAs::prepare(self, builder)
                }

                #[inline]
                unsafe fn write_values(
                    values: &[::planus::Offset<RemoveRenderGroup>],
                    bytes: *mut ::core::mem::MaybeUninit<u8>,
                    buffer_position: u32,
                ) {
                    let bytes = bytes as *mut [::core::mem::MaybeUninit<u8>; 4];
                    for (i, v) in ::core::iter::Iterator::enumerate(values.iter()) {
                        ::planus::WriteAsPrimitive::write(
                            v,
                            ::planus::Cursor::new(&mut *bytes.add(i)),
                            buffer_position - (Self::STRIDE * i) as u32,
                        );
                    }
                }
            }

            impl<'a> ::planus::ReadAsRoot<'a> for RemoveRenderGroupRef<'a> {
                fn read_as_root(slice: &'a [u8]) -> ::planus::Result<Self> {
                    ::planus::TableRead::from_buffer(
                        ::planus::SliceWithStartOffset {
                            buffer: slice,
                            offset_from_start: 0,
                        },
                        0,
                    )
                    .map_err(|error_kind| {
                        error_kind.with_error_location("[RemoveRenderGroupRef]", "read_as_root", 0)
                    })
                }
            }
        }
    }
}
