// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rlbot {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod flat {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLLISION_SHAPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLLISION_SHAPE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLLISION_SHAPE: [CollisionShape; 4] = [
  CollisionShape::NONE,
  CollisionShape::BoxShape,
  CollisionShape::SphereShape,
  CollisionShape::CylinderShape,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CollisionShape(pub u8);
#[allow(non_upper_case_globals)]
impl CollisionShape {
  pub const NONE: Self = Self(0);
  pub const BoxShape: Self = Self(1);
  pub const SphereShape: Self = Self(2);
  pub const CylinderShape: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::BoxShape,
    Self::SphereShape,
    Self::CylinderShape,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::BoxShape => Some("BoxShape"),
      Self::SphereShape => Some("SphereShape"),
      Self::CylinderShape => Some("CylinderShape"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CollisionShape {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CollisionShape {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for CollisionShape {
    type Output = CollisionShape;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CollisionShape {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CollisionShape {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CollisionShape {}
pub struct CollisionShapeUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TILE_STATE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TILE_STATE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TILE_STATE: [TileState; 4] = [
  TileState::Unknown,
  TileState::Filled,
  TileState::Damaged,
  TileState::Open,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TileState(pub i8);
#[allow(non_upper_case_globals)]
impl TileState {
  pub const Unknown: Self = Self(0);
  /// The default state of the tiles.
  pub const Filled: Self = Self(1);
  /// The state when a tile has been damaged.
  pub const Damaged: Self = Self(2);
  /// The state of a tile when it is open and a goal can be scored.
  pub const Open: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unknown,
    Self::Filled,
    Self::Damaged,
    Self::Open,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unknown => Some("Unknown"),
      Self::Filled => Some("Filled"),
      Self::Damaged => Some("Damaged"),
      Self::Open => Some("Open"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TileState {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TileState {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TileState {
    type Output = TileState;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TileState {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TileState {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TileState {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RENDER_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RENDER_TYPE: i8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RENDER_TYPE: [RenderType; 8] = [
  RenderType::DrawLine2D,
  RenderType::DrawLine3D,
  RenderType::DrawLine2D_3D,
  RenderType::DrawRect2D,
  RenderType::DrawRect3D,
  RenderType::DrawString2D,
  RenderType::DrawString3D,
  RenderType::DrawCenteredRect3D,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RenderType(pub i8);
#[allow(non_upper_case_globals)]
impl RenderType {
  pub const DrawLine2D: Self = Self(1);
  pub const DrawLine3D: Self = Self(2);
  pub const DrawLine2D_3D: Self = Self(3);
  pub const DrawRect2D: Self = Self(4);
  pub const DrawRect3D: Self = Self(5);
  pub const DrawString2D: Self = Self(6);
  pub const DrawString3D: Self = Self(7);
  pub const DrawCenteredRect3D: Self = Self(8);

  pub const ENUM_MIN: i8 = 1;
  pub const ENUM_MAX: i8 = 8;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DrawLine2D,
    Self::DrawLine3D,
    Self::DrawLine2D_3D,
    Self::DrawRect2D,
    Self::DrawRect3D,
    Self::DrawString2D,
    Self::DrawString3D,
    Self::DrawCenteredRect3D,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DrawLine2D => Some("DrawLine2D"),
      Self::DrawLine3D => Some("DrawLine3D"),
      Self::DrawLine2D_3D => Some("DrawLine2D_3D"),
      Self::DrawRect2D => Some("DrawRect2D"),
      Self::DrawRect3D => Some("DrawRect3D"),
      Self::DrawString2D => Some("DrawString2D"),
      Self::DrawString3D => Some("DrawString3D"),
      Self::DrawCenteredRect3D => Some("DrawCenteredRect3D"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RenderType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RenderType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RenderType {
    type Output = RenderType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RenderType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RenderType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RenderType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_QUICK_CHAT_SELECTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_QUICK_CHAT_SELECTION: i8 = 62;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_QUICK_CHAT_SELECTION: [QuickChatSelection; 63] = [
  QuickChatSelection::Information_IGotIt,
  QuickChatSelection::Information_NeedBoost,
  QuickChatSelection::Information_TakeTheShot,
  QuickChatSelection::Information_Defending,
  QuickChatSelection::Information_GoForIt,
  QuickChatSelection::Information_Centering,
  QuickChatSelection::Information_AllYours,
  QuickChatSelection::Information_InPosition,
  QuickChatSelection::Information_Incoming,
  QuickChatSelection::Compliments_NiceShot,
  QuickChatSelection::Compliments_GreatPass,
  QuickChatSelection::Compliments_Thanks,
  QuickChatSelection::Compliments_WhatASave,
  QuickChatSelection::Compliments_NiceOne,
  QuickChatSelection::Compliments_WhatAPlay,
  QuickChatSelection::Compliments_GreatClear,
  QuickChatSelection::Compliments_NiceBlock,
  QuickChatSelection::Reactions_OMG,
  QuickChatSelection::Reactions_Noooo,
  QuickChatSelection::Reactions_Wow,
  QuickChatSelection::Reactions_CloseOne,
  QuickChatSelection::Reactions_NoWay,
  QuickChatSelection::Reactions_HolyCow,
  QuickChatSelection::Reactions_Whew,
  QuickChatSelection::Reactions_Siiiick,
  QuickChatSelection::Reactions_Calculated,
  QuickChatSelection::Reactions_Savage,
  QuickChatSelection::Reactions_Okay,
  QuickChatSelection::Apologies_Cursing,
  QuickChatSelection::Apologies_NoProblem,
  QuickChatSelection::Apologies_Whoops,
  QuickChatSelection::Apologies_Sorry,
  QuickChatSelection::Apologies_MyBad,
  QuickChatSelection::Apologies_Oops,
  QuickChatSelection::Apologies_MyFault,
  QuickChatSelection::PostGame_Gg,
  QuickChatSelection::PostGame_WellPlayed,
  QuickChatSelection::PostGame_ThatWasFun,
  QuickChatSelection::PostGame_Rematch,
  QuickChatSelection::PostGame_OneMoreGame,
  QuickChatSelection::PostGame_WhatAGame,
  QuickChatSelection::PostGame_NiceMoves,
  QuickChatSelection::PostGame_EverybodyDance,
  QuickChatSelection::MaxPysonixQuickChatPresets,
  QuickChatSelection::Custom_Toxic_WasteCPU,
  QuickChatSelection::Custom_Toxic_GitGut,
  QuickChatSelection::Custom_Toxic_DeAlloc,
  QuickChatSelection::Custom_Toxic_404NoSkill,
  QuickChatSelection::Custom_Toxic_CatchVirus,
  QuickChatSelection::Custom_Useful_Passing,
  QuickChatSelection::Custom_Useful_Faking,
  QuickChatSelection::Custom_Useful_Demoing,
  QuickChatSelection::Custom_Useful_Bumping,
  QuickChatSelection::Custom_Compliments_TinyChances,
  QuickChatSelection::Custom_Compliments_SkillLevel,
  QuickChatSelection::Custom_Compliments_proud,
  QuickChatSelection::Custom_Compliments_GC,
  QuickChatSelection::Custom_Compliments_Pro,
  QuickChatSelection::Custom_Excuses_Lag,
  QuickChatSelection::Custom_Excuses_GhostInputs,
  QuickChatSelection::Custom_Excuses_Rigged,
  QuickChatSelection::Custom_Toxic_MafiaPlays,
  QuickChatSelection::Custom_Exclamation_Yeet,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct QuickChatSelection(pub i8);
#[allow(non_upper_case_globals)]
impl QuickChatSelection {
  pub const Information_IGotIt: Self = Self(0);
  pub const Information_NeedBoost: Self = Self(1);
  pub const Information_TakeTheShot: Self = Self(2);
  pub const Information_Defending: Self = Self(3);
  pub const Information_GoForIt: Self = Self(4);
  pub const Information_Centering: Self = Self(5);
  pub const Information_AllYours: Self = Self(6);
  pub const Information_InPosition: Self = Self(7);
  pub const Information_Incoming: Self = Self(8);
  pub const Compliments_NiceShot: Self = Self(9);
  pub const Compliments_GreatPass: Self = Self(10);
  pub const Compliments_Thanks: Self = Self(11);
  pub const Compliments_WhatASave: Self = Self(12);
  pub const Compliments_NiceOne: Self = Self(13);
  pub const Compliments_WhatAPlay: Self = Self(14);
  pub const Compliments_GreatClear: Self = Self(15);
  pub const Compliments_NiceBlock: Self = Self(16);
  pub const Reactions_OMG: Self = Self(17);
  pub const Reactions_Noooo: Self = Self(18);
  pub const Reactions_Wow: Self = Self(19);
  pub const Reactions_CloseOne: Self = Self(20);
  pub const Reactions_NoWay: Self = Self(21);
  pub const Reactions_HolyCow: Self = Self(22);
  pub const Reactions_Whew: Self = Self(23);
  pub const Reactions_Siiiick: Self = Self(24);
  pub const Reactions_Calculated: Self = Self(25);
  pub const Reactions_Savage: Self = Self(26);
  pub const Reactions_Okay: Self = Self(27);
  pub const Apologies_Cursing: Self = Self(28);
  pub const Apologies_NoProblem: Self = Self(29);
  pub const Apologies_Whoops: Self = Self(30);
  pub const Apologies_Sorry: Self = Self(31);
  pub const Apologies_MyBad: Self = Self(32);
  pub const Apologies_Oops: Self = Self(33);
  pub const Apologies_MyFault: Self = Self(34);
  pub const PostGame_Gg: Self = Self(35);
  pub const PostGame_WellPlayed: Self = Self(36);
  pub const PostGame_ThatWasFun: Self = Self(37);
  pub const PostGame_Rematch: Self = Self(38);
  pub const PostGame_OneMoreGame: Self = Self(39);
  pub const PostGame_WhatAGame: Self = Self(40);
  pub const PostGame_NiceMoves: Self = Self(41);
  pub const PostGame_EverybodyDance: Self = Self(42);
  /// Custom text chats made by bot makers
  pub const MaxPysonixQuickChatPresets: Self = Self(43);
  /// Waste of CPU cycles
  pub const Custom_Toxic_WasteCPU: Self = Self(44);
  /// Git gud*
  pub const Custom_Toxic_GitGut: Self = Self(45);
  /// De-Allocate Yourself
  pub const Custom_Toxic_DeAlloc: Self = Self(46);
  /// 404: Your skill not found
  pub const Custom_Toxic_404NoSkill: Self = Self(47);
  /// Get a virus
  pub const Custom_Toxic_CatchVirus: Self = Self(48);
  /// Passing!
  pub const Custom_Useful_Passing: Self = Self(49);
  /// Faking!
  pub const Custom_Useful_Faking: Self = Self(50);
  /// Demoing!
  pub const Custom_Useful_Demoing: Self = Self(51);
  /// BOOPING
  pub const Custom_Useful_Bumping: Self = Self(52);
  /// The chances of that was 47525 to 1*
  pub const Custom_Compliments_TinyChances: Self = Self(53);
  /// Who upped your skill level?
  pub const Custom_Compliments_SkillLevel: Self = Self(54);
  /// Your programmer should be proud
  pub const Custom_Compliments_proud: Self = Self(55);
  /// You're the GC of Bots
  pub const Custom_Compliments_GC: Self = Self(56);
  /// Are you [Insert Pro]Bot? *
  pub const Custom_Compliments_Pro: Self = Self(57);
  /// Lag
  pub const Custom_Excuses_Lag: Self = Self(58);
  /// Ghost inputs
  pub const Custom_Excuses_GhostInputs: Self = Self(59);
  /// RIGGED
  pub const Custom_Excuses_Rigged: Self = Self(60);
  /// Mafia plays!
  pub const Custom_Toxic_MafiaPlays: Self = Self(61);
  /// Yeet!
  pub const Custom_Exclamation_Yeet: Self = Self(62);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 62;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Information_IGotIt,
    Self::Information_NeedBoost,
    Self::Information_TakeTheShot,
    Self::Information_Defending,
    Self::Information_GoForIt,
    Self::Information_Centering,
    Self::Information_AllYours,
    Self::Information_InPosition,
    Self::Information_Incoming,
    Self::Compliments_NiceShot,
    Self::Compliments_GreatPass,
    Self::Compliments_Thanks,
    Self::Compliments_WhatASave,
    Self::Compliments_NiceOne,
    Self::Compliments_WhatAPlay,
    Self::Compliments_GreatClear,
    Self::Compliments_NiceBlock,
    Self::Reactions_OMG,
    Self::Reactions_Noooo,
    Self::Reactions_Wow,
    Self::Reactions_CloseOne,
    Self::Reactions_NoWay,
    Self::Reactions_HolyCow,
    Self::Reactions_Whew,
    Self::Reactions_Siiiick,
    Self::Reactions_Calculated,
    Self::Reactions_Savage,
    Self::Reactions_Okay,
    Self::Apologies_Cursing,
    Self::Apologies_NoProblem,
    Self::Apologies_Whoops,
    Self::Apologies_Sorry,
    Self::Apologies_MyBad,
    Self::Apologies_Oops,
    Self::Apologies_MyFault,
    Self::PostGame_Gg,
    Self::PostGame_WellPlayed,
    Self::PostGame_ThatWasFun,
    Self::PostGame_Rematch,
    Self::PostGame_OneMoreGame,
    Self::PostGame_WhatAGame,
    Self::PostGame_NiceMoves,
    Self::PostGame_EverybodyDance,
    Self::MaxPysonixQuickChatPresets,
    Self::Custom_Toxic_WasteCPU,
    Self::Custom_Toxic_GitGut,
    Self::Custom_Toxic_DeAlloc,
    Self::Custom_Toxic_404NoSkill,
    Self::Custom_Toxic_CatchVirus,
    Self::Custom_Useful_Passing,
    Self::Custom_Useful_Faking,
    Self::Custom_Useful_Demoing,
    Self::Custom_Useful_Bumping,
    Self::Custom_Compliments_TinyChances,
    Self::Custom_Compliments_SkillLevel,
    Self::Custom_Compliments_proud,
    Self::Custom_Compliments_GC,
    Self::Custom_Compliments_Pro,
    Self::Custom_Excuses_Lag,
    Self::Custom_Excuses_GhostInputs,
    Self::Custom_Excuses_Rigged,
    Self::Custom_Toxic_MafiaPlays,
    Self::Custom_Exclamation_Yeet,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Information_IGotIt => Some("Information_IGotIt"),
      Self::Information_NeedBoost => Some("Information_NeedBoost"),
      Self::Information_TakeTheShot => Some("Information_TakeTheShot"),
      Self::Information_Defending => Some("Information_Defending"),
      Self::Information_GoForIt => Some("Information_GoForIt"),
      Self::Information_Centering => Some("Information_Centering"),
      Self::Information_AllYours => Some("Information_AllYours"),
      Self::Information_InPosition => Some("Information_InPosition"),
      Self::Information_Incoming => Some("Information_Incoming"),
      Self::Compliments_NiceShot => Some("Compliments_NiceShot"),
      Self::Compliments_GreatPass => Some("Compliments_GreatPass"),
      Self::Compliments_Thanks => Some("Compliments_Thanks"),
      Self::Compliments_WhatASave => Some("Compliments_WhatASave"),
      Self::Compliments_NiceOne => Some("Compliments_NiceOne"),
      Self::Compliments_WhatAPlay => Some("Compliments_WhatAPlay"),
      Self::Compliments_GreatClear => Some("Compliments_GreatClear"),
      Self::Compliments_NiceBlock => Some("Compliments_NiceBlock"),
      Self::Reactions_OMG => Some("Reactions_OMG"),
      Self::Reactions_Noooo => Some("Reactions_Noooo"),
      Self::Reactions_Wow => Some("Reactions_Wow"),
      Self::Reactions_CloseOne => Some("Reactions_CloseOne"),
      Self::Reactions_NoWay => Some("Reactions_NoWay"),
      Self::Reactions_HolyCow => Some("Reactions_HolyCow"),
      Self::Reactions_Whew => Some("Reactions_Whew"),
      Self::Reactions_Siiiick => Some("Reactions_Siiiick"),
      Self::Reactions_Calculated => Some("Reactions_Calculated"),
      Self::Reactions_Savage => Some("Reactions_Savage"),
      Self::Reactions_Okay => Some("Reactions_Okay"),
      Self::Apologies_Cursing => Some("Apologies_Cursing"),
      Self::Apologies_NoProblem => Some("Apologies_NoProblem"),
      Self::Apologies_Whoops => Some("Apologies_Whoops"),
      Self::Apologies_Sorry => Some("Apologies_Sorry"),
      Self::Apologies_MyBad => Some("Apologies_MyBad"),
      Self::Apologies_Oops => Some("Apologies_Oops"),
      Self::Apologies_MyFault => Some("Apologies_MyFault"),
      Self::PostGame_Gg => Some("PostGame_Gg"),
      Self::PostGame_WellPlayed => Some("PostGame_WellPlayed"),
      Self::PostGame_ThatWasFun => Some("PostGame_ThatWasFun"),
      Self::PostGame_Rematch => Some("PostGame_Rematch"),
      Self::PostGame_OneMoreGame => Some("PostGame_OneMoreGame"),
      Self::PostGame_WhatAGame => Some("PostGame_WhatAGame"),
      Self::PostGame_NiceMoves => Some("PostGame_NiceMoves"),
      Self::PostGame_EverybodyDance => Some("PostGame_EverybodyDance"),
      Self::MaxPysonixQuickChatPresets => Some("MaxPysonixQuickChatPresets"),
      Self::Custom_Toxic_WasteCPU => Some("Custom_Toxic_WasteCPU"),
      Self::Custom_Toxic_GitGut => Some("Custom_Toxic_GitGut"),
      Self::Custom_Toxic_DeAlloc => Some("Custom_Toxic_DeAlloc"),
      Self::Custom_Toxic_404NoSkill => Some("Custom_Toxic_404NoSkill"),
      Self::Custom_Toxic_CatchVirus => Some("Custom_Toxic_CatchVirus"),
      Self::Custom_Useful_Passing => Some("Custom_Useful_Passing"),
      Self::Custom_Useful_Faking => Some("Custom_Useful_Faking"),
      Self::Custom_Useful_Demoing => Some("Custom_Useful_Demoing"),
      Self::Custom_Useful_Bumping => Some("Custom_Useful_Bumping"),
      Self::Custom_Compliments_TinyChances => Some("Custom_Compliments_TinyChances"),
      Self::Custom_Compliments_SkillLevel => Some("Custom_Compliments_SkillLevel"),
      Self::Custom_Compliments_proud => Some("Custom_Compliments_proud"),
      Self::Custom_Compliments_GC => Some("Custom_Compliments_GC"),
      Self::Custom_Compliments_Pro => Some("Custom_Compliments_Pro"),
      Self::Custom_Excuses_Lag => Some("Custom_Excuses_Lag"),
      Self::Custom_Excuses_GhostInputs => Some("Custom_Excuses_GhostInputs"),
      Self::Custom_Excuses_Rigged => Some("Custom_Excuses_Rigged"),
      Self::Custom_Toxic_MafiaPlays => Some("Custom_Toxic_MafiaPlays"),
      Self::Custom_Exclamation_Yeet => Some("Custom_Exclamation_Yeet"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for QuickChatSelection {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for QuickChatSelection {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for QuickChatSelection {
    type Output = QuickChatSelection;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for QuickChatSelection {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for QuickChatSelection {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for QuickChatSelection {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PLAYER_CLASS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PLAYER_CLASS: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PLAYER_CLASS: [PlayerClass; 5] = [
  PlayerClass::NONE,
  PlayerClass::RLBotPlayer,
  PlayerClass::HumanPlayer,
  PlayerClass::PsyonixBotPlayer,
  PlayerClass::PartyMemberBotPlayer,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PlayerClass(pub u8);
#[allow(non_upper_case_globals)]
impl PlayerClass {
  pub const NONE: Self = Self(0);
  pub const RLBotPlayer: Self = Self(1);
  pub const HumanPlayer: Self = Self(2);
  pub const PsyonixBotPlayer: Self = Self(3);
  pub const PartyMemberBotPlayer: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::RLBotPlayer,
    Self::HumanPlayer,
    Self::PsyonixBotPlayer,
    Self::PartyMemberBotPlayer,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::RLBotPlayer => Some("RLBotPlayer"),
      Self::HumanPlayer => Some("HumanPlayer"),
      Self::PsyonixBotPlayer => Some("PsyonixBotPlayer"),
      Self::PartyMemberBotPlayer => Some("PartyMemberBotPlayer"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PlayerClass {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PlayerClass {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PlayerClass {
    type Output = PlayerClass;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PlayerClass {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PlayerClass {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PlayerClass {}
pub struct PlayerClassUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GAME_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GAME_MODE: i8 = 6;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_MODE: [GameMode; 7] = [
  GameMode::Soccer,
  GameMode::Hoops,
  GameMode::Dropshot,
  GameMode::Hockey,
  GameMode::Rumble,
  GameMode::Heatseeker,
  GameMode::Gridiron,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GameMode(pub i8);
#[allow(non_upper_case_globals)]
impl GameMode {
  pub const Soccer: Self = Self(0);
  pub const Hoops: Self = Self(1);
  pub const Dropshot: Self = Self(2);
  pub const Hockey: Self = Self(3);
  pub const Rumble: Self = Self(4);
  pub const Heatseeker: Self = Self(5);
  pub const Gridiron: Self = Self(6);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 6;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Soccer,
    Self::Hoops,
    Self::Dropshot,
    Self::Hockey,
    Self::Rumble,
    Self::Heatseeker,
    Self::Gridiron,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Soccer => Some("Soccer"),
      Self::Hoops => Some("Hoops"),
      Self::Dropshot => Some("Dropshot"),
      Self::Hockey => Some("Hockey"),
      Self::Rumble => Some("Rumble"),
      Self::Heatseeker => Some("Heatseeker"),
      Self::Gridiron => Some("Gridiron"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GameMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GameMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GameMode {
    type Output = GameMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GameMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GameMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GameMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GAME_MAP: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GAME_MAP: i8 = 59;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_MAP: [GameMap; 60] = [
  GameMap::DFHStadium,
  GameMap::Mannfield,
  GameMap::ChampionsField,
  GameMap::UrbanCentral,
  GameMap::BeckwithPark,
  GameMap::UtopiaColiseum,
  GameMap::Wasteland,
  GameMap::NeoTokyo,
  GameMap::AquaDome,
  GameMap::StarbaseArc,
  GameMap::Farmstead,
  GameMap::SaltyShores,
  GameMap::DFHStadium_Stormy,
  GameMap::DFHStadium_Day,
  GameMap::Mannfield_Stormy,
  GameMap::Mannfield_Night,
  GameMap::ChampionsField_Day,
  GameMap::BeckwithPark_Stormy,
  GameMap::BeckwithPark_Midnight,
  GameMap::UrbanCentral_Night,
  GameMap::UrbanCentral_Dawn,
  GameMap::UtopiaColiseum_Dusk,
  GameMap::DFHStadium_Snowy,
  GameMap::Mannfield_Snowy,
  GameMap::UtopiaColiseum_Snowy,
  GameMap::Badlands,
  GameMap::Badlands_Night,
  GameMap::TokyoUnderpass,
  GameMap::Arctagon,
  GameMap::Pillars,
  GameMap::Cosmic,
  GameMap::DoubleGoal,
  GameMap::Octagon,
  GameMap::Underpass,
  GameMap::UtopiaRetro,
  GameMap::Hoops_DunkHouse,
  GameMap::DropShot_Core707,
  GameMap::ThrowbackStadium,
  GameMap::ForbiddenTemple,
  GameMap::RivalsArena,
  GameMap::Farmstead_Night,
  GameMap::SaltyShores_Night,
  GameMap::NeonFields,
  GameMap::DFHStadium_Circuit,
  GameMap::DeadeyeCanyon,
  GameMap::StarbaseArc_Aftermath,
  GameMap::Wasteland_Night,
  GameMap::BeckwithPark_GothamNight,
  GameMap::ForbiddenTemple_Day,
  GameMap::UrbanCentral_Haunted,
  GameMap::ChampionsField_NFL,
  GameMap::ThrowbackStadium_Snowy,
  GameMap::Basin,
  GameMap::Corridor,
  GameMap::Loophole,
  GameMap::Galleon,
  GameMap::GalleonRetro,
  GameMap::Hourglass,
  GameMap::Barricade,
  GameMap::Colossus,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GameMap(pub i8);
#[allow(non_upper_case_globals)]
impl GameMap {
  pub const DFHStadium: Self = Self(0);
  pub const Mannfield: Self = Self(1);
  pub const ChampionsField: Self = Self(2);
  pub const UrbanCentral: Self = Self(3);
  pub const BeckwithPark: Self = Self(4);
  pub const UtopiaColiseum: Self = Self(5);
  pub const Wasteland: Self = Self(6);
  pub const NeoTokyo: Self = Self(7);
  pub const AquaDome: Self = Self(8);
  pub const StarbaseArc: Self = Self(9);
  pub const Farmstead: Self = Self(10);
  pub const SaltyShores: Self = Self(11);
  pub const DFHStadium_Stormy: Self = Self(12);
  pub const DFHStadium_Day: Self = Self(13);
  pub const Mannfield_Stormy: Self = Self(14);
  pub const Mannfield_Night: Self = Self(15);
  pub const ChampionsField_Day: Self = Self(16);
  pub const BeckwithPark_Stormy: Self = Self(17);
  pub const BeckwithPark_Midnight: Self = Self(18);
  pub const UrbanCentral_Night: Self = Self(19);
  pub const UrbanCentral_Dawn: Self = Self(20);
  pub const UtopiaColiseum_Dusk: Self = Self(21);
  pub const DFHStadium_Snowy: Self = Self(22);
  pub const Mannfield_Snowy: Self = Self(23);
  pub const UtopiaColiseum_Snowy: Self = Self(24);
  pub const Badlands: Self = Self(25);
  pub const Badlands_Night: Self = Self(26);
  pub const TokyoUnderpass: Self = Self(27);
  pub const Arctagon: Self = Self(28);
  pub const Pillars: Self = Self(29);
  pub const Cosmic: Self = Self(30);
  pub const DoubleGoal: Self = Self(31);
  pub const Octagon: Self = Self(32);
  pub const Underpass: Self = Self(33);
  pub const UtopiaRetro: Self = Self(34);
  pub const Hoops_DunkHouse: Self = Self(35);
  pub const DropShot_Core707: Self = Self(36);
  pub const ThrowbackStadium: Self = Self(37);
  pub const ForbiddenTemple: Self = Self(38);
  pub const RivalsArena: Self = Self(39);
  pub const Farmstead_Night: Self = Self(40);
  pub const SaltyShores_Night: Self = Self(41);
  pub const NeonFields: Self = Self(42);
  pub const DFHStadium_Circuit: Self = Self(43);
  pub const DeadeyeCanyon: Self = Self(44);
  pub const StarbaseArc_Aftermath: Self = Self(45);
  pub const Wasteland_Night: Self = Self(46);
  pub const BeckwithPark_GothamNight: Self = Self(47);
  pub const ForbiddenTemple_Day: Self = Self(48);
  pub const UrbanCentral_Haunted: Self = Self(49);
  pub const ChampionsField_NFL: Self = Self(50);
  pub const ThrowbackStadium_Snowy: Self = Self(51);
  pub const Basin: Self = Self(52);
  pub const Corridor: Self = Self(53);
  pub const Loophole: Self = Self(54);
  pub const Galleon: Self = Self(55);
  pub const GalleonRetro: Self = Self(56);
  pub const Hourglass: Self = Self(57);
  pub const Barricade: Self = Self(58);
  pub const Colossus: Self = Self(59);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 59;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DFHStadium,
    Self::Mannfield,
    Self::ChampionsField,
    Self::UrbanCentral,
    Self::BeckwithPark,
    Self::UtopiaColiseum,
    Self::Wasteland,
    Self::NeoTokyo,
    Self::AquaDome,
    Self::StarbaseArc,
    Self::Farmstead,
    Self::SaltyShores,
    Self::DFHStadium_Stormy,
    Self::DFHStadium_Day,
    Self::Mannfield_Stormy,
    Self::Mannfield_Night,
    Self::ChampionsField_Day,
    Self::BeckwithPark_Stormy,
    Self::BeckwithPark_Midnight,
    Self::UrbanCentral_Night,
    Self::UrbanCentral_Dawn,
    Self::UtopiaColiseum_Dusk,
    Self::DFHStadium_Snowy,
    Self::Mannfield_Snowy,
    Self::UtopiaColiseum_Snowy,
    Self::Badlands,
    Self::Badlands_Night,
    Self::TokyoUnderpass,
    Self::Arctagon,
    Self::Pillars,
    Self::Cosmic,
    Self::DoubleGoal,
    Self::Octagon,
    Self::Underpass,
    Self::UtopiaRetro,
    Self::Hoops_DunkHouse,
    Self::DropShot_Core707,
    Self::ThrowbackStadium,
    Self::ForbiddenTemple,
    Self::RivalsArena,
    Self::Farmstead_Night,
    Self::SaltyShores_Night,
    Self::NeonFields,
    Self::DFHStadium_Circuit,
    Self::DeadeyeCanyon,
    Self::StarbaseArc_Aftermath,
    Self::Wasteland_Night,
    Self::BeckwithPark_GothamNight,
    Self::ForbiddenTemple_Day,
    Self::UrbanCentral_Haunted,
    Self::ChampionsField_NFL,
    Self::ThrowbackStadium_Snowy,
    Self::Basin,
    Self::Corridor,
    Self::Loophole,
    Self::Galleon,
    Self::GalleonRetro,
    Self::Hourglass,
    Self::Barricade,
    Self::Colossus,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DFHStadium => Some("DFHStadium"),
      Self::Mannfield => Some("Mannfield"),
      Self::ChampionsField => Some("ChampionsField"),
      Self::UrbanCentral => Some("UrbanCentral"),
      Self::BeckwithPark => Some("BeckwithPark"),
      Self::UtopiaColiseum => Some("UtopiaColiseum"),
      Self::Wasteland => Some("Wasteland"),
      Self::NeoTokyo => Some("NeoTokyo"),
      Self::AquaDome => Some("AquaDome"),
      Self::StarbaseArc => Some("StarbaseArc"),
      Self::Farmstead => Some("Farmstead"),
      Self::SaltyShores => Some("SaltyShores"),
      Self::DFHStadium_Stormy => Some("DFHStadium_Stormy"),
      Self::DFHStadium_Day => Some("DFHStadium_Day"),
      Self::Mannfield_Stormy => Some("Mannfield_Stormy"),
      Self::Mannfield_Night => Some("Mannfield_Night"),
      Self::ChampionsField_Day => Some("ChampionsField_Day"),
      Self::BeckwithPark_Stormy => Some("BeckwithPark_Stormy"),
      Self::BeckwithPark_Midnight => Some("BeckwithPark_Midnight"),
      Self::UrbanCentral_Night => Some("UrbanCentral_Night"),
      Self::UrbanCentral_Dawn => Some("UrbanCentral_Dawn"),
      Self::UtopiaColiseum_Dusk => Some("UtopiaColiseum_Dusk"),
      Self::DFHStadium_Snowy => Some("DFHStadium_Snowy"),
      Self::Mannfield_Snowy => Some("Mannfield_Snowy"),
      Self::UtopiaColiseum_Snowy => Some("UtopiaColiseum_Snowy"),
      Self::Badlands => Some("Badlands"),
      Self::Badlands_Night => Some("Badlands_Night"),
      Self::TokyoUnderpass => Some("TokyoUnderpass"),
      Self::Arctagon => Some("Arctagon"),
      Self::Pillars => Some("Pillars"),
      Self::Cosmic => Some("Cosmic"),
      Self::DoubleGoal => Some("DoubleGoal"),
      Self::Octagon => Some("Octagon"),
      Self::Underpass => Some("Underpass"),
      Self::UtopiaRetro => Some("UtopiaRetro"),
      Self::Hoops_DunkHouse => Some("Hoops_DunkHouse"),
      Self::DropShot_Core707 => Some("DropShot_Core707"),
      Self::ThrowbackStadium => Some("ThrowbackStadium"),
      Self::ForbiddenTemple => Some("ForbiddenTemple"),
      Self::RivalsArena => Some("RivalsArena"),
      Self::Farmstead_Night => Some("Farmstead_Night"),
      Self::SaltyShores_Night => Some("SaltyShores_Night"),
      Self::NeonFields => Some("NeonFields"),
      Self::DFHStadium_Circuit => Some("DFHStadium_Circuit"),
      Self::DeadeyeCanyon => Some("DeadeyeCanyon"),
      Self::StarbaseArc_Aftermath => Some("StarbaseArc_Aftermath"),
      Self::Wasteland_Night => Some("Wasteland_Night"),
      Self::BeckwithPark_GothamNight => Some("BeckwithPark_GothamNight"),
      Self::ForbiddenTemple_Day => Some("ForbiddenTemple_Day"),
      Self::UrbanCentral_Haunted => Some("UrbanCentral_Haunted"),
      Self::ChampionsField_NFL => Some("ChampionsField_NFL"),
      Self::ThrowbackStadium_Snowy => Some("ThrowbackStadium_Snowy"),
      Self::Basin => Some("Basin"),
      Self::Corridor => Some("Corridor"),
      Self::Loophole => Some("Loophole"),
      Self::Galleon => Some("Galleon"),
      Self::GalleonRetro => Some("GalleonRetro"),
      Self::Hourglass => Some("Hourglass"),
      Self::Barricade => Some("Barricade"),
      Self::Colossus => Some("Colossus"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GameMap {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GameMap {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GameMap {
    type Output = GameMap;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GameMap {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GameMap {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GameMap {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MATCH_LENGTH: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MATCH_LENGTH: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATCH_LENGTH: [MatchLength; 4] = [
  MatchLength::Five_Minutes,
  MatchLength::Ten_Minutes,
  MatchLength::Twenty_Minutes,
  MatchLength::Unlimited,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MatchLength(pub i8);
#[allow(non_upper_case_globals)]
impl MatchLength {
  pub const Five_Minutes: Self = Self(0);
  pub const Ten_Minutes: Self = Self(1);
  pub const Twenty_Minutes: Self = Self(2);
  pub const Unlimited: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Five_Minutes,
    Self::Ten_Minutes,
    Self::Twenty_Minutes,
    Self::Unlimited,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Five_Minutes => Some("Five_Minutes"),
      Self::Ten_Minutes => Some("Ten_Minutes"),
      Self::Twenty_Minutes => Some("Twenty_Minutes"),
      Self::Unlimited => Some("Unlimited"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MatchLength {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MatchLength {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MatchLength {
    type Output = MatchLength;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MatchLength {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MatchLength {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MatchLength {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MAX_SCORE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MAX_SCORE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MAX_SCORE: [MaxScore; 4] = [
  MaxScore::Unlimited,
  MaxScore::One_Goal,
  MaxScore::Three_Goals,
  MaxScore::Five_Goals,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MaxScore(pub i8);
#[allow(non_upper_case_globals)]
impl MaxScore {
  pub const Unlimited: Self = Self(0);
  pub const One_Goal: Self = Self(1);
  pub const Three_Goals: Self = Self(2);
  pub const Five_Goals: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unlimited,
    Self::One_Goal,
    Self::Three_Goals,
    Self::Five_Goals,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unlimited => Some("Unlimited"),
      Self::One_Goal => Some("One_Goal"),
      Self::Three_Goals => Some("Three_Goals"),
      Self::Five_Goals => Some("Five_Goals"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MaxScore {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MaxScore {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MaxScore {
    type Output = MaxScore;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MaxScore {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MaxScore {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MaxScore {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OVERTIME_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OVERTIME_OPTION: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OVERTIME_OPTION: [OvertimeOption; 3] = [
  OvertimeOption::Unlimited,
  OvertimeOption::Five_Max_First_Score,
  OvertimeOption::Five_Max_Random_Team,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OvertimeOption(pub i8);
#[allow(non_upper_case_globals)]
impl OvertimeOption {
  pub const Unlimited: Self = Self(0);
  pub const Five_Max_First_Score: Self = Self(1);
  pub const Five_Max_Random_Team: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unlimited,
    Self::Five_Max_First_Score,
    Self::Five_Max_Random_Team,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unlimited => Some("Unlimited"),
      Self::Five_Max_First_Score => Some("Five_Max_First_Score"),
      Self::Five_Max_Random_Team => Some("Five_Max_Random_Team"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OvertimeOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OvertimeOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OvertimeOption {
    type Output = OvertimeOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OvertimeOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OvertimeOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OvertimeOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SERIES_LENGTH_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SERIES_LENGTH_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SERIES_LENGTH_OPTION: [SeriesLengthOption; 4] = [
  SeriesLengthOption::Unlimited,
  SeriesLengthOption::Three_Games,
  SeriesLengthOption::Five_Games,
  SeriesLengthOption::Seven_Games,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SeriesLengthOption(pub i8);
#[allow(non_upper_case_globals)]
impl SeriesLengthOption {
  pub const Unlimited: Self = Self(0);
  pub const Three_Games: Self = Self(1);
  pub const Five_Games: Self = Self(2);
  pub const Seven_Games: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Unlimited,
    Self::Three_Games,
    Self::Five_Games,
    Self::Seven_Games,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Unlimited => Some("Unlimited"),
      Self::Three_Games => Some("Three_Games"),
      Self::Five_Games => Some("Five_Games"),
      Self::Seven_Games => Some("Seven_Games"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SeriesLengthOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SeriesLengthOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SeriesLengthOption {
    type Output = SeriesLengthOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SeriesLengthOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SeriesLengthOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SeriesLengthOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GAME_SPEED_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GAME_SPEED_OPTION: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_SPEED_OPTION: [GameSpeedOption; 3] = [
  GameSpeedOption::Default,
  GameSpeedOption::Slo_Mo,
  GameSpeedOption::Time_Warp,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GameSpeedOption(pub i8);
#[allow(non_upper_case_globals)]
impl GameSpeedOption {
  pub const Default: Self = Self(0);
  pub const Slo_Mo: Self = Self(1);
  pub const Time_Warp: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Slo_Mo,
    Self::Time_Warp,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Slo_Mo => Some("Slo_Mo"),
      Self::Time_Warp => Some("Time_Warp"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GameSpeedOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GameSpeedOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GameSpeedOption {
    type Output = GameSpeedOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GameSpeedOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GameSpeedOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GameSpeedOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALL_MAX_SPEED_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALL_MAX_SPEED_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALL_MAX_SPEED_OPTION: [BallMaxSpeedOption; 4] = [
  BallMaxSpeedOption::Default,
  BallMaxSpeedOption::Slow,
  BallMaxSpeedOption::Fast,
  BallMaxSpeedOption::Super_Fast,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallMaxSpeedOption(pub i8);
#[allow(non_upper_case_globals)]
impl BallMaxSpeedOption {
  pub const Default: Self = Self(0);
  pub const Slow: Self = Self(1);
  pub const Fast: Self = Self(2);
  pub const Super_Fast: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Slow,
    Self::Fast,
    Self::Super_Fast,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Slow => Some("Slow"),
      Self::Fast => Some("Fast"),
      Self::Super_Fast => Some("Super_Fast"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallMaxSpeedOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallMaxSpeedOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallMaxSpeedOption {
    type Output = BallMaxSpeedOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallMaxSpeedOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallMaxSpeedOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallMaxSpeedOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALL_TYPE_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALL_TYPE_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALL_TYPE_OPTION: [BallTypeOption; 4] = [
  BallTypeOption::Default,
  BallTypeOption::Cube,
  BallTypeOption::Puck,
  BallTypeOption::Basketball,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallTypeOption(pub i8);
#[allow(non_upper_case_globals)]
impl BallTypeOption {
  pub const Default: Self = Self(0);
  pub const Cube: Self = Self(1);
  pub const Puck: Self = Self(2);
  pub const Basketball: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Cube,
    Self::Puck,
    Self::Basketball,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Cube => Some("Cube"),
      Self::Puck => Some("Puck"),
      Self::Basketball => Some("Basketball"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallTypeOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallTypeOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallTypeOption {
    type Output = BallTypeOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallTypeOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallTypeOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallTypeOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALL_WEIGHT_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALL_WEIGHT_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALL_WEIGHT_OPTION: [BallWeightOption; 4] = [
  BallWeightOption::Default,
  BallWeightOption::Light,
  BallWeightOption::Heavy,
  BallWeightOption::Super_Light,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallWeightOption(pub i8);
#[allow(non_upper_case_globals)]
impl BallWeightOption {
  pub const Default: Self = Self(0);
  pub const Light: Self = Self(1);
  pub const Heavy: Self = Self(2);
  pub const Super_Light: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Light,
    Self::Heavy,
    Self::Super_Light,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Light => Some("Light"),
      Self::Heavy => Some("Heavy"),
      Self::Super_Light => Some("Super_Light"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallWeightOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallWeightOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallWeightOption {
    type Output = BallWeightOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallWeightOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallWeightOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallWeightOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALL_SIZE_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALL_SIZE_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALL_SIZE_OPTION: [BallSizeOption; 4] = [
  BallSizeOption::Default,
  BallSizeOption::Small,
  BallSizeOption::Large,
  BallSizeOption::Gigantic,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallSizeOption(pub i8);
#[allow(non_upper_case_globals)]
impl BallSizeOption {
  pub const Default: Self = Self(0);
  pub const Small: Self = Self(1);
  pub const Large: Self = Self(2);
  pub const Gigantic: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Small,
    Self::Large,
    Self::Gigantic,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Small => Some("Small"),
      Self::Large => Some("Large"),
      Self::Gigantic => Some("Gigantic"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallSizeOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallSizeOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallSizeOption {
    type Output = BallSizeOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallSizeOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallSizeOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallSizeOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BALL_BOUNCINESS_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BALL_BOUNCINESS_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BALL_BOUNCINESS_OPTION: [BallBouncinessOption; 4] = [
  BallBouncinessOption::Default,
  BallBouncinessOption::Low,
  BallBouncinessOption::High,
  BallBouncinessOption::Super_High,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BallBouncinessOption(pub i8);
#[allow(non_upper_case_globals)]
impl BallBouncinessOption {
  pub const Default: Self = Self(0);
  pub const Low: Self = Self(1);
  pub const High: Self = Self(2);
  pub const Super_High: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Low,
    Self::High,
    Self::Super_High,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Low => Some("Low"),
      Self::High => Some("High"),
      Self::Super_High => Some("Super_High"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BallBouncinessOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BallBouncinessOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BallBouncinessOption {
    type Output = BallBouncinessOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BallBouncinessOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BallBouncinessOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BallBouncinessOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BOOST_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BOOST_OPTION: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BOOST_OPTION: [BoostOption; 5] = [
  BoostOption::Normal_Boost,
  BoostOption::Unlimited_Boost,
  BoostOption::Slow_Recharge,
  BoostOption::Rapid_Recharge,
  BoostOption::No_Boost,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BoostOption(pub i8);
#[allow(non_upper_case_globals)]
impl BoostOption {
  pub const Normal_Boost: Self = Self(0);
  pub const Unlimited_Boost: Self = Self(1);
  pub const Slow_Recharge: Self = Self(2);
  pub const Rapid_Recharge: Self = Self(3);
  pub const No_Boost: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Normal_Boost,
    Self::Unlimited_Boost,
    Self::Slow_Recharge,
    Self::Rapid_Recharge,
    Self::No_Boost,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Normal_Boost => Some("Normal_Boost"),
      Self::Unlimited_Boost => Some("Unlimited_Boost"),
      Self::Slow_Recharge => Some("Slow_Recharge"),
      Self::Rapid_Recharge => Some("Rapid_Recharge"),
      Self::No_Boost => Some("No_Boost"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BoostOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BoostOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BoostOption {
    type Output = BoostOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BoostOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BoostOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BoostOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RUMBLE_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RUMBLE_OPTION: i8 = 7;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RUMBLE_OPTION: [RumbleOption; 8] = [
  RumbleOption::No_Rumble,
  RumbleOption::Default,
  RumbleOption::Slow,
  RumbleOption::Civilized,
  RumbleOption::Destruction_Derby,
  RumbleOption::Spring_Loaded,
  RumbleOption::Spikes_Only,
  RumbleOption::Spike_Rush,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RumbleOption(pub i8);
#[allow(non_upper_case_globals)]
impl RumbleOption {
  pub const No_Rumble: Self = Self(0);
  pub const Default: Self = Self(1);
  pub const Slow: Self = Self(2);
  pub const Civilized: Self = Self(3);
  pub const Destruction_Derby: Self = Self(4);
  pub const Spring_Loaded: Self = Self(5);
  pub const Spikes_Only: Self = Self(6);
  pub const Spike_Rush: Self = Self(7);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 7;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::No_Rumble,
    Self::Default,
    Self::Slow,
    Self::Civilized,
    Self::Destruction_Derby,
    Self::Spring_Loaded,
    Self::Spikes_Only,
    Self::Spike_Rush,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::No_Rumble => Some("No_Rumble"),
      Self::Default => Some("Default"),
      Self::Slow => Some("Slow"),
      Self::Civilized => Some("Civilized"),
      Self::Destruction_Derby => Some("Destruction_Derby"),
      Self::Spring_Loaded => Some("Spring_Loaded"),
      Self::Spikes_Only => Some("Spikes_Only"),
      Self::Spike_Rush => Some("Spike_Rush"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RumbleOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RumbleOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RumbleOption {
    type Output = RumbleOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RumbleOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RumbleOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RumbleOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BOOST_STRENGTH_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BOOST_STRENGTH_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BOOST_STRENGTH_OPTION: [BoostStrengthOption; 4] = [
  BoostStrengthOption::One,
  BoostStrengthOption::OneAndAHalf,
  BoostStrengthOption::Two,
  BoostStrengthOption::Ten,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BoostStrengthOption(pub i8);
#[allow(non_upper_case_globals)]
impl BoostStrengthOption {
  pub const One: Self = Self(0);
  pub const OneAndAHalf: Self = Self(1);
  pub const Two: Self = Self(2);
  pub const Ten: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::One,
    Self::OneAndAHalf,
    Self::Two,
    Self::Ten,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::One => Some("One"),
      Self::OneAndAHalf => Some("OneAndAHalf"),
      Self::Two => Some("Two"),
      Self::Ten => Some("Ten"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BoostStrengthOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BoostStrengthOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BoostStrengthOption {
    type Output = BoostStrengthOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BoostStrengthOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BoostStrengthOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BoostStrengthOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRAVITY_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRAVITY_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRAVITY_OPTION: [GravityOption; 4] = [
  GravityOption::Default,
  GravityOption::Low,
  GravityOption::High,
  GravityOption::Super_High,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GravityOption(pub i8);
#[allow(non_upper_case_globals)]
impl GravityOption {
  pub const Default: Self = Self(0);
  pub const Low: Self = Self(1);
  pub const High: Self = Self(2);
  pub const Super_High: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Low,
    Self::High,
    Self::Super_High,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Low => Some("Low"),
      Self::High => Some("High"),
      Self::Super_High => Some("Super_High"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GravityOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GravityOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GravityOption {
    type Output = GravityOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GravityOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GravityOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GravityOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DEMOLISH_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DEMOLISH_OPTION: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DEMOLISH_OPTION: [DemolishOption; 5] = [
  DemolishOption::Default,
  DemolishOption::Disabled,
  DemolishOption::Friendly_Fire,
  DemolishOption::On_Contact,
  DemolishOption::On_Contact_FF,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DemolishOption(pub i8);
#[allow(non_upper_case_globals)]
impl DemolishOption {
  pub const Default: Self = Self(0);
  pub const Disabled: Self = Self(1);
  pub const Friendly_Fire: Self = Self(2);
  pub const On_Contact: Self = Self(3);
  pub const On_Contact_FF: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Default,
    Self::Disabled,
    Self::Friendly_Fire,
    Self::On_Contact,
    Self::On_Contact_FF,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Default => Some("Default"),
      Self::Disabled => Some("Disabled"),
      Self::Friendly_Fire => Some("Friendly_Fire"),
      Self::On_Contact => Some("On_Contact"),
      Self::On_Contact_FF => Some("On_Contact_FF"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DemolishOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DemolishOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DemolishOption {
    type Output = DemolishOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DemolishOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DemolishOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DemolishOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_RESPAWN_TIME_OPTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_RESPAWN_TIME_OPTION: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPAWN_TIME_OPTION: [RespawnTimeOption; 4] = [
  RespawnTimeOption::Three_Seconds,
  RespawnTimeOption::Two_Seconds,
  RespawnTimeOption::One_Seconds,
  RespawnTimeOption::Disable_Goal_Reset,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RespawnTimeOption(pub i8);
#[allow(non_upper_case_globals)]
impl RespawnTimeOption {
  pub const Three_Seconds: Self = Self(0);
  pub const Two_Seconds: Self = Self(1);
  pub const One_Seconds: Self = Self(2);
  pub const Disable_Goal_Reset: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Three_Seconds,
    Self::Two_Seconds,
    Self::One_Seconds,
    Self::Disable_Goal_Reset,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Three_Seconds => Some("Three_Seconds"),
      Self::Two_Seconds => Some("Two_Seconds"),
      Self::One_Seconds => Some("One_Seconds"),
      Self::Disable_Goal_Reset => Some("Disable_Goal_Reset"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for RespawnTimeOption {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for RespawnTimeOption {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for RespawnTimeOption {
    type Output = RespawnTimeOption;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RespawnTimeOption {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for RespawnTimeOption {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RespawnTimeOption {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_EXISTING_MATCH_BEHAVIOR: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_EXISTING_MATCH_BEHAVIOR: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXISTING_MATCH_BEHAVIOR: [ExistingMatchBehavior; 3] = [
  ExistingMatchBehavior::Restart_If_Different,
  ExistingMatchBehavior::Restart,
  ExistingMatchBehavior::Continue_And_Spawn,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExistingMatchBehavior(pub i8);
#[allow(non_upper_case_globals)]
impl ExistingMatchBehavior {
  /// Restart the match if any match settings differ. This is the default because old RLBot always worked this way.
  pub const Restart_If_Different: Self = Self(0);
  /// Always restart the match, even if config is identical
  pub const Restart: Self = Self(1);
  /// Never restart an existing match, just try to remove or spawn cars to match the configuration.
  /// If we are not in the middle of a match, a match will be started. Handy for LAN matches.
  pub const Continue_And_Spawn: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Restart_If_Different,
    Self::Restart,
    Self::Continue_And_Spawn,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Restart_If_Different => Some("Restart_If_Different"),
      Self::Restart => Some("Restart"),
      Self::Continue_And_Spawn => Some("Continue_And_Spawn"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ExistingMatchBehavior {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ExistingMatchBehavior {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ExistingMatchBehavior {
    type Output = ExistingMatchBehavior;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ExistingMatchBehavior {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ExistingMatchBehavior {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ExistingMatchBehavior {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GAME_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GAME_MESSAGE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_MESSAGE: [GameMessage; 4] = [
  GameMessage::NONE,
  GameMessage::PlayerStatEvent,
  GameMessage::PlayerSpectate,
  GameMessage::PlayerInputChange,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GameMessage(pub u8);
#[allow(non_upper_case_globals)]
impl GameMessage {
  pub const NONE: Self = Self(0);
  pub const PlayerStatEvent: Self = Self(1);
  pub const PlayerSpectate: Self = Self(2);
  pub const PlayerInputChange: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PlayerStatEvent,
    Self::PlayerSpectate,
    Self::PlayerInputChange,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::PlayerStatEvent => Some("PlayerStatEvent"),
      Self::PlayerSpectate => Some("PlayerSpectate"),
      Self::PlayerInputChange => Some("PlayerInputChange"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GameMessage {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GameMessage {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GameMessage {
    type Output = GameMessage;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GameMessage {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GameMessage {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GameMessage {}
pub struct GameMessageUnionTableOffset {}

// struct Vector3, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector3(pub [u8; 12]);
impl Default for Vector3 { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Vector3 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector3")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector3 {}
impl<'a> flatbuffers::Follow<'a> for Vector3 {
  type Inner = &'a Vector3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector3>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector3 {
  type Inner = &'a Vector3;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector3>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector3 {
    type Output = Vector3;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector3 as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector3 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector3 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

/// Expresses the rotation state of an object in Euler angles, with values in radians.
// struct Rotator, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Rotator(pub [u8; 12]);
impl Default for Rotator { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Rotator {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Rotator")
      .field("pitch", &self.pitch())
      .field("yaw", &self.yaw())
      .field("roll", &self.roll())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Rotator {}
impl<'a> flatbuffers::Follow<'a> for Rotator {
  type Inner = &'a Rotator;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Rotator>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Rotator {
  type Inner = &'a Rotator;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Rotator>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Rotator {
    type Output = Rotator;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Rotator as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Rotator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Rotator {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    pitch: f32,
    yaw: f32,
    roll: f32,
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_pitch(pitch);
    s.set_yaw(yaw);
    s.set_roll(roll);
    s
  }

  pub fn pitch(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_pitch(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn yaw(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_yaw(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn roll(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_roll(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

/// Expresses the rotation state of an object.
/// Learn about quaternions here: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
/// You can tinker with them here to build an intuition: https://quaternions.online/
// struct Quaternion, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Quaternion(pub [u8; 16]);
impl Default for Quaternion { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Quaternion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Quaternion")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .field("w", &self.w())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Quaternion {}
impl<'a> flatbuffers::Follow<'a> for Quaternion {
  type Inner = &'a Quaternion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Quaternion>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Quaternion {
  type Inner = &'a Quaternion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Quaternion>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Quaternion {
    type Output = Quaternion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Quaternion as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Quaternion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Quaternion {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
    z: f32,
    w: f32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s.set_w(w);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn w(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_w(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Float, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Float(pub [u8; 4]);
impl Default for Float { 
  fn default() -> Self { 
    Self([0; 4])
  }
}
impl core::fmt::Debug for Float {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Float")
      .field("val", &self.val())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Float {}
impl<'a> flatbuffers::Follow<'a> for Float {
  type Inner = &'a Float;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Float>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Float {
  type Inner = &'a Float;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Float>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Float {
    type Output = Float;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Float as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Float {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Float {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    val: f32,
  ) -> Self {
    let mut s = Self([0; 4]);
    s.set_val(val);
    s
  }

  pub fn val(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_val(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Bool, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Bool(pub [u8; 1]);
impl Default for Bool { 
  fn default() -> Self { 
    Self([0; 1])
  }
}
impl core::fmt::Debug for Bool {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Bool")
      .field("val", &self.val())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Bool {}
impl<'a> flatbuffers::Follow<'a> for Bool {
  type Inner = &'a Bool;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Bool>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Bool {
  type Inner = &'a Bool;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Bool>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Bool {
    type Output = Bool;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Bool as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Bool {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Bool {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    val: bool,
  ) -> Self {
    let mut s = Self([0; 1]);
    s.set_val(val);
    s
  }

  pub fn val(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_val(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ControllerStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ControllerState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ControllerState<'a> {
  type Inner = ControllerState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ControllerState<'a> {
  pub const VT_THROTTLE: flatbuffers::VOffsetT = 4;
  pub const VT_STEER: flatbuffers::VOffsetT = 6;
  pub const VT_PITCH: flatbuffers::VOffsetT = 8;
  pub const VT_YAW: flatbuffers::VOffsetT = 10;
  pub const VT_ROLL: flatbuffers::VOffsetT = 12;
  pub const VT_JUMP: flatbuffers::VOffsetT = 14;
  pub const VT_BOOST: flatbuffers::VOffsetT = 16;
  pub const VT_HANDBRAKE: flatbuffers::VOffsetT = 18;
  pub const VT_USEITEM: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ControllerState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ControllerStateArgs
  ) -> flatbuffers::WIPOffset<ControllerState<'bldr>> {
    let mut builder = ControllerStateBuilder::new(_fbb);
    builder.add_roll(args.roll);
    builder.add_yaw(args.yaw);
    builder.add_pitch(args.pitch);
    builder.add_steer(args.steer);
    builder.add_throttle(args.throttle);
    builder.add_useItem(args.useItem);
    builder.add_handbrake(args.handbrake);
    builder.add_boost(args.boost);
    builder.add_jump(args.jump);
    builder.finish()
  }


  /// -1 for full reverse, 1 for full forward
  #[inline]
  pub fn throttle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ControllerState::VT_THROTTLE, Some(0.0)).unwrap()}
  }
  /// -1 for full left, 1 for full right
  #[inline]
  pub fn steer(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ControllerState::VT_STEER, Some(0.0)).unwrap()}
  }
  /// -1 for nose down, 1 for nose up
  #[inline]
  pub fn pitch(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ControllerState::VT_PITCH, Some(0.0)).unwrap()}
  }
  /// -1 for full left, 1 for full right
  #[inline]
  pub fn yaw(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ControllerState::VT_YAW, Some(0.0)).unwrap()}
  }
  /// -1 for roll left, 1 for roll right
  #[inline]
  pub fn roll(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(ControllerState::VT_ROLL, Some(0.0)).unwrap()}
  }
  /// true if you want to press the jump button
  #[inline]
  pub fn jump(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ControllerState::VT_JUMP, Some(false)).unwrap()}
  }
  /// true if you want to press the boost button
  #[inline]
  pub fn boost(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ControllerState::VT_BOOST, Some(false)).unwrap()}
  }
  /// true if you want to press the handbrake button
  #[inline]
  pub fn handbrake(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ControllerState::VT_HANDBRAKE, Some(false)).unwrap()}
  }
  /// true if you want to press the 'use item' button, used in rumble etc.
  #[inline]
  pub fn useItem(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ControllerState::VT_USEITEM, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ControllerState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("throttle", Self::VT_THROTTLE, false)?
     .visit_field::<f32>("steer", Self::VT_STEER, false)?
     .visit_field::<f32>("pitch", Self::VT_PITCH, false)?
     .visit_field::<f32>("yaw", Self::VT_YAW, false)?
     .visit_field::<f32>("roll", Self::VT_ROLL, false)?
     .visit_field::<bool>("jump", Self::VT_JUMP, false)?
     .visit_field::<bool>("boost", Self::VT_BOOST, false)?
     .visit_field::<bool>("handbrake", Self::VT_HANDBRAKE, false)?
     .visit_field::<bool>("useItem", Self::VT_USEITEM, false)?
     .finish();
    Ok(())
  }
}
pub struct ControllerStateArgs {
    pub throttle: f32,
    pub steer: f32,
    pub pitch: f32,
    pub yaw: f32,
    pub roll: f32,
    pub jump: bool,
    pub boost: bool,
    pub handbrake: bool,
    pub useItem: bool,
}
impl<'a> Default for ControllerStateArgs {
  #[inline]
  fn default() -> Self {
    ControllerStateArgs {
      throttle: 0.0,
      steer: 0.0,
      pitch: 0.0,
      yaw: 0.0,
      roll: 0.0,
      jump: false,
      boost: false,
      handbrake: false,
      useItem: false,
    }
  }
}

pub struct ControllerStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ControllerStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_throttle(&mut self, throttle: f32) {
    self.fbb_.push_slot::<f32>(ControllerState::VT_THROTTLE, throttle, 0.0);
  }
  #[inline]
  pub fn add_steer(&mut self, steer: f32) {
    self.fbb_.push_slot::<f32>(ControllerState::VT_STEER, steer, 0.0);
  }
  #[inline]
  pub fn add_pitch(&mut self, pitch: f32) {
    self.fbb_.push_slot::<f32>(ControllerState::VT_PITCH, pitch, 0.0);
  }
  #[inline]
  pub fn add_yaw(&mut self, yaw: f32) {
    self.fbb_.push_slot::<f32>(ControllerState::VT_YAW, yaw, 0.0);
  }
  #[inline]
  pub fn add_roll(&mut self, roll: f32) {
    self.fbb_.push_slot::<f32>(ControllerState::VT_ROLL, roll, 0.0);
  }
  #[inline]
  pub fn add_jump(&mut self, jump: bool) {
    self.fbb_.push_slot::<bool>(ControllerState::VT_JUMP, jump, false);
  }
  #[inline]
  pub fn add_boost(&mut self, boost: bool) {
    self.fbb_.push_slot::<bool>(ControllerState::VT_BOOST, boost, false);
  }
  #[inline]
  pub fn add_handbrake(&mut self, handbrake: bool) {
    self.fbb_.push_slot::<bool>(ControllerState::VT_HANDBRAKE, handbrake, false);
  }
  #[inline]
  pub fn add_useItem(&mut self, useItem: bool) {
    self.fbb_.push_slot::<bool>(ControllerState::VT_USEITEM, useItem, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ControllerStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ControllerStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ControllerState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ControllerState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ControllerState");
      ds.field("throttle", &self.throttle());
      ds.field("steer", &self.steer());
      ds.field("pitch", &self.pitch());
      ds.field("yaw", &self.yaw());
      ds.field("roll", &self.roll());
      ds.field("jump", &self.jump());
      ds.field("boost", &self.boost());
      ds.field("handbrake", &self.handbrake());
      ds.field("useItem", &self.useItem());
      ds.finish()
  }
}
pub enum PlayerInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayerInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerInput<'a> {
  type Inner = PlayerInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerInput<'a> {
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
  pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerInputArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerInput<'bldr>> {
    let mut builder = PlayerInputBuilder::new(_fbb);
    if let Some(x) = args.controllerState { builder.add_controllerState(x); }
    builder.add_playerIndex(args.playerIndex);
    builder.finish()
  }


  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerInput::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn controllerState(&self) -> Option<ControllerState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ControllerState>>(PlayerInput::VT_CONTROLLERSTATE, None)}
  }
}

impl flatbuffers::Verifiable for PlayerInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>("controllerState", Self::VT_CONTROLLERSTATE, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerInputArgs<'a> {
    pub playerIndex: i32,
    pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
}
impl<'a> Default for PlayerInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerInputArgs {
      playerIndex: 0,
      controllerState: None,
    }
  }
}

pub struct PlayerInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(PlayerInput::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn add_controllerState(&mut self, controllerState: flatbuffers::WIPOffset<ControllerState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(PlayerInput::VT_CONTROLLERSTATE, controllerState);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerInput");
      ds.field("playerIndex", &self.playerIndex());
      ds.field("controllerState", &self.controllerState());
      ds.finish()
  }
}
pub enum BoxShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoxShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoxShape<'a> {
  type Inner = BoxShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoxShape<'a> {
  pub const VT_LENGTH: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoxShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoxShapeArgs
  ) -> flatbuffers::WIPOffset<BoxShape<'bldr>> {
    let mut builder = BoxShapeBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_length(args.length);
    builder.finish()
  }


  #[inline]
  pub fn length(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BoxShape::VT_LENGTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BoxShape::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BoxShape::VT_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoxShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("length", Self::VT_LENGTH, false)?
     .visit_field::<f32>("width", Self::VT_WIDTH, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct BoxShapeArgs {
    pub length: f32,
    pub width: f32,
    pub height: f32,
}
impl<'a> Default for BoxShapeArgs {
  #[inline]
  fn default() -> Self {
    BoxShapeArgs {
      length: 0.0,
      width: 0.0,
      height: 0.0,
    }
  }
}

pub struct BoxShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoxShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_length(&mut self, length: f32) {
    self.fbb_.push_slot::<f32>(BoxShape::VT_LENGTH, length, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f32) {
    self.fbb_.push_slot::<f32>(BoxShape::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(BoxShape::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoxShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoxShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoxShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoxShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoxShape");
      ds.field("length", &self.length());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum SphereShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SphereShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SphereShape<'a> {
  type Inner = SphereShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SphereShape<'a> {
  pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SphereShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SphereShapeArgs
  ) -> flatbuffers::WIPOffset<SphereShape<'bldr>> {
    let mut builder = SphereShapeBuilder::new(_fbb);
    builder.add_diameter(args.diameter);
    builder.finish()
  }


  #[inline]
  pub fn diameter(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(SphereShape::VT_DIAMETER, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SphereShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("diameter", Self::VT_DIAMETER, false)?
     .finish();
    Ok(())
  }
}
pub struct SphereShapeArgs {
    pub diameter: f32,
}
impl<'a> Default for SphereShapeArgs {
  #[inline]
  fn default() -> Self {
    SphereShapeArgs {
      diameter: 0.0,
    }
  }
}

pub struct SphereShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SphereShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_diameter(&mut self, diameter: f32) {
    self.fbb_.push_slot::<f32>(SphereShape::VT_DIAMETER, diameter, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SphereShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SphereShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SphereShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SphereShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SphereShape");
      ds.field("diameter", &self.diameter());
      ds.finish()
  }
}
pub enum CylinderShapeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CylinderShape<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CylinderShape<'a> {
  type Inner = CylinderShape<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CylinderShape<'a> {
  pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CylinderShape { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CylinderShapeArgs
  ) -> flatbuffers::WIPOffset<CylinderShape<'bldr>> {
    let mut builder = CylinderShapeBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_diameter(args.diameter);
    builder.finish()
  }


  #[inline]
  pub fn diameter(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CylinderShape::VT_DIAMETER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(CylinderShape::VT_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for CylinderShape<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("diameter", Self::VT_DIAMETER, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct CylinderShapeArgs {
    pub diameter: f32,
    pub height: f32,
}
impl<'a> Default for CylinderShapeArgs {
  #[inline]
  fn default() -> Self {
    CylinderShapeArgs {
      diameter: 0.0,
      height: 0.0,
    }
  }
}

pub struct CylinderShapeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CylinderShapeBuilder<'a, 'b> {
  #[inline]
  pub fn add_diameter(&mut self, diameter: f32) {
    self.fbb_.push_slot::<f32>(CylinderShape::VT_DIAMETER, diameter, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(CylinderShape::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CylinderShapeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CylinderShapeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CylinderShape<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CylinderShape<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CylinderShape");
      ds.field("diameter", &self.diameter());
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum TouchOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Touch<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Touch<'a> {
  type Inner = Touch<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Touch<'a> {
  pub const VT_PLAYERNAME: flatbuffers::VOffsetT = 4;
  pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 8;
  pub const VT_NORMAL: flatbuffers::VOffsetT = 10;
  pub const VT_TEAM: flatbuffers::VOffsetT = 12;
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Touch { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TouchArgs<'args>
  ) -> flatbuffers::WIPOffset<Touch<'bldr>> {
    let mut builder = TouchBuilder::new(_fbb);
    builder.add_playerIndex(args.playerIndex);
    builder.add_team(args.team);
    if let Some(x) = args.normal { builder.add_normal(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_gameSeconds(args.gameSeconds);
    if let Some(x) = args.playerName { builder.add_playerName(x); }
    builder.finish()
  }


  /// The name of the player involved with the touch.
  #[inline]
  pub fn playerName(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Touch::VT_PLAYERNAME, None)}
  }
  /// Seconds that had elapsed in the game when the touch occurred.
  #[inline]
  pub fn gameSeconds(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Touch::VT_GAMESECONDS, Some(0.0)).unwrap()}
  }
  /// The point of contact for the touch.
  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(Touch::VT_LOCATION, None)}
  }
  /// The direction of the touch.
  #[inline]
  pub fn normal(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(Touch::VT_NORMAL, None)}
  }
  /// The Team which the touch belongs to, 0 for blue 1 for orange.
  #[inline]
  pub fn team(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Touch::VT_TEAM, Some(0)).unwrap()}
  }
  /// The index of the player involved with the touch.
  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Touch::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Touch<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("playerName", Self::VT_PLAYERNAME, false)?
     .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Vector3>("normal", Self::VT_NORMAL, false)?
     .visit_field::<i32>("team", Self::VT_TEAM, false)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct TouchArgs<'a> {
    pub playerName: Option<flatbuffers::WIPOffset<&'a str>>,
    pub gameSeconds: f32,
    pub location: Option<&'a Vector3>,
    pub normal: Option<&'a Vector3>,
    pub team: i32,
    pub playerIndex: i32,
}
impl<'a> Default for TouchArgs<'a> {
  #[inline]
  fn default() -> Self {
    TouchArgs {
      playerName: None,
      gameSeconds: 0.0,
      location: None,
      normal: None,
      team: 0,
      playerIndex: 0,
    }
  }
}

pub struct TouchBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TouchBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerName(&mut self, playerName: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Touch::VT_PLAYERNAME, playerName);
  }
  #[inline]
  pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
    self.fbb_.push_slot::<f32>(Touch::VT_GAMESECONDS, gameSeconds, 0.0);
  }
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(Touch::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_normal(&mut self, normal: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(Touch::VT_NORMAL, normal);
  }
  #[inline]
  pub fn add_team(&mut self, team: i32) {
    self.fbb_.push_slot::<i32>(Touch::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(Touch::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TouchBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TouchBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Touch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Touch<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Touch");
      ds.field("playerName", &self.playerName());
      ds.field("gameSeconds", &self.gameSeconds());
      ds.field("location", &self.location());
      ds.field("normal", &self.normal());
      ds.field("team", &self.team());
      ds.field("playerIndex", &self.playerIndex());
      ds.finish()
  }
}
pub enum ScoreInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScoreInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScoreInfo<'a> {
  type Inner = ScoreInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ScoreInfo<'a> {
  pub const VT_SCORE: flatbuffers::VOffsetT = 4;
  pub const VT_GOALS: flatbuffers::VOffsetT = 6;
  pub const VT_OWNGOALS: flatbuffers::VOffsetT = 8;
  pub const VT_ASSISTS: flatbuffers::VOffsetT = 10;
  pub const VT_SAVES: flatbuffers::VOffsetT = 12;
  pub const VT_SHOTS: flatbuffers::VOffsetT = 14;
  pub const VT_DEMOLITIONS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScoreInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ScoreInfoArgs
  ) -> flatbuffers::WIPOffset<ScoreInfo<'bldr>> {
    let mut builder = ScoreInfoBuilder::new(_fbb);
    builder.add_demolitions(args.demolitions);
    builder.add_shots(args.shots);
    builder.add_saves(args.saves);
    builder.add_assists(args.assists);
    builder.add_ownGoals(args.ownGoals);
    builder.add_goals(args.goals);
    builder.add_score(args.score);
    builder.finish()
  }


  #[inline]
  pub fn score(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_SCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn goals(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_GOALS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ownGoals(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_OWNGOALS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn assists(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_ASSISTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn saves(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_SAVES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn shots(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_SHOTS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn demolitions(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ScoreInfo::VT_DEMOLITIONS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ScoreInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("score", Self::VT_SCORE, false)?
     .visit_field::<i32>("goals", Self::VT_GOALS, false)?
     .visit_field::<i32>("ownGoals", Self::VT_OWNGOALS, false)?
     .visit_field::<i32>("assists", Self::VT_ASSISTS, false)?
     .visit_field::<i32>("saves", Self::VT_SAVES, false)?
     .visit_field::<i32>("shots", Self::VT_SHOTS, false)?
     .visit_field::<i32>("demolitions", Self::VT_DEMOLITIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct ScoreInfoArgs {
    pub score: i32,
    pub goals: i32,
    pub ownGoals: i32,
    pub assists: i32,
    pub saves: i32,
    pub shots: i32,
    pub demolitions: i32,
}
impl<'a> Default for ScoreInfoArgs {
  #[inline]
  fn default() -> Self {
    ScoreInfoArgs {
      score: 0,
      goals: 0,
      ownGoals: 0,
      assists: 0,
      saves: 0,
      shots: 0,
      demolitions: 0,
    }
  }
}

pub struct ScoreInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScoreInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_score(&mut self, score: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_goals(&mut self, goals: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_GOALS, goals, 0);
  }
  #[inline]
  pub fn add_ownGoals(&mut self, ownGoals: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_OWNGOALS, ownGoals, 0);
  }
  #[inline]
  pub fn add_assists(&mut self, assists: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_ASSISTS, assists, 0);
  }
  #[inline]
  pub fn add_saves(&mut self, saves: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_SAVES, saves, 0);
  }
  #[inline]
  pub fn add_shots(&mut self, shots: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_SHOTS, shots, 0);
  }
  #[inline]
  pub fn add_demolitions(&mut self, demolitions: i32) {
    self.fbb_.push_slot::<i32>(ScoreInfo::VT_DEMOLITIONS, demolitions, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScoreInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScoreInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScoreInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScoreInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScoreInfo");
      ds.field("score", &self.score());
      ds.field("goals", &self.goals());
      ds.field("ownGoals", &self.ownGoals());
      ds.field("assists", &self.assists());
      ds.field("saves", &self.saves());
      ds.field("shots", &self.shots());
      ds.field("demolitions", &self.demolitions());
      ds.finish()
  }
}
pub enum PhysicsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Physics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Physics<'a> {
  type Inner = Physics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Physics<'a> {
  pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
  pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
  pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Physics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PhysicsArgs<'args>
  ) -> flatbuffers::WIPOffset<Physics<'bldr>> {
    let mut builder = PhysicsBuilder::new(_fbb);
    if let Some(x) = args.angularVelocity { builder.add_angularVelocity(x); }
    if let Some(x) = args.velocity { builder.add_velocity(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(Physics::VT_LOCATION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<&'a Rotator> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rotator>(Physics::VT_ROTATION, None)}
  }
  #[inline]
  pub fn velocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(Physics::VT_VELOCITY, None)}
  }
  #[inline]
  pub fn angularVelocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(Physics::VT_ANGULARVELOCITY, None)}
  }
}

impl flatbuffers::Verifiable for Physics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Rotator>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
     .visit_field::<Vector3>("angularVelocity", Self::VT_ANGULARVELOCITY, false)?
     .finish();
    Ok(())
  }
}
pub struct PhysicsArgs<'a> {
    pub location: Option<&'a Vector3>,
    pub rotation: Option<&'a Rotator>,
    pub velocity: Option<&'a Vector3>,
    pub angularVelocity: Option<&'a Vector3>,
}
impl<'a> Default for PhysicsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PhysicsArgs {
      location: None,
      rotation: None,
      velocity: None,
      angularVelocity: None,
    }
  }
}

pub struct PhysicsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PhysicsBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(Physics::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: &Rotator) {
    self.fbb_.push_slot_always::<&Rotator>(Physics::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_velocity(&mut self, velocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(Physics::VT_VELOCITY, velocity);
  }
  #[inline]
  pub fn add_angularVelocity(&mut self, angularVelocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(Physics::VT_ANGULARVELOCITY, angularVelocity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PhysicsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PhysicsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Physics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Physics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Physics");
      ds.field("location", &self.location());
      ds.field("rotation", &self.rotation());
      ds.field("velocity", &self.velocity());
      ds.field("angularVelocity", &self.angularVelocity());
      ds.finish()
  }
}
pub enum PlayerInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayerInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerInfo<'a> {
  type Inner = PlayerInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerInfo<'a> {
  pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
  pub const VT_SCOREINFO: flatbuffers::VOffsetT = 6;
  pub const VT_ISDEMOLISHED: flatbuffers::VOffsetT = 8;
  pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
  pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
  pub const VT_ISBOT: flatbuffers::VOffsetT = 14;
  pub const VT_JUMPED: flatbuffers::VOffsetT = 16;
  pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 18;
  pub const VT_NAME: flatbuffers::VOffsetT = 20;
  pub const VT_TEAM: flatbuffers::VOffsetT = 22;
  pub const VT_BOOST: flatbuffers::VOffsetT = 24;
  pub const VT_HITBOX: flatbuffers::VOffsetT = 26;
  pub const VT_HITBOXOFFSET: flatbuffers::VOffsetT = 28;
  pub const VT_SPAWNID: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerInfo<'bldr>> {
    let mut builder = PlayerInfoBuilder::new(_fbb);
    builder.add_spawnId(args.spawnId);
    if let Some(x) = args.hitboxOffset { builder.add_hitboxOffset(x); }
    if let Some(x) = args.hitbox { builder.add_hitbox(x); }
    builder.add_boost(args.boost);
    builder.add_team(args.team);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.scoreInfo { builder.add_scoreInfo(x); }
    if let Some(x) = args.physics { builder.add_physics(x); }
    builder.add_doubleJumped(args.doubleJumped);
    builder.add_jumped(args.jumped);
    builder.add_isBot(args.isBot);
    builder.add_isSupersonic(args.isSupersonic);
    builder.add_hasWheelContact(args.hasWheelContact);
    builder.add_isDemolished(args.isDemolished);
    builder.finish()
  }


  #[inline]
  pub fn physics(&self) -> Option<Physics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Physics>>(PlayerInfo::VT_PHYSICS, None)}
  }
  #[inline]
  pub fn scoreInfo(&self) -> Option<ScoreInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ScoreInfo>>(PlayerInfo::VT_SCOREINFO, None)}
  }
  #[inline]
  pub fn isDemolished(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_ISDEMOLISHED, Some(false)).unwrap()}
  }
  /// True if your wheels are on the ground, the wall, or the ceiling. False if you're midair or turtling.
  #[inline]
  pub fn hasWheelContact(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_HASWHEELCONTACT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isSupersonic(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_ISSUPERSONIC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isBot(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_ISBOT, Some(false)).unwrap()}
  }
  /// True if the player has jumped. Falling off the ceiling / driving off the goal post does not count.
  #[inline]
  pub fn jumped(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_JUMPED, Some(false)).unwrap()}
  }
  ///  True if player has double jumped. False does not mean you have a jump remaining, because the
  ///  aerial timer can run out, and that doesn't affect this flag.
  #[inline]
  pub fn doubleJumped(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PlayerInfo::VT_DOUBLEJUMPED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlayerInfo::VT_NAME, None)}
  }
  #[inline]
  pub fn team(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerInfo::VT_TEAM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn boost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerInfo::VT_BOOST, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hitbox(&self) -> Option<BoxShape<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BoxShape>>(PlayerInfo::VT_HITBOX, None)}
  }
  #[inline]
  pub fn hitboxOffset(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(PlayerInfo::VT_HITBOXOFFSET, None)}
  }
  /// In the case where the requested player index is not available, spawnId will help
  /// the framework figure out what index was actually assigned to this player instead.
  #[inline]
  pub fn spawnId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerInfo::VT_SPAWNID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PlayerInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Physics>>("physics", Self::VT_PHYSICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ScoreInfo>>("scoreInfo", Self::VT_SCOREINFO, false)?
     .visit_field::<bool>("isDemolished", Self::VT_ISDEMOLISHED, false)?
     .visit_field::<bool>("hasWheelContact", Self::VT_HASWHEELCONTACT, false)?
     .visit_field::<bool>("isSupersonic", Self::VT_ISSUPERSONIC, false)?
     .visit_field::<bool>("isBot", Self::VT_ISBOT, false)?
     .visit_field::<bool>("jumped", Self::VT_JUMPED, false)?
     .visit_field::<bool>("doubleJumped", Self::VT_DOUBLEJUMPED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("team", Self::VT_TEAM, false)?
     .visit_field::<i32>("boost", Self::VT_BOOST, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BoxShape>>("hitbox", Self::VT_HITBOX, false)?
     .visit_field::<Vector3>("hitboxOffset", Self::VT_HITBOXOFFSET, false)?
     .visit_field::<i32>("spawnId", Self::VT_SPAWNID, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerInfoArgs<'a> {
    pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
    pub scoreInfo: Option<flatbuffers::WIPOffset<ScoreInfo<'a>>>,
    pub isDemolished: bool,
    pub hasWheelContact: bool,
    pub isSupersonic: bool,
    pub isBot: bool,
    pub jumped: bool,
    pub doubleJumped: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub team: i32,
    pub boost: i32,
    pub hitbox: Option<flatbuffers::WIPOffset<BoxShape<'a>>>,
    pub hitboxOffset: Option<&'a Vector3>,
    pub spawnId: i32,
}
impl<'a> Default for PlayerInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerInfoArgs {
      physics: None,
      scoreInfo: None,
      isDemolished: false,
      hasWheelContact: false,
      isSupersonic: false,
      isBot: false,
      jumped: false,
      doubleJumped: false,
      name: None,
      team: 0,
      boost: 0,
      hitbox: None,
      hitboxOffset: None,
      spawnId: 0,
    }
  }
}

pub struct PlayerInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Physics>>(PlayerInfo::VT_PHYSICS, physics);
  }
  #[inline]
  pub fn add_scoreInfo(&mut self, scoreInfo: flatbuffers::WIPOffset<ScoreInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ScoreInfo>>(PlayerInfo::VT_SCOREINFO, scoreInfo);
  }
  #[inline]
  pub fn add_isDemolished(&mut self, isDemolished: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_ISDEMOLISHED, isDemolished, false);
  }
  #[inline]
  pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_HASWHEELCONTACT, hasWheelContact, false);
  }
  #[inline]
  pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_ISSUPERSONIC, isSupersonic, false);
  }
  #[inline]
  pub fn add_isBot(&mut self, isBot: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_ISBOT, isBot, false);
  }
  #[inline]
  pub fn add_jumped(&mut self, jumped: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_JUMPED, jumped, false);
  }
  #[inline]
  pub fn add_doubleJumped(&mut self, doubleJumped: bool) {
    self.fbb_.push_slot::<bool>(PlayerInfo::VT_DOUBLEJUMPED, doubleJumped, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerInfo::VT_NAME, name);
  }
  #[inline]
  pub fn add_team(&mut self, team: i32) {
    self.fbb_.push_slot::<i32>(PlayerInfo::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_boost(&mut self, boost: i32) {
    self.fbb_.push_slot::<i32>(PlayerInfo::VT_BOOST, boost, 0);
  }
  #[inline]
  pub fn add_hitbox(&mut self, hitbox: flatbuffers::WIPOffset<BoxShape<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BoxShape>>(PlayerInfo::VT_HITBOX, hitbox);
  }
  #[inline]
  pub fn add_hitboxOffset(&mut self, hitboxOffset: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(PlayerInfo::VT_HITBOXOFFSET, hitboxOffset);
  }
  #[inline]
  pub fn add_spawnId(&mut self, spawnId: i32) {
    self.fbb_.push_slot::<i32>(PlayerInfo::VT_SPAWNID, spawnId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerInfo");
      ds.field("physics", &self.physics());
      ds.field("scoreInfo", &self.scoreInfo());
      ds.field("isDemolished", &self.isDemolished());
      ds.field("hasWheelContact", &self.hasWheelContact());
      ds.field("isSupersonic", &self.isSupersonic());
      ds.field("isBot", &self.isBot());
      ds.field("jumped", &self.jumped());
      ds.field("doubleJumped", &self.doubleJumped());
      ds.field("name", &self.name());
      ds.field("team", &self.team());
      ds.field("boost", &self.boost());
      ds.field("hitbox", &self.hitbox());
      ds.field("hitboxOffset", &self.hitboxOffset());
      ds.field("spawnId", &self.spawnId());
      ds.finish()
  }
}
pub enum DropShotBallInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DropShotBallInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DropShotBallInfo<'a> {
  type Inner = DropShotBallInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DropShotBallInfo<'a> {
  pub const VT_ABSORBEDFORCE: flatbuffers::VOffsetT = 4;
  pub const VT_DAMAGEINDEX: flatbuffers::VOffsetT = 6;
  pub const VT_FORCEACCUMRECENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DropShotBallInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DropShotBallInfoArgs
  ) -> flatbuffers::WIPOffset<DropShotBallInfo<'bldr>> {
    let mut builder = DropShotBallInfoBuilder::new(_fbb);
    builder.add_forceAccumRecent(args.forceAccumRecent);
    builder.add_damageIndex(args.damageIndex);
    builder.add_absorbedForce(args.absorbedForce);
    builder.finish()
  }


  #[inline]
  pub fn absorbedForce(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn damageIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn forceAccumRecent(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DropShotBallInfo::VT_FORCEACCUMRECENT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DropShotBallInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("absorbedForce", Self::VT_ABSORBEDFORCE, false)?
     .visit_field::<i32>("damageIndex", Self::VT_DAMAGEINDEX, false)?
     .visit_field::<f32>("forceAccumRecent", Self::VT_FORCEACCUMRECENT, false)?
     .finish();
    Ok(())
  }
}
pub struct DropShotBallInfoArgs {
    pub absorbedForce: f32,
    pub damageIndex: i32,
    pub forceAccumRecent: f32,
}
impl<'a> Default for DropShotBallInfoArgs {
  #[inline]
  fn default() -> Self {
    DropShotBallInfoArgs {
      absorbedForce: 0.0,
      damageIndex: 0,
      forceAccumRecent: 0.0,
    }
  }
}

pub struct DropShotBallInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DropShotBallInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_absorbedForce(&mut self, absorbedForce: f32) {
    self.fbb_.push_slot::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, absorbedForce, 0.0);
  }
  #[inline]
  pub fn add_damageIndex(&mut self, damageIndex: i32) {
    self.fbb_.push_slot::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, damageIndex, 0);
  }
  #[inline]
  pub fn add_forceAccumRecent(&mut self, forceAccumRecent: f32) {
    self.fbb_.push_slot::<f32>(DropShotBallInfo::VT_FORCEACCUMRECENT, forceAccumRecent, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DropShotBallInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DropShotBallInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DropShotBallInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DropShotBallInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DropShotBallInfo");
      ds.field("absorbedForce", &self.absorbedForce());
      ds.field("damageIndex", &self.damageIndex());
      ds.field("forceAccumRecent", &self.forceAccumRecent());
      ds.finish()
  }
}
pub enum BallInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BallInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BallInfo<'a> {
  type Inner = BallInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BallInfo<'a> {
  pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
  pub const VT_LATESTTOUCH: flatbuffers::VOffsetT = 6;
  pub const VT_DROPSHOTINFO: flatbuffers::VOffsetT = 8;
  pub const VT_SHAPE_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_SHAPE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BallInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BallInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<BallInfo<'bldr>> {
    let mut builder = BallInfoBuilder::new(_fbb);
    if let Some(x) = args.shape { builder.add_shape(x); }
    if let Some(x) = args.dropShotInfo { builder.add_dropShotInfo(x); }
    if let Some(x) = args.latestTouch { builder.add_latestTouch(x); }
    if let Some(x) = args.physics { builder.add_physics(x); }
    builder.add_shape_type(args.shape_type);
    builder.finish()
  }


  #[inline]
  pub fn physics(&self) -> Option<Physics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Physics>>(BallInfo::VT_PHYSICS, None)}
  }
  #[inline]
  pub fn latestTouch(&self) -> Option<Touch<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Touch>>(BallInfo::VT_LATESTTOUCH, None)}
  }
  #[inline]
  pub fn dropShotInfo(&self) -> Option<DropShotBallInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DropShotBallInfo>>(BallInfo::VT_DROPSHOTINFO, None)}
  }
  #[inline]
  pub fn shape_type(&self) -> CollisionShape {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<CollisionShape>(BallInfo::VT_SHAPE_TYPE, Some(CollisionShape::NONE)).unwrap()}
  }
  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(BallInfo::VT_SHAPE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn shape_as_box_shape(&self) -> Option<BoxShape<'a>> {
    if self.shape_type() == CollisionShape::BoxShape {
      self.shape().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { BoxShape::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn shape_as_sphere_shape(&self) -> Option<SphereShape<'a>> {
    if self.shape_type() == CollisionShape::SphereShape {
      self.shape().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SphereShape::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn shape_as_cylinder_shape(&self) -> Option<CylinderShape<'a>> {
    if self.shape_type() == CollisionShape::CylinderShape {
      self.shape().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CylinderShape::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for BallInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Physics>>("physics", Self::VT_PHYSICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Touch>>("latestTouch", Self::VT_LATESTTOUCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DropShotBallInfo>>("dropShotInfo", Self::VT_DROPSHOTINFO, false)?
     .visit_union::<CollisionShape, _>("shape_type", Self::VT_SHAPE_TYPE, "shape", Self::VT_SHAPE, false, |key, v, pos| {
        match key {
          CollisionShape::BoxShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoxShape>>("CollisionShape::BoxShape", pos),
          CollisionShape::SphereShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SphereShape>>("CollisionShape::SphereShape", pos),
          CollisionShape::CylinderShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CylinderShape>>("CollisionShape::CylinderShape", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct BallInfoArgs<'a> {
    pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
    pub latestTouch: Option<flatbuffers::WIPOffset<Touch<'a>>>,
    pub dropShotInfo: Option<flatbuffers::WIPOffset<DropShotBallInfo<'a>>>,
    pub shape_type: CollisionShape,
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BallInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    BallInfoArgs {
      physics: None,
      latestTouch: None,
      dropShotInfo: None,
      shape_type: CollisionShape::NONE,
      shape: None,
    }
  }
}

pub struct BallInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BallInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Physics>>(BallInfo::VT_PHYSICS, physics);
  }
  #[inline]
  pub fn add_latestTouch(&mut self, latestTouch: flatbuffers::WIPOffset<Touch<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Touch>>(BallInfo::VT_LATESTTOUCH, latestTouch);
  }
  #[inline]
  pub fn add_dropShotInfo(&mut self, dropShotInfo: flatbuffers::WIPOffset<DropShotBallInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DropShotBallInfo>>(BallInfo::VT_DROPSHOTINFO, dropShotInfo);
  }
  #[inline]
  pub fn add_shape_type(&mut self, shape_type: CollisionShape) {
    self.fbb_.push_slot::<CollisionShape>(BallInfo::VT_SHAPE_TYPE, shape_type, CollisionShape::NONE);
  }
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BallInfo::VT_SHAPE, shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BallInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BallInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BallInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BallInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BallInfo");
      ds.field("physics", &self.physics());
      ds.field("latestTouch", &self.latestTouch());
      ds.field("dropShotInfo", &self.dropShotInfo());
      ds.field("shape_type", &self.shape_type());
      match self.shape_type() {
        CollisionShape::BoxShape => {
          if let Some(x) = self.shape_as_box_shape() {
            ds.field("shape", &x)
          } else {
            ds.field("shape", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        CollisionShape::SphereShape => {
          if let Some(x) = self.shape_as_sphere_shape() {
            ds.field("shape", &x)
          } else {
            ds.field("shape", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        CollisionShape::CylinderShape => {
          if let Some(x) = self.shape_as_cylinder_shape() {
            ds.field("shape", &x)
          } else {
            ds.field("shape", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("shape", &x)
        },
      };
      ds.finish()
  }
}
pub enum BoostPadStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoostPadState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoostPadState<'a> {
  type Inner = BoostPadState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoostPadState<'a> {
  pub const VT_ISACTIVE: flatbuffers::VOffsetT = 4;
  pub const VT_TIMER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoostPadState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoostPadStateArgs
  ) -> flatbuffers::WIPOffset<BoostPadState<'bldr>> {
    let mut builder = BoostPadStateBuilder::new(_fbb);
    builder.add_timer(args.timer);
    builder.add_isActive(args.isActive);
    builder.finish()
  }


  /// True if the boost can be picked up
  #[inline]
  pub fn isActive(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BoostPadState::VT_ISACTIVE, Some(false)).unwrap()}
  }
  /// The number of seconds since the boost has been picked up, or 0.0 if the boost is active.
  #[inline]
  pub fn timer(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BoostPadState::VT_TIMER, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoostPadState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("isActive", Self::VT_ISACTIVE, false)?
     .visit_field::<f32>("timer", Self::VT_TIMER, false)?
     .finish();
    Ok(())
  }
}
pub struct BoostPadStateArgs {
    pub isActive: bool,
    pub timer: f32,
}
impl<'a> Default for BoostPadStateArgs {
  #[inline]
  fn default() -> Self {
    BoostPadStateArgs {
      isActive: false,
      timer: 0.0,
    }
  }
}

pub struct BoostPadStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoostPadStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_isActive(&mut self, isActive: bool) {
    self.fbb_.push_slot::<bool>(BoostPadState::VT_ISACTIVE, isActive, false);
  }
  #[inline]
  pub fn add_timer(&mut self, timer: f32) {
    self.fbb_.push_slot::<f32>(BoostPadState::VT_TIMER, timer, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoostPadStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoostPadStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoostPadState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoostPadState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoostPadState");
      ds.field("isActive", &self.isActive());
      ds.field("timer", &self.timer());
      ds.finish()
  }
}
pub enum DropshotTileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DropshotTile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DropshotTile<'a> {
  type Inner = DropshotTile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DropshotTile<'a> {
  pub const VT_TILESTATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DropshotTile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DropshotTileArgs
  ) -> flatbuffers::WIPOffset<DropshotTile<'bldr>> {
    let mut builder = DropshotTileBuilder::new(_fbb);
    builder.add_tileState(args.tileState);
    builder.finish()
  }


  /// The amount of damage the tile has sustained.
  #[inline]
  pub fn tileState(&self) -> TileState {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TileState>(DropshotTile::VT_TILESTATE, Some(TileState::Unknown)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DropshotTile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TileState>("tileState", Self::VT_TILESTATE, false)?
     .finish();
    Ok(())
  }
}
pub struct DropshotTileArgs {
    pub tileState: TileState,
}
impl<'a> Default for DropshotTileArgs {
  #[inline]
  fn default() -> Self {
    DropshotTileArgs {
      tileState: TileState::Unknown,
    }
  }
}

pub struct DropshotTileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DropshotTileBuilder<'a, 'b> {
  #[inline]
  pub fn add_tileState(&mut self, tileState: TileState) {
    self.fbb_.push_slot::<TileState>(DropshotTile::VT_TILESTATE, tileState, TileState::Unknown);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DropshotTileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DropshotTileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DropshotTile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DropshotTile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DropshotTile");
      ds.field("tileState", &self.tileState());
      ds.finish()
  }
}
pub enum GameInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GameInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameInfo<'a> {
  type Inner = GameInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GameInfo<'a> {
  pub const VT_SECONDSELAPSED: flatbuffers::VOffsetT = 4;
  pub const VT_GAMETIMEREMAINING: flatbuffers::VOffsetT = 6;
  pub const VT_ISOVERTIME: flatbuffers::VOffsetT = 8;
  pub const VT_ISUNLIMITEDTIME: flatbuffers::VOffsetT = 10;
  pub const VT_ISROUNDACTIVE: flatbuffers::VOffsetT = 12;
  pub const VT_ISKICKOFFPAUSE: flatbuffers::VOffsetT = 14;
  pub const VT_ISMATCHENDED: flatbuffers::VOffsetT = 16;
  pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 18;
  pub const VT_GAMESPEED: flatbuffers::VOffsetT = 20;
  pub const VT_FRAMENUM: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GameInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GameInfoArgs
  ) -> flatbuffers::WIPOffset<GameInfo<'bldr>> {
    let mut builder = GameInfoBuilder::new(_fbb);
    builder.add_frameNum(args.frameNum);
    builder.add_gameSpeed(args.gameSpeed);
    builder.add_worldGravityZ(args.worldGravityZ);
    builder.add_gameTimeRemaining(args.gameTimeRemaining);
    builder.add_secondsElapsed(args.secondsElapsed);
    builder.add_isMatchEnded(args.isMatchEnded);
    builder.add_isKickoffPause(args.isKickoffPause);
    builder.add_isRoundActive(args.isRoundActive);
    builder.add_isUnlimitedTime(args.isUnlimitedTime);
    builder.add_isOvertime(args.isOvertime);
    builder.finish()
  }


  #[inline]
  pub fn secondsElapsed(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GameInfo::VT_SECONDSELAPSED, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gameTimeRemaining(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GameInfo::VT_GAMETIMEREMAINING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn isOvertime(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GameInfo::VT_ISOVERTIME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isUnlimitedTime(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GameInfo::VT_ISUNLIMITEDTIME, Some(false)).unwrap()}
  }
  /// True when cars are allowed to move, and during the pause menu. False during replays.
  #[inline]
  pub fn isRoundActive(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GameInfo::VT_ISROUNDACTIVE, Some(false)).unwrap()}
  }
  /// True when the clock is paused due to kickoff, but false during kickoff countdown. In other words, it is true
  /// while cars can move during kickoff. Note that if both players sit still, game clock start and this will become false.
  #[inline]
  pub fn isKickoffPause(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GameInfo::VT_ISKICKOFFPAUSE, Some(false)).unwrap()}
  }
  /// Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
  /// countdown. Turns false again the moment the 'choose team' screen appears.
  #[inline]
  pub fn isMatchEnded(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GameInfo::VT_ISMATCHENDED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn worldGravityZ(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GameInfo::VT_WORLDGRAVITYZ, Some(0.0)).unwrap()}
  }
  /// Game speed multiplier, 1.0 is regular game speed.
  #[inline]
  pub fn gameSpeed(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GameInfo::VT_GAMESPEED, Some(0.0)).unwrap()}
  }
  /// Tracks the number of physics frames the game has computed.
  /// May increase by more than one across consecutive packets.
  /// Data type will roll over after 207 days at 120Hz.
  #[inline]
  pub fn frameNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GameInfo::VT_FRAMENUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GameInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("secondsElapsed", Self::VT_SECONDSELAPSED, false)?
     .visit_field::<f32>("gameTimeRemaining", Self::VT_GAMETIMEREMAINING, false)?
     .visit_field::<bool>("isOvertime", Self::VT_ISOVERTIME, false)?
     .visit_field::<bool>("isUnlimitedTime", Self::VT_ISUNLIMITEDTIME, false)?
     .visit_field::<bool>("isRoundActive", Self::VT_ISROUNDACTIVE, false)?
     .visit_field::<bool>("isKickoffPause", Self::VT_ISKICKOFFPAUSE, false)?
     .visit_field::<bool>("isMatchEnded", Self::VT_ISMATCHENDED, false)?
     .visit_field::<f32>("worldGravityZ", Self::VT_WORLDGRAVITYZ, false)?
     .visit_field::<f32>("gameSpeed", Self::VT_GAMESPEED, false)?
     .visit_field::<i32>("frameNum", Self::VT_FRAMENUM, false)?
     .finish();
    Ok(())
  }
}
pub struct GameInfoArgs {
    pub secondsElapsed: f32,
    pub gameTimeRemaining: f32,
    pub isOvertime: bool,
    pub isUnlimitedTime: bool,
    pub isRoundActive: bool,
    pub isKickoffPause: bool,
    pub isMatchEnded: bool,
    pub worldGravityZ: f32,
    pub gameSpeed: f32,
    pub frameNum: i32,
}
impl<'a> Default for GameInfoArgs {
  #[inline]
  fn default() -> Self {
    GameInfoArgs {
      secondsElapsed: 0.0,
      gameTimeRemaining: 0.0,
      isOvertime: false,
      isUnlimitedTime: false,
      isRoundActive: false,
      isKickoffPause: false,
      isMatchEnded: false,
      worldGravityZ: 0.0,
      gameSpeed: 0.0,
      frameNum: 0,
    }
  }
}

pub struct GameInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_secondsElapsed(&mut self, secondsElapsed: f32) {
    self.fbb_.push_slot::<f32>(GameInfo::VT_SECONDSELAPSED, secondsElapsed, 0.0);
  }
  #[inline]
  pub fn add_gameTimeRemaining(&mut self, gameTimeRemaining: f32) {
    self.fbb_.push_slot::<f32>(GameInfo::VT_GAMETIMEREMAINING, gameTimeRemaining, 0.0);
  }
  #[inline]
  pub fn add_isOvertime(&mut self, isOvertime: bool) {
    self.fbb_.push_slot::<bool>(GameInfo::VT_ISOVERTIME, isOvertime, false);
  }
  #[inline]
  pub fn add_isUnlimitedTime(&mut self, isUnlimitedTime: bool) {
    self.fbb_.push_slot::<bool>(GameInfo::VT_ISUNLIMITEDTIME, isUnlimitedTime, false);
  }
  #[inline]
  pub fn add_isRoundActive(&mut self, isRoundActive: bool) {
    self.fbb_.push_slot::<bool>(GameInfo::VT_ISROUNDACTIVE, isRoundActive, false);
  }
  #[inline]
  pub fn add_isKickoffPause(&mut self, isKickoffPause: bool) {
    self.fbb_.push_slot::<bool>(GameInfo::VT_ISKICKOFFPAUSE, isKickoffPause, false);
  }
  #[inline]
  pub fn add_isMatchEnded(&mut self, isMatchEnded: bool) {
    self.fbb_.push_slot::<bool>(GameInfo::VT_ISMATCHENDED, isMatchEnded, false);
  }
  #[inline]
  pub fn add_worldGravityZ(&mut self, worldGravityZ: f32) {
    self.fbb_.push_slot::<f32>(GameInfo::VT_WORLDGRAVITYZ, worldGravityZ, 0.0);
  }
  #[inline]
  pub fn add_gameSpeed(&mut self, gameSpeed: f32) {
    self.fbb_.push_slot::<f32>(GameInfo::VT_GAMESPEED, gameSpeed, 0.0);
  }
  #[inline]
  pub fn add_frameNum(&mut self, frameNum: i32) {
    self.fbb_.push_slot::<i32>(GameInfo::VT_FRAMENUM, frameNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GameInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GameInfo");
      ds.field("secondsElapsed", &self.secondsElapsed());
      ds.field("gameTimeRemaining", &self.gameTimeRemaining());
      ds.field("isOvertime", &self.isOvertime());
      ds.field("isUnlimitedTime", &self.isUnlimitedTime());
      ds.field("isRoundActive", &self.isRoundActive());
      ds.field("isKickoffPause", &self.isKickoffPause());
      ds.field("isMatchEnded", &self.isMatchEnded());
      ds.field("worldGravityZ", &self.worldGravityZ());
      ds.field("gameSpeed", &self.gameSpeed());
      ds.field("frameNum", &self.frameNum());
      ds.finish()
  }
}
pub enum TeamInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TeamInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TeamInfo<'a> {
  type Inner = TeamInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TeamInfo<'a> {
  pub const VT_TEAMINDEX: flatbuffers::VOffsetT = 4;
  pub const VT_SCORE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TeamInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TeamInfoArgs
  ) -> flatbuffers::WIPOffset<TeamInfo<'bldr>> {
    let mut builder = TeamInfoBuilder::new(_fbb);
    builder.add_score(args.score);
    builder.add_teamIndex(args.teamIndex);
    builder.finish()
  }


  #[inline]
  pub fn teamIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TeamInfo::VT_TEAMINDEX, Some(0)).unwrap()}
  }
  /// number of goals scored.
  #[inline]
  pub fn score(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TeamInfo::VT_SCORE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TeamInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("teamIndex", Self::VT_TEAMINDEX, false)?
     .visit_field::<i32>("score", Self::VT_SCORE, false)?
     .finish();
    Ok(())
  }
}
pub struct TeamInfoArgs {
    pub teamIndex: i32,
    pub score: i32,
}
impl<'a> Default for TeamInfoArgs {
  #[inline]
  fn default() -> Self {
    TeamInfoArgs {
      teamIndex: 0,
      score: 0,
    }
  }
}

pub struct TeamInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TeamInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_teamIndex(&mut self, teamIndex: i32) {
    self.fbb_.push_slot::<i32>(TeamInfo::VT_TEAMINDEX, teamIndex, 0);
  }
  #[inline]
  pub fn add_score(&mut self, score: i32) {
    self.fbb_.push_slot::<i32>(TeamInfo::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TeamInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TeamInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TeamInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TeamInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TeamInfo");
      ds.field("teamIndex", &self.teamIndex());
      ds.field("score", &self.score());
      ds.finish()
  }
}
pub enum GameTickPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GameTickPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameTickPacket<'a> {
  type Inner = GameTickPacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GameTickPacket<'a> {
  pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
  pub const VT_BOOSTPADSTATES: flatbuffers::VOffsetT = 6;
  pub const VT_BALL: flatbuffers::VOffsetT = 8;
  pub const VT_GAMEINFO: flatbuffers::VOffsetT = 10;
  pub const VT_TILEINFORMATION: flatbuffers::VOffsetT = 12;
  pub const VT_TEAMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GameTickPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GameTickPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<GameTickPacket<'bldr>> {
    let mut builder = GameTickPacketBuilder::new(_fbb);
    if let Some(x) = args.teams { builder.add_teams(x); }
    if let Some(x) = args.tileInformation { builder.add_tileInformation(x); }
    if let Some(x) = args.gameInfo { builder.add_gameInfo(x); }
    if let Some(x) = args.ball { builder.add_ball(x); }
    if let Some(x) = args.boostPadStates { builder.add_boostPadStates(x); }
    if let Some(x) = args.players { builder.add_players(x); }
    builder.finish()
  }


  #[inline]
  pub fn players(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo>>>>(GameTickPacket::VT_PLAYERS, None)}
  }
  #[inline]
  pub fn boostPadStates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState>>>>(GameTickPacket::VT_BOOSTPADSTATES, None)}
  }
  #[inline]
  pub fn ball(&self) -> Option<BallInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BallInfo>>(GameTickPacket::VT_BALL, None)}
  }
  #[inline]
  pub fn gameInfo(&self) -> Option<GameInfo<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GameInfo>>(GameTickPacket::VT_GAMEINFO, None)}
  }
  #[inline]
  pub fn tileInformation(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile>>>>(GameTickPacket::VT_TILEINFORMATION, None)}
  }
  #[inline]
  pub fn teams(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo>>>>(GameTickPacket::VT_TEAMS, None)}
  }
}

impl flatbuffers::Verifiable for GameTickPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerInfo>>>>("players", Self::VT_PLAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPadState>>>>("boostPadStates", Self::VT_BOOSTPADSTATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BallInfo>>("ball", Self::VT_BALL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GameInfo>>("gameInfo", Self::VT_GAMEINFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DropshotTile>>>>("tileInformation", Self::VT_TILEINFORMATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TeamInfo>>>>("teams", Self::VT_TEAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct GameTickPacketArgs<'a> {
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>>>,
    pub boostPadStates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>>>,
    pub ball: Option<flatbuffers::WIPOffset<BallInfo<'a>>>,
    pub gameInfo: Option<flatbuffers::WIPOffset<GameInfo<'a>>>,
    pub tileInformation: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>>>,
    pub teams: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>>>,
}
impl<'a> Default for GameTickPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    GameTickPacketArgs {
      players: None,
      boostPadStates: None,
      ball: None,
      gameInfo: None,
      tileInformation: None,
      teams: None,
    }
  }
}

pub struct GameTickPacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameTickPacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PlayerInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_PLAYERS, players);
  }
  #[inline]
  pub fn add_boostPadStates(&mut self, boostPadStates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoostPadState<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_BOOSTPADSTATES, boostPadStates);
  }
  #[inline]
  pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BallInfo>>(GameTickPacket::VT_BALL, ball);
  }
  #[inline]
  pub fn add_gameInfo(&mut self, gameInfo: flatbuffers::WIPOffset<GameInfo<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GameInfo>>(GameTickPacket::VT_GAMEINFO, gameInfo);
  }
  #[inline]
  pub fn add_tileInformation(&mut self, tileInformation: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DropshotTile<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_TILEINFORMATION, tileInformation);
  }
  #[inline]
  pub fn add_teams(&mut self, teams: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TeamInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_TEAMS, teams);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameTickPacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameTickPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameTickPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GameTickPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GameTickPacket");
      ds.field("players", &self.players());
      ds.field("boostPadStates", &self.boostPadStates());
      ds.field("ball", &self.ball());
      ds.field("gameInfo", &self.gameInfo());
      ds.field("tileInformation", &self.tileInformation());
      ds.field("teams", &self.teams());
      ds.finish()
  }
}
pub enum RigidBodyStateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The state of a rigid body in Rocket League's physics engine.
/// This gets updated in time with the physics tick, not the rendering framerate.
/// The frame field will be incremented every time the physics engine ticks.
pub struct RigidBodyState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RigidBodyState<'a> {
  type Inner = RigidBodyState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RigidBodyState<'a> {
  pub const VT_FRAME: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 8;
  pub const VT_VELOCITY: flatbuffers::VOffsetT = 10;
  pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RigidBodyState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RigidBodyStateArgs<'args>
  ) -> flatbuffers::WIPOffset<RigidBodyState<'bldr>> {
    let mut builder = RigidBodyStateBuilder::new(_fbb);
    if let Some(x) = args.angularVelocity { builder.add_angularVelocity(x); }
    if let Some(x) = args.velocity { builder.add_velocity(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_frame(args.frame);
    builder.finish()
  }


  #[inline]
  pub fn frame(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RigidBodyState::VT_FRAME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(RigidBodyState::VT_LOCATION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<&'a Quaternion> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Quaternion>(RigidBodyState::VT_ROTATION, None)}
  }
  #[inline]
  pub fn velocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(RigidBodyState::VT_VELOCITY, None)}
  }
  #[inline]
  pub fn angularVelocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(RigidBodyState::VT_ANGULARVELOCITY, None)}
  }
}

impl flatbuffers::Verifiable for RigidBodyState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("frame", Self::VT_FRAME, false)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Quaternion>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
     .visit_field::<Vector3>("angularVelocity", Self::VT_ANGULARVELOCITY, false)?
     .finish();
    Ok(())
  }
}
pub struct RigidBodyStateArgs<'a> {
    pub frame: i32,
    pub location: Option<&'a Vector3>,
    pub rotation: Option<&'a Quaternion>,
    pub velocity: Option<&'a Vector3>,
    pub angularVelocity: Option<&'a Vector3>,
}
impl<'a> Default for RigidBodyStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RigidBodyStateArgs {
      frame: 0,
      location: None,
      rotation: None,
      velocity: None,
      angularVelocity: None,
    }
  }
}

pub struct RigidBodyStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RigidBodyStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_frame(&mut self, frame: i32) {
    self.fbb_.push_slot::<i32>(RigidBodyState::VT_FRAME, frame, 0);
  }
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(RigidBodyState::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: &Quaternion) {
    self.fbb_.push_slot_always::<&Quaternion>(RigidBodyState::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_velocity(&mut self, velocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(RigidBodyState::VT_VELOCITY, velocity);
  }
  #[inline]
  pub fn add_angularVelocity(&mut self, angularVelocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(RigidBodyState::VT_ANGULARVELOCITY, angularVelocity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RigidBodyStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RigidBodyStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RigidBodyState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RigidBodyState");
      ds.field("frame", &self.frame());
      ds.field("location", &self.location());
      ds.field("rotation", &self.rotation());
      ds.field("velocity", &self.velocity());
      ds.field("angularVelocity", &self.angularVelocity());
      ds.finish()
  }
}
pub enum PlayerRigidBodyStateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rigid body state for a player / car in the game. Includes the latest
/// controller input, which is otherwise difficult to correlate with consequences.
pub struct PlayerRigidBodyState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerRigidBodyState<'a> {
  type Inner = PlayerRigidBodyState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerRigidBodyState<'a> {
  pub const VT_STATE: flatbuffers::VOffsetT = 4;
  pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerRigidBodyState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerRigidBodyStateArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'bldr>> {
    let mut builder = PlayerRigidBodyStateBuilder::new(_fbb);
    if let Some(x) = args.input { builder.add_input(x); }
    if let Some(x) = args.state { builder.add_state(x); }
    builder.finish()
  }


  #[inline]
  pub fn state(&self) -> Option<RigidBodyState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RigidBodyState>>(PlayerRigidBodyState::VT_STATE, None)}
  }
  #[inline]
  pub fn input(&self) -> Option<ControllerState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ControllerState>>(PlayerRigidBodyState::VT_INPUT, None)}
  }
}

impl flatbuffers::Verifiable for PlayerRigidBodyState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RigidBodyState>>("state", Self::VT_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>("input", Self::VT_INPUT, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerRigidBodyStateArgs<'a> {
    pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
    pub input: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
}
impl<'a> Default for PlayerRigidBodyStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerRigidBodyStateArgs {
      state: None,
      input: None,
    }
  }
}

pub struct PlayerRigidBodyStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerRigidBodyStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RigidBodyState>>(PlayerRigidBodyState::VT_STATE, state);
  }
  #[inline]
  pub fn add_input(&mut self, input: flatbuffers::WIPOffset<ControllerState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(PlayerRigidBodyState::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerRigidBodyStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerRigidBodyStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerRigidBodyState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerRigidBodyState");
      ds.field("state", &self.state());
      ds.field("input", &self.input());
      ds.finish()
  }
}
pub enum BallRigidBodyStateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rigid body state for the ball.
pub struct BallRigidBodyState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BallRigidBodyState<'a> {
  type Inner = BallRigidBodyState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BallRigidBodyState<'a> {
  pub const VT_STATE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BallRigidBodyState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BallRigidBodyStateArgs<'args>
  ) -> flatbuffers::WIPOffset<BallRigidBodyState<'bldr>> {
    let mut builder = BallRigidBodyStateBuilder::new(_fbb);
    if let Some(x) = args.state { builder.add_state(x); }
    builder.finish()
  }


  #[inline]
  pub fn state(&self) -> Option<RigidBodyState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RigidBodyState>>(BallRigidBodyState::VT_STATE, None)}
  }
}

impl flatbuffers::Verifiable for BallRigidBodyState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<RigidBodyState>>("state", Self::VT_STATE, false)?
     .finish();
    Ok(())
  }
}
pub struct BallRigidBodyStateArgs<'a> {
    pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
}
impl<'a> Default for BallRigidBodyStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    BallRigidBodyStateArgs {
      state: None,
    }
  }
}

pub struct BallRigidBodyStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BallRigidBodyStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RigidBodyState>>(BallRigidBodyState::VT_STATE, state);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BallRigidBodyStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BallRigidBodyStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BallRigidBodyState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BallRigidBodyState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BallRigidBodyState");
      ds.field("state", &self.state());
      ds.finish()
  }
}
pub enum RigidBodyTickOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Contains all rigid body state information.
pub struct RigidBodyTick<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RigidBodyTick<'a> {
  type Inner = RigidBodyTick<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RigidBodyTick<'a> {
  pub const VT_BALL: flatbuffers::VOffsetT = 4;
  pub const VT_PLAYERS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RigidBodyTick { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RigidBodyTickArgs<'args>
  ) -> flatbuffers::WIPOffset<RigidBodyTick<'bldr>> {
    let mut builder = RigidBodyTickBuilder::new(_fbb);
    if let Some(x) = args.players { builder.add_players(x); }
    if let Some(x) = args.ball { builder.add_ball(x); }
    builder.finish()
  }


  #[inline]
  pub fn ball(&self) -> Option<BallRigidBodyState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BallRigidBodyState>>(RigidBodyTick::VT_BALL, None)}
  }
  #[inline]
  pub fn players(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState>>>>(RigidBodyTick::VT_PLAYERS, None)}
  }
}

impl flatbuffers::Verifiable for RigidBodyTick<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<BallRigidBodyState>>("ball", Self::VT_BALL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerRigidBodyState>>>>("players", Self::VT_PLAYERS, false)?
     .finish();
    Ok(())
  }
}
pub struct RigidBodyTickArgs<'a> {
    pub ball: Option<flatbuffers::WIPOffset<BallRigidBodyState<'a>>>,
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>>>,
}
impl<'a> Default for RigidBodyTickArgs<'a> {
  #[inline]
  fn default() -> Self {
    RigidBodyTickArgs {
      ball: None,
      players: None,
    }
  }
}

pub struct RigidBodyTickBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RigidBodyTickBuilder<'a, 'b> {
  #[inline]
  pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallRigidBodyState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BallRigidBodyState>>(RigidBodyTick::VT_BALL, ball);
  }
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RigidBodyTick::VT_PLAYERS, players);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RigidBodyTickBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RigidBodyTickBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyTick<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RigidBodyTick<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RigidBodyTick");
      ds.field("ball", &self.ball());
      ds.field("players", &self.players());
      ds.finish()
  }
}
pub enum GoalInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GoalInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GoalInfo<'a> {
  type Inner = GoalInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GoalInfo<'a> {
  pub const VT_TEAMNUM: flatbuffers::VOffsetT = 4;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GoalInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GoalInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<GoalInfo<'bldr>> {
    let mut builder = GoalInfoBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_width(args.width);
    if let Some(x) = args.direction { builder.add_direction(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_teamNum(args.teamNum);
    builder.finish()
  }


  #[inline]
  pub fn teamNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GoalInfo::VT_TEAMNUM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(GoalInfo::VT_LOCATION, None)}
  }
  #[inline]
  pub fn direction(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(GoalInfo::VT_DIRECTION, None)}
  }
  #[inline]
  pub fn width(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GoalInfo::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(GoalInfo::VT_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GoalInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("teamNum", Self::VT_TEAMNUM, false)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Vector3>("direction", Self::VT_DIRECTION, false)?
     .visit_field::<f32>("width", Self::VT_WIDTH, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct GoalInfoArgs<'a> {
    pub teamNum: i32,
    pub location: Option<&'a Vector3>,
    pub direction: Option<&'a Vector3>,
    pub width: f32,
    pub height: f32,
}
impl<'a> Default for GoalInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    GoalInfoArgs {
      teamNum: 0,
      location: None,
      direction: None,
      width: 0.0,
      height: 0.0,
    }
  }
}

pub struct GoalInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GoalInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_teamNum(&mut self, teamNum: i32) {
    self.fbb_.push_slot::<i32>(GoalInfo::VT_TEAMNUM, teamNum, 0);
  }
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(GoalInfo::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_direction(&mut self, direction: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(GoalInfo::VT_DIRECTION, direction);
  }
  #[inline]
  pub fn add_width(&mut self, width: f32) {
    self.fbb_.push_slot::<f32>(GoalInfo::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(GoalInfo::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GoalInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GoalInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GoalInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GoalInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GoalInfo");
      ds.field("teamNum", &self.teamNum());
      ds.field("location", &self.location());
      ds.field("direction", &self.direction());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.finish()
  }
}
pub enum BoostPadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoostPad<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoostPad<'a> {
  type Inner = BoostPad<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoostPad<'a> {
  pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_ISFULLBOOST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoostPad { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BoostPadArgs<'args>
  ) -> flatbuffers::WIPOffset<BoostPad<'bldr>> {
    let mut builder = BoostPadBuilder::new(_fbb);
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_isFullBoost(args.isFullBoost);
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(BoostPad::VT_LOCATION, None)}
  }
  #[inline]
  pub fn isFullBoost(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(BoostPad::VT_ISFULLBOOST, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BoostPad<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<bool>("isFullBoost", Self::VT_ISFULLBOOST, false)?
     .finish();
    Ok(())
  }
}
pub struct BoostPadArgs<'a> {
    pub location: Option<&'a Vector3>,
    pub isFullBoost: bool,
}
impl<'a> Default for BoostPadArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoostPadArgs {
      location: None,
      isFullBoost: false,
    }
  }
}

pub struct BoostPadBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BoostPadBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(BoostPad::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_isFullBoost(&mut self, isFullBoost: bool) {
    self.fbb_.push_slot::<bool>(BoostPad::VT_ISFULLBOOST, isFullBoost, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoostPadBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BoostPadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoostPad<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoostPad<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoostPad");
      ds.field("location", &self.location());
      ds.field("isFullBoost", &self.isFullBoost());
      ds.finish()
  }
}
pub enum FieldInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FieldInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FieldInfo<'a> {
  type Inner = FieldInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FieldInfo<'a> {
  pub const VT_BOOSTPADS: flatbuffers::VOffsetT = 4;
  pub const VT_GOALS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FieldInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FieldInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<FieldInfo<'bldr>> {
    let mut builder = FieldInfoBuilder::new(_fbb);
    if let Some(x) = args.goals { builder.add_goals(x); }
    if let Some(x) = args.boostPads { builder.add_boostPads(x); }
    builder.finish()
  }


  #[inline]
  pub fn boostPads(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad>>>>(FieldInfo::VT_BOOSTPADS, None)}
  }
  #[inline]
  pub fn goals(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo>>>>(FieldInfo::VT_GOALS, None)}
  }
}

impl flatbuffers::Verifiable for FieldInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPad>>>>("boostPads", Self::VT_BOOSTPADS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GoalInfo>>>>("goals", Self::VT_GOALS, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldInfoArgs<'a> {
    pub boostPads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>>>,
    pub goals: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>>>,
}
impl<'a> Default for FieldInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldInfoArgs {
      boostPads: None,
      goals: None,
    }
  }
}

pub struct FieldInfoBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldInfoBuilder<'a, 'b> {
  #[inline]
  pub fn add_boostPads(&mut self, boostPads: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoostPad<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FieldInfo::VT_BOOSTPADS, boostPads);
  }
  #[inline]
  pub fn add_goals(&mut self, goals: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GoalInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FieldInfo::VT_GOALS, goals);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldInfoBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FieldInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FieldInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FieldInfo");
      ds.field("boostPads", &self.boostPads());
      ds.field("goals", &self.goals());
      ds.finish()
  }
}
pub enum Vector3PartialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Vector3Partial<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vector3Partial<'a> {
  type Inner = Vector3Partial<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vector3Partial<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_Z: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vector3Partial { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Vector3PartialArgs<'args>
  ) -> flatbuffers::WIPOffset<Vector3Partial<'bldr>> {
    let mut builder = Vector3PartialBuilder::new(_fbb);
    if let Some(x) = args.z { builder.add_z(x); }
    if let Some(x) = args.y { builder.add_y(x); }
    if let Some(x) = args.x { builder.add_x(x); }
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(Vector3Partial::VT_X, None)}
  }
  #[inline]
  pub fn y(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(Vector3Partial::VT_Y, None)}
  }
  #[inline]
  pub fn z(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(Vector3Partial::VT_Z, None)}
  }
}

impl flatbuffers::Verifiable for Vector3Partial<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Float>("x", Self::VT_X, false)?
     .visit_field::<Float>("y", Self::VT_Y, false)?
     .visit_field::<Float>("z", Self::VT_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct Vector3PartialArgs<'a> {
    pub x: Option<&'a Float>,
    pub y: Option<&'a Float>,
    pub z: Option<&'a Float>,
}
impl<'a> Default for Vector3PartialArgs<'a> {
  #[inline]
  fn default() -> Self {
    Vector3PartialArgs {
      x: None,
      y: None,
      z: None,
    }
  }
}

pub struct Vector3PartialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Vector3PartialBuilder<'a, 'b> {
  #[inline]
  pub fn add_x(&mut self, x: &Float) {
    self.fbb_.push_slot_always::<&Float>(Vector3Partial::VT_X, x);
  }
  #[inline]
  pub fn add_y(&mut self, y: &Float) {
    self.fbb_.push_slot_always::<&Float>(Vector3Partial::VT_Y, y);
  }
  #[inline]
  pub fn add_z(&mut self, z: &Float) {
    self.fbb_.push_slot_always::<&Float>(Vector3Partial::VT_Z, z);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Vector3PartialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Vector3PartialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vector3Partial<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vector3Partial<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vector3Partial");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.finish()
  }
}
pub enum RotatorPartialOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RotatorPartial<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RotatorPartial<'a> {
  type Inner = RotatorPartial<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RotatorPartial<'a> {
  pub const VT_PITCH: flatbuffers::VOffsetT = 4;
  pub const VT_YAW: flatbuffers::VOffsetT = 6;
  pub const VT_ROLL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RotatorPartial { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RotatorPartialArgs<'args>
  ) -> flatbuffers::WIPOffset<RotatorPartial<'bldr>> {
    let mut builder = RotatorPartialBuilder::new(_fbb);
    if let Some(x) = args.roll { builder.add_roll(x); }
    if let Some(x) = args.yaw { builder.add_yaw(x); }
    if let Some(x) = args.pitch { builder.add_pitch(x); }
    builder.finish()
  }


  #[inline]
  pub fn pitch(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(RotatorPartial::VT_PITCH, None)}
  }
  #[inline]
  pub fn yaw(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(RotatorPartial::VT_YAW, None)}
  }
  #[inline]
  pub fn roll(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(RotatorPartial::VT_ROLL, None)}
  }
}

impl flatbuffers::Verifiable for RotatorPartial<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Float>("pitch", Self::VT_PITCH, false)?
     .visit_field::<Float>("yaw", Self::VT_YAW, false)?
     .visit_field::<Float>("roll", Self::VT_ROLL, false)?
     .finish();
    Ok(())
  }
}
pub struct RotatorPartialArgs<'a> {
    pub pitch: Option<&'a Float>,
    pub yaw: Option<&'a Float>,
    pub roll: Option<&'a Float>,
}
impl<'a> Default for RotatorPartialArgs<'a> {
  #[inline]
  fn default() -> Self {
    RotatorPartialArgs {
      pitch: None,
      yaw: None,
      roll: None,
    }
  }
}

pub struct RotatorPartialBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RotatorPartialBuilder<'a, 'b> {
  #[inline]
  pub fn add_pitch(&mut self, pitch: &Float) {
    self.fbb_.push_slot_always::<&Float>(RotatorPartial::VT_PITCH, pitch);
  }
  #[inline]
  pub fn add_yaw(&mut self, yaw: &Float) {
    self.fbb_.push_slot_always::<&Float>(RotatorPartial::VT_YAW, yaw);
  }
  #[inline]
  pub fn add_roll(&mut self, roll: &Float) {
    self.fbb_.push_slot_always::<&Float>(RotatorPartial::VT_ROLL, roll);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RotatorPartialBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RotatorPartialBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RotatorPartial<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RotatorPartial<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RotatorPartial");
      ds.field("pitch", &self.pitch());
      ds.field("yaw", &self.yaw());
      ds.field("roll", &self.roll());
      ds.finish()
  }
}
pub enum DesiredPhysicsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredPhysics<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredPhysics<'a> {
  type Inner = DesiredPhysics<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredPhysics<'a> {
  pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
  pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
  pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredPhysics { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredPhysicsArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredPhysics<'bldr>> {
    let mut builder = DesiredPhysicsBuilder::new(_fbb);
    if let Some(x) = args.angularVelocity { builder.add_angularVelocity(x); }
    if let Some(x) = args.velocity { builder.add_velocity(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<Vector3Partial<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(DesiredPhysics::VT_LOCATION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<RotatorPartial<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RotatorPartial>>(DesiredPhysics::VT_ROTATION, None)}
  }
  #[inline]
  pub fn velocity(&self) -> Option<Vector3Partial<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(DesiredPhysics::VT_VELOCITY, None)}
  }
  #[inline]
  pub fn angularVelocity(&self) -> Option<Vector3Partial<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(DesiredPhysics::VT_ANGULARVELOCITY, None)}
  }
}

impl flatbuffers::Verifiable for DesiredPhysics<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>("location", Self::VT_LOCATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RotatorPartial>>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>("velocity", Self::VT_VELOCITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>("angularVelocity", Self::VT_ANGULARVELOCITY, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredPhysicsArgs<'a> {
    pub location: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
    pub rotation: Option<flatbuffers::WIPOffset<RotatorPartial<'a>>>,
    pub velocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
    pub angularVelocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
}
impl<'a> Default for DesiredPhysicsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredPhysicsArgs {
      location: None,
      rotation: None,
      velocity: None,
      angularVelocity: None,
    }
  }
}

pub struct DesiredPhysicsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredPhysicsBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: flatbuffers::WIPOffset<Vector3Partial<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(DesiredPhysics::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<RotatorPartial<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RotatorPartial>>(DesiredPhysics::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_velocity(&mut self, velocity: flatbuffers::WIPOffset<Vector3Partial<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(DesiredPhysics::VT_VELOCITY, velocity);
  }
  #[inline]
  pub fn add_angularVelocity(&mut self, angularVelocity: flatbuffers::WIPOffset<Vector3Partial<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(DesiredPhysics::VT_ANGULARVELOCITY, angularVelocity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredPhysicsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredPhysicsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredPhysics<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredPhysics<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredPhysics");
      ds.field("location", &self.location());
      ds.field("rotation", &self.rotation());
      ds.field("velocity", &self.velocity());
      ds.field("angularVelocity", &self.angularVelocity());
      ds.finish()
  }
}
pub enum DesiredBallStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredBallState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredBallState<'a> {
  type Inner = DesiredBallState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredBallState<'a> {
  pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredBallState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredBallStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredBallState<'bldr>> {
    let mut builder = DesiredBallStateBuilder::new(_fbb);
    if let Some(x) = args.physics { builder.add_physics(x); }
    builder.finish()
  }


  #[inline]
  pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(DesiredBallState::VT_PHYSICS, None)}
  }
}

impl flatbuffers::Verifiable for DesiredBallState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DesiredPhysics>>("physics", Self::VT_PHYSICS, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredBallStateArgs<'a> {
    pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
}
impl<'a> Default for DesiredBallStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredBallStateArgs {
      physics: None,
    }
  }
}

pub struct DesiredBallStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredBallStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(DesiredBallState::VT_PHYSICS, physics);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredBallStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredBallStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBallState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredBallState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredBallState");
      ds.field("physics", &self.physics());
      ds.finish()
  }
}
pub enum DesiredCarStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredCarState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredCarState<'a> {
  type Inner = DesiredCarState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredCarState<'a> {
  pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
  pub const VT_BOOSTAMOUNT: flatbuffers::VOffsetT = 6;
  pub const VT_JUMPED: flatbuffers::VOffsetT = 8;
  pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredCarState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredCarStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredCarState<'bldr>> {
    let mut builder = DesiredCarStateBuilder::new(_fbb);
    if let Some(x) = args.doubleJumped { builder.add_doubleJumped(x); }
    if let Some(x) = args.jumped { builder.add_jumped(x); }
    if let Some(x) = args.boostAmount { builder.add_boostAmount(x); }
    if let Some(x) = args.physics { builder.add_physics(x); }
    builder.finish()
  }


  #[inline]
  pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(DesiredCarState::VT_PHYSICS, None)}
  }
  #[inline]
  pub fn boostAmount(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(DesiredCarState::VT_BOOSTAMOUNT, None)}
  }
  #[inline]
  pub fn jumped(&self) -> Option<&'a Bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bool>(DesiredCarState::VT_JUMPED, None)}
  }
  #[inline]
  pub fn doubleJumped(&self) -> Option<&'a Bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bool>(DesiredCarState::VT_DOUBLEJUMPED, None)}
  }
}

impl flatbuffers::Verifiable for DesiredCarState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DesiredPhysics>>("physics", Self::VT_PHYSICS, false)?
     .visit_field::<Float>("boostAmount", Self::VT_BOOSTAMOUNT, false)?
     .visit_field::<Bool>("jumped", Self::VT_JUMPED, false)?
     .visit_field::<Bool>("doubleJumped", Self::VT_DOUBLEJUMPED, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredCarStateArgs<'a> {
    pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
    pub boostAmount: Option<&'a Float>,
    pub jumped: Option<&'a Bool>,
    pub doubleJumped: Option<&'a Bool>,
}
impl<'a> Default for DesiredCarStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredCarStateArgs {
      physics: None,
      boostAmount: None,
      jumped: None,
      doubleJumped: None,
    }
  }
}

pub struct DesiredCarStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredCarStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(DesiredCarState::VT_PHYSICS, physics);
  }
  #[inline]
  pub fn add_boostAmount(&mut self, boostAmount: &Float) {
    self.fbb_.push_slot_always::<&Float>(DesiredCarState::VT_BOOSTAMOUNT, boostAmount);
  }
  #[inline]
  pub fn add_jumped(&mut self, jumped: &Bool) {
    self.fbb_.push_slot_always::<&Bool>(DesiredCarState::VT_JUMPED, jumped);
  }
  #[inline]
  pub fn add_doubleJumped(&mut self, doubleJumped: &Bool) {
    self.fbb_.push_slot_always::<&Bool>(DesiredCarState::VT_DOUBLEJUMPED, doubleJumped);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredCarStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredCarStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredCarState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredCarState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredCarState");
      ds.field("physics", &self.physics());
      ds.field("boostAmount", &self.boostAmount());
      ds.field("jumped", &self.jumped());
      ds.field("doubleJumped", &self.doubleJumped());
      ds.finish()
  }
}
pub enum DesiredBoostStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredBoostState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredBoostState<'a> {
  type Inner = DesiredBoostState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredBoostState<'a> {
  pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredBoostState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredBoostStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredBoostState<'bldr>> {
    let mut builder = DesiredBoostStateBuilder::new(_fbb);
    if let Some(x) = args.respawnTime { builder.add_respawnTime(x); }
    builder.finish()
  }


  #[inline]
  pub fn respawnTime(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(DesiredBoostState::VT_RESPAWNTIME, None)}
  }
}

impl flatbuffers::Verifiable for DesiredBoostState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Float>("respawnTime", Self::VT_RESPAWNTIME, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredBoostStateArgs<'a> {
    pub respawnTime: Option<&'a Float>,
}
impl<'a> Default for DesiredBoostStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredBoostStateArgs {
      respawnTime: None,
    }
  }
}

pub struct DesiredBoostStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredBoostStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_respawnTime(&mut self, respawnTime: &Float) {
    self.fbb_.push_slot_always::<&Float>(DesiredBoostState::VT_RESPAWNTIME, respawnTime);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredBoostStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredBoostStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBoostState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredBoostState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredBoostState");
      ds.field("respawnTime", &self.respawnTime());
      ds.finish()
  }
}
pub enum DesiredGameInfoStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredGameInfoState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredGameInfoState<'a> {
  type Inner = DesiredGameInfoState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredGameInfoState<'a> {
  pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 4;
  pub const VT_GAMESPEED: flatbuffers::VOffsetT = 6;
  pub const VT_PAUSED: flatbuffers::VOffsetT = 8;
  pub const VT_ENDMATCH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredGameInfoState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredGameInfoStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredGameInfoState<'bldr>> {
    let mut builder = DesiredGameInfoStateBuilder::new(_fbb);
    if let Some(x) = args.endMatch { builder.add_endMatch(x); }
    if let Some(x) = args.paused { builder.add_paused(x); }
    if let Some(x) = args.gameSpeed { builder.add_gameSpeed(x); }
    if let Some(x) = args.worldGravityZ { builder.add_worldGravityZ(x); }
    builder.finish()
  }


  #[inline]
  pub fn worldGravityZ(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(DesiredGameInfoState::VT_WORLDGRAVITYZ, None)}
  }
  #[inline]
  pub fn gameSpeed(&self) -> Option<&'a Float> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Float>(DesiredGameInfoState::VT_GAMESPEED, None)}
  }
  #[inline]
  pub fn paused(&self) -> Option<&'a Bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bool>(DesiredGameInfoState::VT_PAUSED, None)}
  }
  #[inline]
  pub fn endMatch(&self) -> Option<&'a Bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bool>(DesiredGameInfoState::VT_ENDMATCH, None)}
  }
}

impl flatbuffers::Verifiable for DesiredGameInfoState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Float>("worldGravityZ", Self::VT_WORLDGRAVITYZ, false)?
     .visit_field::<Float>("gameSpeed", Self::VT_GAMESPEED, false)?
     .visit_field::<Bool>("paused", Self::VT_PAUSED, false)?
     .visit_field::<Bool>("endMatch", Self::VT_ENDMATCH, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredGameInfoStateArgs<'a> {
    pub worldGravityZ: Option<&'a Float>,
    pub gameSpeed: Option<&'a Float>,
    pub paused: Option<&'a Bool>,
    pub endMatch: Option<&'a Bool>,
}
impl<'a> Default for DesiredGameInfoStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredGameInfoStateArgs {
      worldGravityZ: None,
      gameSpeed: None,
      paused: None,
      endMatch: None,
    }
  }
}

pub struct DesiredGameInfoStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredGameInfoStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_worldGravityZ(&mut self, worldGravityZ: &Float) {
    self.fbb_.push_slot_always::<&Float>(DesiredGameInfoState::VT_WORLDGRAVITYZ, worldGravityZ);
  }
  #[inline]
  pub fn add_gameSpeed(&mut self, gameSpeed: &Float) {
    self.fbb_.push_slot_always::<&Float>(DesiredGameInfoState::VT_GAMESPEED, gameSpeed);
  }
  #[inline]
  pub fn add_paused(&mut self, paused: &Bool) {
    self.fbb_.push_slot_always::<&Bool>(DesiredGameInfoState::VT_PAUSED, paused);
  }
  #[inline]
  pub fn add_endMatch(&mut self, endMatch: &Bool) {
    self.fbb_.push_slot_always::<&Bool>(DesiredGameInfoState::VT_ENDMATCH, endMatch);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredGameInfoStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredGameInfoStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameInfoState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredGameInfoState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredGameInfoState");
      ds.field("worldGravityZ", &self.worldGravityZ());
      ds.field("gameSpeed", &self.gameSpeed());
      ds.field("paused", &self.paused());
      ds.field("endMatch", &self.endMatch());
      ds.finish()
  }
}
pub enum ConsoleCommandOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A console command which we will try to execute inside Rocket League.
/// See https://github.com/RLBot/RLBot/wiki/Console-Commands for a list of known commands.
pub struct ConsoleCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConsoleCommand<'a> {
  type Inner = ConsoleCommand<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ConsoleCommand<'a> {
  pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConsoleCommand { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConsoleCommandArgs<'args>
  ) -> flatbuffers::WIPOffset<ConsoleCommand<'bldr>> {
    let mut builder = ConsoleCommandBuilder::new(_fbb);
    if let Some(x) = args.command { builder.add_command(x); }
    builder.finish()
  }


  #[inline]
  pub fn command(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ConsoleCommand::VT_COMMAND, None)}
  }
}

impl flatbuffers::Verifiable for ConsoleCommand<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("command", Self::VT_COMMAND, false)?
     .finish();
    Ok(())
  }
}
pub struct ConsoleCommandArgs<'a> {
    pub command: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ConsoleCommandArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConsoleCommandArgs {
      command: None,
    }
  }
}

pub struct ConsoleCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConsoleCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConsoleCommand::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConsoleCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConsoleCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConsoleCommand<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConsoleCommand");
      ds.field("command", &self.command());
      ds.finish()
  }
}
pub enum DesiredGameStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DesiredGameState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DesiredGameState<'a> {
  type Inner = DesiredGameState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DesiredGameState<'a> {
  pub const VT_BALLSTATE: flatbuffers::VOffsetT = 4;
  pub const VT_CARSTATES: flatbuffers::VOffsetT = 6;
  pub const VT_BOOSTSTATES: flatbuffers::VOffsetT = 8;
  pub const VT_GAMEINFOSTATE: flatbuffers::VOffsetT = 10;
  pub const VT_CONSOLECOMMANDS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DesiredGameState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DesiredGameStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DesiredGameState<'bldr>> {
    let mut builder = DesiredGameStateBuilder::new(_fbb);
    if let Some(x) = args.consoleCommands { builder.add_consoleCommands(x); }
    if let Some(x) = args.gameInfoState { builder.add_gameInfoState(x); }
    if let Some(x) = args.boostStates { builder.add_boostStates(x); }
    if let Some(x) = args.carStates { builder.add_carStates(x); }
    if let Some(x) = args.ballState { builder.add_ballState(x); }
    builder.finish()
  }


  #[inline]
  pub fn ballState(&self) -> Option<DesiredBallState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DesiredBallState>>(DesiredGameState::VT_BALLSTATE, None)}
  }
  #[inline]
  pub fn carStates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState>>>>(DesiredGameState::VT_CARSTATES, None)}
  }
  #[inline]
  pub fn boostStates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState>>>>(DesiredGameState::VT_BOOSTSTATES, None)}
  }
  #[inline]
  pub fn gameInfoState(&self) -> Option<DesiredGameInfoState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DesiredGameInfoState>>(DesiredGameState::VT_GAMEINFOSTATE, None)}
  }
  #[inline]
  pub fn consoleCommands(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand>>>>(DesiredGameState::VT_CONSOLECOMMANDS, None)}
  }
}

impl flatbuffers::Verifiable for DesiredGameState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DesiredBallState>>("ballState", Self::VT_BALLSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredCarState>>>>("carStates", Self::VT_CARSTATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredBoostState>>>>("boostStates", Self::VT_BOOSTSTATES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DesiredGameInfoState>>("gameInfoState", Self::VT_GAMEINFOSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleCommand>>>>("consoleCommands", Self::VT_CONSOLECOMMANDS, false)?
     .finish();
    Ok(())
  }
}
pub struct DesiredGameStateArgs<'a> {
    pub ballState: Option<flatbuffers::WIPOffset<DesiredBallState<'a>>>,
    pub carStates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>>>,
    pub boostStates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>>>,
    pub gameInfoState: Option<flatbuffers::WIPOffset<DesiredGameInfoState<'a>>>,
    pub consoleCommands: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>>>,
}
impl<'a> Default for DesiredGameStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DesiredGameStateArgs {
      ballState: None,
      carStates: None,
      boostStates: None,
      gameInfoState: None,
      consoleCommands: None,
    }
  }
}

pub struct DesiredGameStateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DesiredGameStateBuilder<'a, 'b> {
  #[inline]
  pub fn add_ballState(&mut self, ballState: flatbuffers::WIPOffset<DesiredBallState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DesiredBallState>>(DesiredGameState::VT_BALLSTATE, ballState);
  }
  #[inline]
  pub fn add_carStates(&mut self, carStates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DesiredCarState<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesiredGameState::VT_CARSTATES, carStates);
  }
  #[inline]
  pub fn add_boostStates(&mut self, boostStates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DesiredBoostState<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesiredGameState::VT_BOOSTSTATES, boostStates);
  }
  #[inline]
  pub fn add_gameInfoState(&mut self, gameInfoState: flatbuffers::WIPOffset<DesiredGameInfoState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DesiredGameInfoState>>(DesiredGameState::VT_GAMEINFOSTATE, gameInfoState);
  }
  #[inline]
  pub fn add_consoleCommands(&mut self, consoleCommands: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ConsoleCommand<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DesiredGameState::VT_CONSOLECOMMANDS, consoleCommands);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DesiredGameStateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DesiredGameStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DesiredGameState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DesiredGameState");
      ds.field("ballState", &self.ballState());
      ds.field("carStates", &self.carStates());
      ds.field("boostStates", &self.boostStates());
      ds.field("gameInfoState", &self.gameInfoState());
      ds.field("consoleCommands", &self.consoleCommands());
      ds.finish()
  }
}
pub enum ColorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Color<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Color<'a> {
  type Inner = Color<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Color<'a> {
  pub const VT_A: flatbuffers::VOffsetT = 4;
  pub const VT_R: flatbuffers::VOffsetT = 6;
  pub const VT_G: flatbuffers::VOffsetT = 8;
  pub const VT_B: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Color { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ColorArgs
  ) -> flatbuffers::WIPOffset<Color<'bldr>> {
    let mut builder = ColorBuilder::new(_fbb);
    builder.add_b(args.b);
    builder.add_g(args.g);
    builder.add_r(args.r);
    builder.add_a(args.a);
    builder.finish()
  }


  #[inline]
  pub fn a(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color::VT_A, Some(0)).unwrap()}
  }
  #[inline]
  pub fn r(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color::VT_R, Some(0)).unwrap()}
  }
  #[inline]
  pub fn g(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color::VT_G, Some(0)).unwrap()}
  }
  #[inline]
  pub fn b(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Color::VT_B, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Color<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("a", Self::VT_A, false)?
     .visit_field::<u8>("r", Self::VT_R, false)?
     .visit_field::<u8>("g", Self::VT_G, false)?
     .visit_field::<u8>("b", Self::VT_B, false)?
     .finish();
    Ok(())
  }
}
pub struct ColorArgs {
    pub a: u8,
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
impl<'a> Default for ColorArgs {
  #[inline]
  fn default() -> Self {
    ColorArgs {
      a: 0,
      r: 0,
      g: 0,
      b: 0,
    }
  }
}

pub struct ColorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ColorBuilder<'a, 'b> {
  #[inline]
  pub fn add_a(&mut self, a: u8) {
    self.fbb_.push_slot::<u8>(Color::VT_A, a, 0);
  }
  #[inline]
  pub fn add_r(&mut self, r: u8) {
    self.fbb_.push_slot::<u8>(Color::VT_R, r, 0);
  }
  #[inline]
  pub fn add_g(&mut self, g: u8) {
    self.fbb_.push_slot::<u8>(Color::VT_G, g, 0);
  }
  #[inline]
  pub fn add_b(&mut self, b: u8) {
    self.fbb_.push_slot::<u8>(Color::VT_B, b, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ColorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Color<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Color");
      ds.field("a", &self.a());
      ds.field("r", &self.r());
      ds.field("g", &self.g());
      ds.field("b", &self.b());
      ds.finish()
  }
}
pub enum RenderMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RenderMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RenderMessage<'a> {
  type Inner = RenderMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RenderMessage<'a> {
  pub const VT_RENDERTYPE: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;
  pub const VT_START: flatbuffers::VOffsetT = 8;
  pub const VT_END: flatbuffers::VOffsetT = 10;
  pub const VT_SCALEX: flatbuffers::VOffsetT = 12;
  pub const VT_SCALEY: flatbuffers::VOffsetT = 14;
  pub const VT_TEXT: flatbuffers::VOffsetT = 16;
  pub const VT_ISFILLED: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RenderMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RenderMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<RenderMessage<'bldr>> {
    let mut builder = RenderMessageBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    builder.add_scaleY(args.scaleY);
    builder.add_scaleX(args.scaleX);
    if let Some(x) = args.end { builder.add_end(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.add_isFilled(args.isFilled);
    builder.add_renderType(args.renderType);
    builder.finish()
  }


  #[inline]
  pub fn renderType(&self) -> RenderType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RenderType>(RenderMessage::VT_RENDERTYPE, Some(RenderType::DrawLine2D)).unwrap()}
  }
  #[inline]
  pub fn color(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(RenderMessage::VT_COLOR, None)}
  }
  /// For 2d renders this only grabs x and y
  #[inline]
  pub fn start(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(RenderMessage::VT_START, None)}
  }
  /// For 2d renders this only grabs x and y
  #[inline]
  pub fn end(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(RenderMessage::VT_END, None)}
  }
  /// Scales the x size of the text/rectangle, is used for rectangles assuming an initial value of 1
  #[inline]
  pub fn scaleX(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RenderMessage::VT_SCALEX, Some(1)).unwrap()}
  }
  /// Scales the y size of the text/rectangle, is used for rectangles assuming an initial value of 1
  #[inline]
  pub fn scaleY(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RenderMessage::VT_SCALEY, Some(1)).unwrap()}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(RenderMessage::VT_TEXT, None)}
  }
  /// Rectangles can be filled or just outlines.
  #[inline]
  pub fn isFilled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RenderMessage::VT_ISFILLED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RenderMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<RenderType>("renderType", Self::VT_RENDERTYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("color", Self::VT_COLOR, false)?
     .visit_field::<Vector3>("start", Self::VT_START, false)?
     .visit_field::<Vector3>("end", Self::VT_END, false)?
     .visit_field::<i32>("scaleX", Self::VT_SCALEX, false)?
     .visit_field::<i32>("scaleY", Self::VT_SCALEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<bool>("isFilled", Self::VT_ISFILLED, false)?
     .finish();
    Ok(())
  }
}
pub struct RenderMessageArgs<'a> {
    pub renderType: RenderType,
    pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub start: Option<&'a Vector3>,
    pub end: Option<&'a Vector3>,
    pub scaleX: i32,
    pub scaleY: i32,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isFilled: bool,
}
impl<'a> Default for RenderMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    RenderMessageArgs {
      renderType: RenderType::DrawLine2D,
      color: None,
      start: None,
      end: None,
      scaleX: 1,
      scaleY: 1,
      text: None,
      isFilled: false,
    }
  }
}

pub struct RenderMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RenderMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_renderType(&mut self, renderType: RenderType) {
    self.fbb_.push_slot::<RenderType>(RenderMessage::VT_RENDERTYPE, renderType, RenderType::DrawLine2D);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(RenderMessage::VT_COLOR, color);
  }
  #[inline]
  pub fn add_start(&mut self, start: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(RenderMessage::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(RenderMessage::VT_END, end);
  }
  #[inline]
  pub fn add_scaleX(&mut self, scaleX: i32) {
    self.fbb_.push_slot::<i32>(RenderMessage::VT_SCALEX, scaleX, 1);
  }
  #[inline]
  pub fn add_scaleY(&mut self, scaleY: i32) {
    self.fbb_.push_slot::<i32>(RenderMessage::VT_SCALEY, scaleY, 1);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RenderMessage::VT_TEXT, text);
  }
  #[inline]
  pub fn add_isFilled(&mut self, isFilled: bool) {
    self.fbb_.push_slot::<bool>(RenderMessage::VT_ISFILLED, isFilled, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RenderMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RenderMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RenderMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RenderMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RenderMessage");
      ds.field("renderType", &self.renderType());
      ds.field("color", &self.color());
      ds.field("start", &self.start());
      ds.field("end", &self.end());
      ds.field("scaleX", &self.scaleX());
      ds.field("scaleY", &self.scaleY());
      ds.field("text", &self.text());
      ds.field("isFilled", &self.isFilled());
      ds.finish()
  }
}
pub enum RenderGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RenderGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RenderGroup<'a> {
  type Inner = RenderGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RenderGroup<'a> {
  pub const VT_RENDERMESSAGES: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RenderGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RenderGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<RenderGroup<'bldr>> {
    let mut builder = RenderGroupBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.renderMessages { builder.add_renderMessages(x); }
    builder.finish()
  }


  #[inline]
  pub fn renderMessages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage>>>>(RenderGroup::VT_RENDERMESSAGES, None)}
  }
  /// The id of the render group
  #[inline]
  pub fn id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(RenderGroup::VT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RenderGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RenderMessage>>>>("renderMessages", Self::VT_RENDERMESSAGES, false)?
     .visit_field::<i32>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct RenderGroupArgs<'a> {
    pub renderMessages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>>>,
    pub id: i32,
}
impl<'a> Default for RenderGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    RenderGroupArgs {
      renderMessages: None,
      id: 0,
    }
  }
}

pub struct RenderGroupBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RenderGroupBuilder<'a, 'b> {
  #[inline]
  pub fn add_renderMessages(&mut self, renderMessages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<RenderMessage<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RenderGroup::VT_RENDERMESSAGES, renderMessages);
  }
  #[inline]
  pub fn add_id(&mut self, id: i32) {
    self.fbb_.push_slot::<i32>(RenderGroup::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RenderGroupBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RenderGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RenderGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RenderGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RenderGroup");
      ds.field("renderMessages", &self.renderMessages());
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum QuickChatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuickChat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuickChat<'a> {
  type Inner = QuickChat<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuickChat<'a> {
  pub const VT_QUICKCHATSELECTION: flatbuffers::VOffsetT = 4;
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 6;
  pub const VT_TEAMONLY: flatbuffers::VOffsetT = 8;
  pub const VT_MESSAGEINDEX: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuickChat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args QuickChatArgs
  ) -> flatbuffers::WIPOffset<QuickChat<'bldr>> {
    let mut builder = QuickChatBuilder::new(_fbb);
    builder.add_timeStamp(args.timeStamp);
    builder.add_messageIndex(args.messageIndex);
    builder.add_playerIndex(args.playerIndex);
    builder.add_teamOnly(args.teamOnly);
    builder.add_quickChatSelection(args.quickChatSelection);
    builder.finish()
  }


  #[inline]
  pub fn quickChatSelection(&self) -> QuickChatSelection {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<QuickChatSelection>(QuickChat::VT_QUICKCHATSELECTION, Some(QuickChatSelection::Information_IGotIt)).unwrap()}
  }
  /// The index of the player that sent the quick chat
  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(QuickChat::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
  /// True if the chat is team only false if everyone can see it.
  #[inline]
  pub fn teamOnly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(QuickChat::VT_TEAMONLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn messageIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(QuickChat::VT_MESSAGEINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timeStamp(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(QuickChat::VT_TIMESTAMP, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for QuickChat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<QuickChatSelection>("quickChatSelection", Self::VT_QUICKCHATSELECTION, false)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .visit_field::<bool>("teamOnly", Self::VT_TEAMONLY, false)?
     .visit_field::<i32>("messageIndex", Self::VT_MESSAGEINDEX, false)?
     .visit_field::<f32>("timeStamp", Self::VT_TIMESTAMP, false)?
     .finish();
    Ok(())
  }
}
pub struct QuickChatArgs {
    pub quickChatSelection: QuickChatSelection,
    pub playerIndex: i32,
    pub teamOnly: bool,
    pub messageIndex: i32,
    pub timeStamp: f32,
}
impl<'a> Default for QuickChatArgs {
  #[inline]
  fn default() -> Self {
    QuickChatArgs {
      quickChatSelection: QuickChatSelection::Information_IGotIt,
      playerIndex: 0,
      teamOnly: false,
      messageIndex: 0,
      timeStamp: 0.0,
    }
  }
}

pub struct QuickChatBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuickChatBuilder<'a, 'b> {
  #[inline]
  pub fn add_quickChatSelection(&mut self, quickChatSelection: QuickChatSelection) {
    self.fbb_.push_slot::<QuickChatSelection>(QuickChat::VT_QUICKCHATSELECTION, quickChatSelection, QuickChatSelection::Information_IGotIt);
  }
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(QuickChat::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn add_teamOnly(&mut self, teamOnly: bool) {
    self.fbb_.push_slot::<bool>(QuickChat::VT_TEAMONLY, teamOnly, false);
  }
  #[inline]
  pub fn add_messageIndex(&mut self, messageIndex: i32) {
    self.fbb_.push_slot::<i32>(QuickChat::VT_MESSAGEINDEX, messageIndex, 0);
  }
  #[inline]
  pub fn add_timeStamp(&mut self, timeStamp: f32) {
    self.fbb_.push_slot::<f32>(QuickChat::VT_TIMESTAMP, timeStamp, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuickChatBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuickChatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuickChat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuickChat<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuickChat");
      ds.field("quickChatSelection", &self.quickChatSelection());
      ds.field("playerIndex", &self.playerIndex());
      ds.field("teamOnly", &self.teamOnly());
      ds.field("messageIndex", &self.messageIndex());
      ds.field("timeStamp", &self.timeStamp());
      ds.finish()
  }
}
pub enum TinyPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A minimal version of player data, useful when bandwidth needs to be conserved.
pub struct TinyPlayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TinyPlayer<'a> {
  type Inner = TinyPlayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TinyPlayer<'a> {
  pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
  pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
  pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
  pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
  pub const VT_TEAM: flatbuffers::VOffsetT = 14;
  pub const VT_BOOST: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TinyPlayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TinyPlayerArgs<'args>
  ) -> flatbuffers::WIPOffset<TinyPlayer<'bldr>> {
    let mut builder = TinyPlayerBuilder::new(_fbb);
    builder.add_boost(args.boost);
    builder.add_team(args.team);
    if let Some(x) = args.velocity { builder.add_velocity(x); }
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.add_isSupersonic(args.isSupersonic);
    builder.add_hasWheelContact(args.hasWheelContact);
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(TinyPlayer::VT_LOCATION, None)}
  }
  #[inline]
  pub fn rotation(&self) -> Option<&'a Rotator> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Rotator>(TinyPlayer::VT_ROTATION, None)}
  }
  #[inline]
  pub fn velocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(TinyPlayer::VT_VELOCITY, None)}
  }
  #[inline]
  pub fn hasWheelContact(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TinyPlayer::VT_HASWHEELCONTACT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isSupersonic(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(TinyPlayer::VT_ISSUPERSONIC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn team(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TinyPlayer::VT_TEAM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn boost(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(TinyPlayer::VT_BOOST, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TinyPlayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Rotator>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
     .visit_field::<bool>("hasWheelContact", Self::VT_HASWHEELCONTACT, false)?
     .visit_field::<bool>("isSupersonic", Self::VT_ISSUPERSONIC, false)?
     .visit_field::<i32>("team", Self::VT_TEAM, false)?
     .visit_field::<i32>("boost", Self::VT_BOOST, false)?
     .finish();
    Ok(())
  }
}
pub struct TinyPlayerArgs<'a> {
    pub location: Option<&'a Vector3>,
    pub rotation: Option<&'a Rotator>,
    pub velocity: Option<&'a Vector3>,
    pub hasWheelContact: bool,
    pub isSupersonic: bool,
    pub team: i32,
    pub boost: i32,
}
impl<'a> Default for TinyPlayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    TinyPlayerArgs {
      location: None,
      rotation: None,
      velocity: None,
      hasWheelContact: false,
      isSupersonic: false,
      team: 0,
      boost: 0,
    }
  }
}

pub struct TinyPlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TinyPlayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(TinyPlayer::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: &Rotator) {
    self.fbb_.push_slot_always::<&Rotator>(TinyPlayer::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_velocity(&mut self, velocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(TinyPlayer::VT_VELOCITY, velocity);
  }
  #[inline]
  pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
    self.fbb_.push_slot::<bool>(TinyPlayer::VT_HASWHEELCONTACT, hasWheelContact, false);
  }
  #[inline]
  pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
    self.fbb_.push_slot::<bool>(TinyPlayer::VT_ISSUPERSONIC, isSupersonic, false);
  }
  #[inline]
  pub fn add_team(&mut self, team: i32) {
    self.fbb_.push_slot::<i32>(TinyPlayer::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_boost(&mut self, boost: i32) {
    self.fbb_.push_slot::<i32>(TinyPlayer::VT_BOOST, boost, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TinyPlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TinyPlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TinyPlayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TinyPlayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TinyPlayer");
      ds.field("location", &self.location());
      ds.field("rotation", &self.rotation());
      ds.field("velocity", &self.velocity());
      ds.field("hasWheelContact", &self.hasWheelContact());
      ds.field("isSupersonic", &self.isSupersonic());
      ds.field("team", &self.team());
      ds.field("boost", &self.boost());
      ds.finish()
  }
}
pub enum TinyBallOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A minimal version of the ball, useful when bandwidth needs to be conserved.
pub struct TinyBall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TinyBall<'a> {
  type Inner = TinyBall<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TinyBall<'a> {
  pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
  pub const VT_VELOCITY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TinyBall { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TinyBallArgs<'args>
  ) -> flatbuffers::WIPOffset<TinyBall<'bldr>> {
    let mut builder = TinyBallBuilder::new(_fbb);
    if let Some(x) = args.velocity { builder.add_velocity(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    builder.finish()
  }


  #[inline]
  pub fn location(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(TinyBall::VT_LOCATION, None)}
  }
  #[inline]
  pub fn velocity(&self) -> Option<&'a Vector3> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3>(TinyBall::VT_VELOCITY, None)}
  }
}

impl flatbuffers::Verifiable for TinyBall<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
     .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
     .finish();
    Ok(())
  }
}
pub struct TinyBallArgs<'a> {
    pub location: Option<&'a Vector3>,
    pub velocity: Option<&'a Vector3>,
}
impl<'a> Default for TinyBallArgs<'a> {
  #[inline]
  fn default() -> Self {
    TinyBallArgs {
      location: None,
      velocity: None,
    }
  }
}

pub struct TinyBallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TinyBallBuilder<'a, 'b> {
  #[inline]
  pub fn add_location(&mut self, location: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(TinyBall::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_velocity(&mut self, velocity: &Vector3) {
    self.fbb_.push_slot_always::<&Vector3>(TinyBall::VT_VELOCITY, velocity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TinyBallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TinyBallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TinyBall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TinyBall<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TinyBall");
      ds.field("location", &self.location());
      ds.field("velocity", &self.velocity());
      ds.finish()
  }
}
pub enum TinyPacketOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A minimal version of the game tick packet, useful when bandwidth needs to be conserved.
pub struct TinyPacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TinyPacket<'a> {
  type Inner = TinyPacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TinyPacket<'a> {
  pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
  pub const VT_BALL: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TinyPacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TinyPacketArgs<'args>
  ) -> flatbuffers::WIPOffset<TinyPacket<'bldr>> {
    let mut builder = TinyPacketBuilder::new(_fbb);
    if let Some(x) = args.ball { builder.add_ball(x); }
    if let Some(x) = args.players { builder.add_players(x); }
    builder.finish()
  }


  #[inline]
  pub fn players(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer>>>>(TinyPacket::VT_PLAYERS, None)}
  }
  #[inline]
  pub fn ball(&self) -> Option<TinyBall<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TinyBall>>(TinyPacket::VT_BALL, None)}
  }
}

impl flatbuffers::Verifiable for TinyPacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TinyPlayer>>>>("players", Self::VT_PLAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TinyBall>>("ball", Self::VT_BALL, false)?
     .finish();
    Ok(())
  }
}
pub struct TinyPacketArgs<'a> {
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>>>,
    pub ball: Option<flatbuffers::WIPOffset<TinyBall<'a>>>,
}
impl<'a> Default for TinyPacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    TinyPacketArgs {
      players: None,
      ball: None,
    }
  }
}

pub struct TinyPacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TinyPacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TinyPlayer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TinyPacket::VT_PLAYERS, players);
  }
  #[inline]
  pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<TinyBall<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TinyBall>>(TinyPacket::VT_BALL, ball);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TinyPacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TinyPacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TinyPacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TinyPacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TinyPacket");
      ds.field("players", &self.players());
      ds.field("ball", &self.ball());
      ds.finish()
  }
}
pub enum PredictionSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PredictionSlice<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PredictionSlice<'a> {
  type Inner = PredictionSlice<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PredictionSlice<'a> {
  pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 4;
  pub const VT_PHYSICS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PredictionSlice { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PredictionSliceArgs<'args>
  ) -> flatbuffers::WIPOffset<PredictionSlice<'bldr>> {
    let mut builder = PredictionSliceBuilder::new(_fbb);
    if let Some(x) = args.physics { builder.add_physics(x); }
    builder.add_gameSeconds(args.gameSeconds);
    builder.finish()
  }


  /// The moment in game time that this prediction corresponds to.
  /// This corresponds to 'secondsElapsed' in the GameInfo table.
  #[inline]
  pub fn gameSeconds(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PredictionSlice::VT_GAMESECONDS, Some(0.0)).unwrap()}
  }
  /// The predicted location and motion of the object.
  #[inline]
  pub fn physics(&self) -> Option<Physics<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Physics>>(PredictionSlice::VT_PHYSICS, None)}
  }
}

impl flatbuffers::Verifiable for PredictionSlice<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Physics>>("physics", Self::VT_PHYSICS, false)?
     .finish();
    Ok(())
  }
}
pub struct PredictionSliceArgs<'a> {
    pub gameSeconds: f32,
    pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
}
impl<'a> Default for PredictionSliceArgs<'a> {
  #[inline]
  fn default() -> Self {
    PredictionSliceArgs {
      gameSeconds: 0.0,
      physics: None,
    }
  }
}

pub struct PredictionSliceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PredictionSliceBuilder<'a, 'b> {
  #[inline]
  pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
    self.fbb_.push_slot::<f32>(PredictionSlice::VT_GAMESECONDS, gameSeconds, 0.0);
  }
  #[inline]
  pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Physics>>(PredictionSlice::VT_PHYSICS, physics);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PredictionSliceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PredictionSliceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PredictionSlice<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PredictionSlice<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PredictionSlice");
      ds.field("gameSeconds", &self.gameSeconds());
      ds.field("physics", &self.physics());
      ds.finish()
  }
}
pub enum BallPredictionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BallPrediction<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BallPrediction<'a> {
  type Inner = BallPrediction<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BallPrediction<'a> {
  pub const VT_SLICES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BallPrediction { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BallPredictionArgs<'args>
  ) -> flatbuffers::WIPOffset<BallPrediction<'bldr>> {
    let mut builder = BallPredictionBuilder::new(_fbb);
    if let Some(x) = args.slices { builder.add_slices(x); }
    builder.finish()
  }


  /// A list of places the ball will be at specific times in the future.
  /// It is guaranteed to sorted so that time increases with each slice.
  /// It is NOT guaranteed to have a consistent amount of time between slices.
  #[inline]
  pub fn slices(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice>>>>(BallPrediction::VT_SLICES, None)}
  }
}

impl flatbuffers::Verifiable for BallPrediction<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PredictionSlice>>>>("slices", Self::VT_SLICES, false)?
     .finish();
    Ok(())
  }
}
pub struct BallPredictionArgs<'a> {
    pub slices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>>>,
}
impl<'a> Default for BallPredictionArgs<'a> {
  #[inline]
  fn default() -> Self {
    BallPredictionArgs {
      slices: None,
    }
  }
}

pub struct BallPredictionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BallPredictionBuilder<'a, 'b> {
  #[inline]
  pub fn add_slices(&mut self, slices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PredictionSlice<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BallPrediction::VT_SLICES, slices);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BallPredictionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BallPredictionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BallPrediction<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BallPrediction<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BallPrediction");
      ds.field("slices", &self.slices());
      ds.finish()
  }
}
pub enum RLBotPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A bot controlled by the RLBot framework
pub struct RLBotPlayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RLBotPlayer<'a> {
  type Inner = RLBotPlayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RLBotPlayer<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RLBotPlayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RLBotPlayerArgs
  ) -> flatbuffers::WIPOffset<RLBotPlayer<'bldr>> {
    let mut builder = RLBotPlayerBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for RLBotPlayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RLBotPlayerArgs {
}
impl<'a> Default for RLBotPlayerArgs {
  #[inline]
  fn default() -> Self {
    RLBotPlayerArgs {
    }
  }
}

pub struct RLBotPlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RLBotPlayerBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RLBotPlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RLBotPlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RLBotPlayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RLBotPlayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RLBotPlayer");
      ds.finish()
  }
}
pub enum HumanPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A normal human player
pub struct HumanPlayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HumanPlayer<'a> {
  type Inner = HumanPlayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HumanPlayer<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HumanPlayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HumanPlayerArgs
  ) -> flatbuffers::WIPOffset<HumanPlayer<'bldr>> {
    let mut builder = HumanPlayerBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for HumanPlayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HumanPlayerArgs {
}
impl<'a> Default for HumanPlayerArgs {
  #[inline]
  fn default() -> Self {
    HumanPlayerArgs {
    }
  }
}

pub struct HumanPlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HumanPlayerBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HumanPlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HumanPlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HumanPlayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HumanPlayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HumanPlayer");
      ds.finish()
  }
}
pub enum PsyonixBotPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A psyonix bot, e.g. All Star bot
pub struct PsyonixBotPlayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PsyonixBotPlayer<'a> {
  type Inner = PsyonixBotPlayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PsyonixBotPlayer<'a> {
  pub const VT_BOTSKILL: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PsyonixBotPlayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PsyonixBotPlayerArgs
  ) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'bldr>> {
    let mut builder = PsyonixBotPlayerBuilder::new(_fbb);
    builder.add_botSkill(args.botSkill);
    builder.finish()
  }


  #[inline]
  pub fn botSkill(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PsyonixBotPlayer::VT_BOTSKILL, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PsyonixBotPlayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("botSkill", Self::VT_BOTSKILL, false)?
     .finish();
    Ok(())
  }
}
pub struct PsyonixBotPlayerArgs {
    pub botSkill: f32,
}
impl<'a> Default for PsyonixBotPlayerArgs {
  #[inline]
  fn default() -> Self {
    PsyonixBotPlayerArgs {
      botSkill: 0.0,
    }
  }
}

pub struct PsyonixBotPlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PsyonixBotPlayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_botSkill(&mut self, botSkill: f32) {
    self.fbb_.push_slot::<f32>(PsyonixBotPlayer::VT_BOTSKILL, botSkill, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PsyonixBotPlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PsyonixBotPlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PsyonixBotPlayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PsyonixBotPlayer");
      ds.field("botSkill", &self.botSkill());
      ds.finish()
  }
}
pub enum PartyMemberBotPlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

/// A player that Rocket League treats as human, e.g. has a dedicated camera and can do training mode,
/// but is actually controlled by a bot.
pub struct PartyMemberBotPlayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PartyMemberBotPlayer<'a> {
  type Inner = PartyMemberBotPlayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PartyMemberBotPlayer<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PartyMemberBotPlayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PartyMemberBotPlayerArgs
  ) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'bldr>> {
    let mut builder = PartyMemberBotPlayerBuilder::new(_fbb);
    builder.finish()
  }

}

impl flatbuffers::Verifiable for PartyMemberBotPlayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PartyMemberBotPlayerArgs {
}
impl<'a> Default for PartyMemberBotPlayerArgs {
  #[inline]
  fn default() -> Self {
    PartyMemberBotPlayerArgs {
    }
  }
}

pub struct PartyMemberBotPlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PartyMemberBotPlayerBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PartyMemberBotPlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PartyMemberBotPlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PartyMemberBotPlayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PartyMemberBotPlayer");
      ds.finish()
  }
}
pub enum PlayerLoadoutOffset {}
#[derive(Copy, Clone, PartialEq)]

/// The car type, color, and other aspects of the player's appearance.
/// See https://github.com/RLBot/RLBot/wiki/Bot-Customization
pub struct PlayerLoadout<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerLoadout<'a> {
  type Inner = PlayerLoadout<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerLoadout<'a> {
  pub const VT_TEAMCOLORID: flatbuffers::VOffsetT = 4;
  pub const VT_CUSTOMCOLORID: flatbuffers::VOffsetT = 6;
  pub const VT_CARID: flatbuffers::VOffsetT = 8;
  pub const VT_DECALID: flatbuffers::VOffsetT = 10;
  pub const VT_WHEELSID: flatbuffers::VOffsetT = 12;
  pub const VT_BOOSTID: flatbuffers::VOffsetT = 14;
  pub const VT_ANTENNAID: flatbuffers::VOffsetT = 16;
  pub const VT_HATID: flatbuffers::VOffsetT = 18;
  pub const VT_PAINTFINISHID: flatbuffers::VOffsetT = 20;
  pub const VT_CUSTOMFINISHID: flatbuffers::VOffsetT = 22;
  pub const VT_ENGINEAUDIOID: flatbuffers::VOffsetT = 24;
  pub const VT_TRAILSID: flatbuffers::VOffsetT = 26;
  pub const VT_GOALEXPLOSIONID: flatbuffers::VOffsetT = 28;
  pub const VT_LOADOUTPAINT: flatbuffers::VOffsetT = 30;
  pub const VT_PRIMARYCOLORLOOKUP: flatbuffers::VOffsetT = 32;
  pub const VT_SECONDARYCOLORLOOKUP: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerLoadout { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerLoadoutArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerLoadout<'bldr>> {
    let mut builder = PlayerLoadoutBuilder::new(_fbb);
    if let Some(x) = args.secondaryColorLookup { builder.add_secondaryColorLookup(x); }
    if let Some(x) = args.primaryColorLookup { builder.add_primaryColorLookup(x); }
    if let Some(x) = args.loadoutPaint { builder.add_loadoutPaint(x); }
    builder.add_goalExplosionId(args.goalExplosionId);
    builder.add_trailsId(args.trailsId);
    builder.add_engineAudioId(args.engineAudioId);
    builder.add_customFinishId(args.customFinishId);
    builder.add_paintFinishId(args.paintFinishId);
    builder.add_hatId(args.hatId);
    builder.add_antennaId(args.antennaId);
    builder.add_boostId(args.boostId);
    builder.add_wheelsId(args.wheelsId);
    builder.add_decalId(args.decalId);
    builder.add_carId(args.carId);
    builder.add_customColorId(args.customColorId);
    builder.add_teamColorId(args.teamColorId);
    builder.finish()
  }


  #[inline]
  pub fn teamColorId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_TEAMCOLORID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn customColorId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn carId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_CARID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn decalId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_DECALID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn wheelsId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_WHEELSID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn boostId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_BOOSTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn antennaId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_ANTENNAID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hatId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_HATID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn paintFinishId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_PAINTFINISHID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn customFinishId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn engineAudioId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn trailsId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_TRAILSID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn goalExplosionId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn loadoutPaint(&self) -> Option<LoadoutPaint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LoadoutPaint>>(PlayerLoadout::VT_LOADOUTPAINT, None)}
  }
  /// Sets the primary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides teamColorId.
  #[inline]
  pub fn primaryColorLookup(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(PlayerLoadout::VT_PRIMARYCOLORLOOKUP, None)}
  }
  /// Sets the secondary color of the car to the swatch that most closely matches the provided
  /// RGB color value. If set, this overrides customColorId.
  #[inline]
  pub fn secondaryColorLookup(&self) -> Option<Color<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(PlayerLoadout::VT_SECONDARYCOLORLOOKUP, None)}
  }
}

impl flatbuffers::Verifiable for PlayerLoadout<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("teamColorId", Self::VT_TEAMCOLORID, false)?
     .visit_field::<i32>("customColorId", Self::VT_CUSTOMCOLORID, false)?
     .visit_field::<i32>("carId", Self::VT_CARID, false)?
     .visit_field::<i32>("decalId", Self::VT_DECALID, false)?
     .visit_field::<i32>("wheelsId", Self::VT_WHEELSID, false)?
     .visit_field::<i32>("boostId", Self::VT_BOOSTID, false)?
     .visit_field::<i32>("antennaId", Self::VT_ANTENNAID, false)?
     .visit_field::<i32>("hatId", Self::VT_HATID, false)?
     .visit_field::<i32>("paintFinishId", Self::VT_PAINTFINISHID, false)?
     .visit_field::<i32>("customFinishId", Self::VT_CUSTOMFINISHID, false)?
     .visit_field::<i32>("engineAudioId", Self::VT_ENGINEAUDIOID, false)?
     .visit_field::<i32>("trailsId", Self::VT_TRAILSID, false)?
     .visit_field::<i32>("goalExplosionId", Self::VT_GOALEXPLOSIONID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LoadoutPaint>>("loadoutPaint", Self::VT_LOADOUTPAINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("primaryColorLookup", Self::VT_PRIMARYCOLORLOOKUP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Color>>("secondaryColorLookup", Self::VT_SECONDARYCOLORLOOKUP, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerLoadoutArgs<'a> {
    pub teamColorId: i32,
    pub customColorId: i32,
    pub carId: i32,
    pub decalId: i32,
    pub wheelsId: i32,
    pub boostId: i32,
    pub antennaId: i32,
    pub hatId: i32,
    pub paintFinishId: i32,
    pub customFinishId: i32,
    pub engineAudioId: i32,
    pub trailsId: i32,
    pub goalExplosionId: i32,
    pub loadoutPaint: Option<flatbuffers::WIPOffset<LoadoutPaint<'a>>>,
    pub primaryColorLookup: Option<flatbuffers::WIPOffset<Color<'a>>>,
    pub secondaryColorLookup: Option<flatbuffers::WIPOffset<Color<'a>>>,
}
impl<'a> Default for PlayerLoadoutArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerLoadoutArgs {
      teamColorId: 0,
      customColorId: 0,
      carId: 0,
      decalId: 0,
      wheelsId: 0,
      boostId: 0,
      antennaId: 0,
      hatId: 0,
      paintFinishId: 0,
      customFinishId: 0,
      engineAudioId: 0,
      trailsId: 0,
      goalExplosionId: 0,
      loadoutPaint: None,
      primaryColorLookup: None,
      secondaryColorLookup: None,
    }
  }
}

pub struct PlayerLoadoutBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerLoadoutBuilder<'a, 'b> {
  #[inline]
  pub fn add_teamColorId(&mut self, teamColorId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_TEAMCOLORID, teamColorId, 0);
  }
  #[inline]
  pub fn add_customColorId(&mut self, customColorId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, customColorId, 0);
  }
  #[inline]
  pub fn add_carId(&mut self, carId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_CARID, carId, 0);
  }
  #[inline]
  pub fn add_decalId(&mut self, decalId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_DECALID, decalId, 0);
  }
  #[inline]
  pub fn add_wheelsId(&mut self, wheelsId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_WHEELSID, wheelsId, 0);
  }
  #[inline]
  pub fn add_boostId(&mut self, boostId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_BOOSTID, boostId, 0);
  }
  #[inline]
  pub fn add_antennaId(&mut self, antennaId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_ANTENNAID, antennaId, 0);
  }
  #[inline]
  pub fn add_hatId(&mut self, hatId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_HATID, hatId, 0);
  }
  #[inline]
  pub fn add_paintFinishId(&mut self, paintFinishId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_PAINTFINISHID, paintFinishId, 0);
  }
  #[inline]
  pub fn add_customFinishId(&mut self, customFinishId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, customFinishId, 0);
  }
  #[inline]
  pub fn add_engineAudioId(&mut self, engineAudioId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, engineAudioId, 0);
  }
  #[inline]
  pub fn add_trailsId(&mut self, trailsId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_TRAILSID, trailsId, 0);
  }
  #[inline]
  pub fn add_goalExplosionId(&mut self, goalExplosionId: i32) {
    self.fbb_.push_slot::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, goalExplosionId, 0);
  }
  #[inline]
  pub fn add_loadoutPaint(&mut self, loadoutPaint: flatbuffers::WIPOffset<LoadoutPaint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LoadoutPaint>>(PlayerLoadout::VT_LOADOUTPAINT, loadoutPaint);
  }
  #[inline]
  pub fn add_primaryColorLookup(&mut self, primaryColorLookup: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(PlayerLoadout::VT_PRIMARYCOLORLOOKUP, primaryColorLookup);
  }
  #[inline]
  pub fn add_secondaryColorLookup(&mut self, secondaryColorLookup: flatbuffers::WIPOffset<Color<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(PlayerLoadout::VT_SECONDARYCOLORLOOKUP, secondaryColorLookup);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerLoadoutBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerLoadoutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerLoadout<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerLoadout<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerLoadout");
      ds.field("teamColorId", &self.teamColorId());
      ds.field("customColorId", &self.customColorId());
      ds.field("carId", &self.carId());
      ds.field("decalId", &self.decalId());
      ds.field("wheelsId", &self.wheelsId());
      ds.field("boostId", &self.boostId());
      ds.field("antennaId", &self.antennaId());
      ds.field("hatId", &self.hatId());
      ds.field("paintFinishId", &self.paintFinishId());
      ds.field("customFinishId", &self.customFinishId());
      ds.field("engineAudioId", &self.engineAudioId());
      ds.field("trailsId", &self.trailsId());
      ds.field("goalExplosionId", &self.goalExplosionId());
      ds.field("loadoutPaint", &self.loadoutPaint());
      ds.field("primaryColorLookup", &self.primaryColorLookup());
      ds.field("secondaryColorLookup", &self.secondaryColorLookup());
      ds.finish()
  }
}
pub enum LoadoutPaintOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Specification for 'painted' items. See https://github.com/RLBot/RLBot/wiki/Bot-Customization
pub struct LoadoutPaint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadoutPaint<'a> {
  type Inner = LoadoutPaint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadoutPaint<'a> {
  pub const VT_CARPAINTID: flatbuffers::VOffsetT = 4;
  pub const VT_DECALPAINTID: flatbuffers::VOffsetT = 6;
  pub const VT_WHEELSPAINTID: flatbuffers::VOffsetT = 8;
  pub const VT_BOOSTPAINTID: flatbuffers::VOffsetT = 10;
  pub const VT_ANTENNAPAINTID: flatbuffers::VOffsetT = 12;
  pub const VT_HATPAINTID: flatbuffers::VOffsetT = 14;
  pub const VT_TRAILSPAINTID: flatbuffers::VOffsetT = 16;
  pub const VT_GOALEXPLOSIONPAINTID: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadoutPaint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LoadoutPaintArgs
  ) -> flatbuffers::WIPOffset<LoadoutPaint<'bldr>> {
    let mut builder = LoadoutPaintBuilder::new(_fbb);
    builder.add_goalExplosionPaintId(args.goalExplosionPaintId);
    builder.add_trailsPaintId(args.trailsPaintId);
    builder.add_hatPaintId(args.hatPaintId);
    builder.add_antennaPaintId(args.antennaPaintId);
    builder.add_boostPaintId(args.boostPaintId);
    builder.add_wheelsPaintId(args.wheelsPaintId);
    builder.add_decalPaintId(args.decalPaintId);
    builder.add_carPaintId(args.carPaintId);
    builder.finish()
  }


  #[inline]
  pub fn carPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_CARPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn decalPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_DECALPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn wheelsPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_WHEELSPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn boostPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_BOOSTPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn antennaPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hatPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_HATPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn trailsPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_TRAILSPAINTID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn goalExplosionPaintId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LoadoutPaint::VT_GOALEXPLOSIONPAINTID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadoutPaint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("carPaintId", Self::VT_CARPAINTID, false)?
     .visit_field::<i32>("decalPaintId", Self::VT_DECALPAINTID, false)?
     .visit_field::<i32>("wheelsPaintId", Self::VT_WHEELSPAINTID, false)?
     .visit_field::<i32>("boostPaintId", Self::VT_BOOSTPAINTID, false)?
     .visit_field::<i32>("antennaPaintId", Self::VT_ANTENNAPAINTID, false)?
     .visit_field::<i32>("hatPaintId", Self::VT_HATPAINTID, false)?
     .visit_field::<i32>("trailsPaintId", Self::VT_TRAILSPAINTID, false)?
     .visit_field::<i32>("goalExplosionPaintId", Self::VT_GOALEXPLOSIONPAINTID, false)?
     .finish();
    Ok(())
  }
}
pub struct LoadoutPaintArgs {
    pub carPaintId: i32,
    pub decalPaintId: i32,
    pub wheelsPaintId: i32,
    pub boostPaintId: i32,
    pub antennaPaintId: i32,
    pub hatPaintId: i32,
    pub trailsPaintId: i32,
    pub goalExplosionPaintId: i32,
}
impl<'a> Default for LoadoutPaintArgs {
  #[inline]
  fn default() -> Self {
    LoadoutPaintArgs {
      carPaintId: 0,
      decalPaintId: 0,
      wheelsPaintId: 0,
      boostPaintId: 0,
      antennaPaintId: 0,
      hatPaintId: 0,
      trailsPaintId: 0,
      goalExplosionPaintId: 0,
    }
  }
}

pub struct LoadoutPaintBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LoadoutPaintBuilder<'a, 'b> {
  #[inline]
  pub fn add_carPaintId(&mut self, carPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_CARPAINTID, carPaintId, 0);
  }
  #[inline]
  pub fn add_decalPaintId(&mut self, decalPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_DECALPAINTID, decalPaintId, 0);
  }
  #[inline]
  pub fn add_wheelsPaintId(&mut self, wheelsPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_WHEELSPAINTID, wheelsPaintId, 0);
  }
  #[inline]
  pub fn add_boostPaintId(&mut self, boostPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_BOOSTPAINTID, boostPaintId, 0);
  }
  #[inline]
  pub fn add_antennaPaintId(&mut self, antennaPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, antennaPaintId, 0);
  }
  #[inline]
  pub fn add_hatPaintId(&mut self, hatPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_HATPAINTID, hatPaintId, 0);
  }
  #[inline]
  pub fn add_trailsPaintId(&mut self, trailsPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_TRAILSPAINTID, trailsPaintId, 0);
  }
  #[inline]
  pub fn add_goalExplosionPaintId(&mut self, goalExplosionPaintId: i32) {
    self.fbb_.push_slot::<i32>(LoadoutPaint::VT_GOALEXPLOSIONPAINTID, goalExplosionPaintId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LoadoutPaintBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LoadoutPaintBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadoutPaint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadoutPaint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadoutPaint");
      ds.field("carPaintId", &self.carPaintId());
      ds.field("decalPaintId", &self.decalPaintId());
      ds.field("wheelsPaintId", &self.wheelsPaintId());
      ds.field("boostPaintId", &self.boostPaintId());
      ds.field("antennaPaintId", &self.antennaPaintId());
      ds.field("hatPaintId", &self.hatPaintId());
      ds.field("trailsPaintId", &self.trailsPaintId());
      ds.field("goalExplosionPaintId", &self.goalExplosionPaintId());
      ds.finish()
  }
}
pub enum PlayerConfigurationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayerConfiguration<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerConfiguration<'a> {
  type Inner = PlayerConfiguration<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerConfiguration<'a> {
  pub const VT_VARIETY_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_VARIETY: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;
  pub const VT_TEAM: flatbuffers::VOffsetT = 10;
  pub const VT_LOADOUT: flatbuffers::VOffsetT = 12;
  pub const VT_SPAWNID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerConfiguration { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerConfigurationArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerConfiguration<'bldr>> {
    let mut builder = PlayerConfigurationBuilder::new(_fbb);
    builder.add_spawnId(args.spawnId);
    if let Some(x) = args.loadout { builder.add_loadout(x); }
    builder.add_team(args.team);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.variety { builder.add_variety(x); }
    builder.add_variety_type(args.variety_type);
    builder.finish()
  }


  #[inline]
  pub fn variety_type(&self) -> PlayerClass {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PlayerClass>(PlayerConfiguration::VT_VARIETY_TYPE, Some(PlayerClass::NONE)).unwrap()}
  }
  #[inline]
  pub fn variety(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(PlayerConfiguration::VT_VARIETY, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlayerConfiguration::VT_NAME, None)}
  }
  #[inline]
  pub fn team(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerConfiguration::VT_TEAM, Some(0)).unwrap()}
  }
  #[inline]
  pub fn loadout(&self) -> Option<PlayerLoadout<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PlayerLoadout>>(PlayerConfiguration::VT_LOADOUT, None)}
  }
  /// In the case where the requested player index is not available, spawnId will help
  /// the framework figure out what index was actually assigned to this player instead.
  #[inline]
  pub fn spawnId(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerConfiguration::VT_SPAWNID, Some(0)).unwrap()}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn variety_as_rlbot_player(&self) -> Option<RLBotPlayer<'a>> {
    if self.variety_type() == PlayerClass::RLBotPlayer {
      self.variety().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { RLBotPlayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn variety_as_human_player(&self) -> Option<HumanPlayer<'a>> {
    if self.variety_type() == PlayerClass::HumanPlayer {
      self.variety().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { HumanPlayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn variety_as_psyonix_bot_player(&self) -> Option<PsyonixBotPlayer<'a>> {
    if self.variety_type() == PlayerClass::PsyonixBotPlayer {
      self.variety().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PsyonixBotPlayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn variety_as_party_member_bot_player(&self) -> Option<PartyMemberBotPlayer<'a>> {
    if self.variety_type() == PlayerClass::PartyMemberBotPlayer {
      self.variety().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PartyMemberBotPlayer::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for PlayerConfiguration<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<PlayerClass, _>("variety_type", Self::VT_VARIETY_TYPE, "variety", Self::VT_VARIETY, false, |key, v, pos| {
        match key {
          PlayerClass::RLBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RLBotPlayer>>("PlayerClass::RLBotPlayer", pos),
          PlayerClass::HumanPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HumanPlayer>>("PlayerClass::HumanPlayer", pos),
          PlayerClass::PsyonixBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PsyonixBotPlayer>>("PlayerClass::PsyonixBotPlayer", pos),
          PlayerClass::PartyMemberBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PartyMemberBotPlayer>>("PlayerClass::PartyMemberBotPlayer", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("team", Self::VT_TEAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PlayerLoadout>>("loadout", Self::VT_LOADOUT, false)?
     .visit_field::<i32>("spawnId", Self::VT_SPAWNID, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerConfigurationArgs<'a> {
    pub variety_type: PlayerClass,
    pub variety: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub team: i32,
    pub loadout: Option<flatbuffers::WIPOffset<PlayerLoadout<'a>>>,
    pub spawnId: i32,
}
impl<'a> Default for PlayerConfigurationArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerConfigurationArgs {
      variety_type: PlayerClass::NONE,
      variety: None,
      name: None,
      team: 0,
      loadout: None,
      spawnId: 0,
    }
  }
}

pub struct PlayerConfigurationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerConfigurationBuilder<'a, 'b> {
  #[inline]
  pub fn add_variety_type(&mut self, variety_type: PlayerClass) {
    self.fbb_.push_slot::<PlayerClass>(PlayerConfiguration::VT_VARIETY_TYPE, variety_type, PlayerClass::NONE);
  }
  #[inline]
  pub fn add_variety(&mut self, variety: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerConfiguration::VT_VARIETY, variety);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerConfiguration::VT_NAME, name);
  }
  #[inline]
  pub fn add_team(&mut self, team: i32) {
    self.fbb_.push_slot::<i32>(PlayerConfiguration::VT_TEAM, team, 0);
  }
  #[inline]
  pub fn add_loadout(&mut self, loadout: flatbuffers::WIPOffset<PlayerLoadout<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PlayerLoadout>>(PlayerConfiguration::VT_LOADOUT, loadout);
  }
  #[inline]
  pub fn add_spawnId(&mut self, spawnId: i32) {
    self.fbb_.push_slot::<i32>(PlayerConfiguration::VT_SPAWNID, spawnId, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerConfigurationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerConfigurationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerConfiguration<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerConfiguration<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerConfiguration");
      ds.field("variety_type", &self.variety_type());
      match self.variety_type() {
        PlayerClass::RLBotPlayer => {
          if let Some(x) = self.variety_as_rlbot_player() {
            ds.field("variety", &x)
          } else {
            ds.field("variety", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlayerClass::HumanPlayer => {
          if let Some(x) = self.variety_as_human_player() {
            ds.field("variety", &x)
          } else {
            ds.field("variety", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlayerClass::PsyonixBotPlayer => {
          if let Some(x) = self.variety_as_psyonix_bot_player() {
            ds.field("variety", &x)
          } else {
            ds.field("variety", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        PlayerClass::PartyMemberBotPlayer => {
          if let Some(x) = self.variety_as_party_member_bot_player() {
            ds.field("variety", &x)
          } else {
            ds.field("variety", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("variety", &x)
        },
      };
      ds.field("name", &self.name());
      ds.field("team", &self.team());
      ds.field("loadout", &self.loadout());
      ds.field("spawnId", &self.spawnId());
      ds.finish()
  }
}
pub enum MutatorSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MutatorSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MutatorSettings<'a> {
  type Inner = MutatorSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MutatorSettings<'a> {
  pub const VT_MATCHLENGTH: flatbuffers::VOffsetT = 4;
  pub const VT_MAXSCORE: flatbuffers::VOffsetT = 6;
  pub const VT_OVERTIMEOPTION: flatbuffers::VOffsetT = 8;
  pub const VT_SERIESLENGTHOPTION: flatbuffers::VOffsetT = 10;
  pub const VT_GAMESPEEDOPTION: flatbuffers::VOffsetT = 12;
  pub const VT_BALLMAXSPEEDOPTION: flatbuffers::VOffsetT = 14;
  pub const VT_BALLTYPEOPTION: flatbuffers::VOffsetT = 16;
  pub const VT_BALLWEIGHTOPTION: flatbuffers::VOffsetT = 18;
  pub const VT_BALLSIZEOPTION: flatbuffers::VOffsetT = 20;
  pub const VT_BALLBOUNCINESSOPTION: flatbuffers::VOffsetT = 22;
  pub const VT_BOOSTOPTION: flatbuffers::VOffsetT = 24;
  pub const VT_RUMBLEOPTION: flatbuffers::VOffsetT = 26;
  pub const VT_BOOSTSTRENGTHOPTION: flatbuffers::VOffsetT = 28;
  pub const VT_GRAVITYOPTION: flatbuffers::VOffsetT = 30;
  pub const VT_DEMOLISHOPTION: flatbuffers::VOffsetT = 32;
  pub const VT_RESPAWNTIMEOPTION: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MutatorSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MutatorSettingsArgs
  ) -> flatbuffers::WIPOffset<MutatorSettings<'bldr>> {
    let mut builder = MutatorSettingsBuilder::new(_fbb);
    builder.add_respawnTimeOption(args.respawnTimeOption);
    builder.add_demolishOption(args.demolishOption);
    builder.add_gravityOption(args.gravityOption);
    builder.add_boostStrengthOption(args.boostStrengthOption);
    builder.add_rumbleOption(args.rumbleOption);
    builder.add_boostOption(args.boostOption);
    builder.add_ballBouncinessOption(args.ballBouncinessOption);
    builder.add_ballSizeOption(args.ballSizeOption);
    builder.add_ballWeightOption(args.ballWeightOption);
    builder.add_ballTypeOption(args.ballTypeOption);
    builder.add_ballMaxSpeedOption(args.ballMaxSpeedOption);
    builder.add_gameSpeedOption(args.gameSpeedOption);
    builder.add_seriesLengthOption(args.seriesLengthOption);
    builder.add_overtimeOption(args.overtimeOption);
    builder.add_maxScore(args.maxScore);
    builder.add_matchLength(args.matchLength);
    builder.finish()
  }


  #[inline]
  pub fn matchLength(&self) -> MatchLength {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MatchLength>(MutatorSettings::VT_MATCHLENGTH, Some(MatchLength::Five_Minutes)).unwrap()}
  }
  #[inline]
  pub fn maxScore(&self) -> MaxScore {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MaxScore>(MutatorSettings::VT_MAXSCORE, Some(MaxScore::Unlimited)).unwrap()}
  }
  #[inline]
  pub fn overtimeOption(&self) -> OvertimeOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OvertimeOption>(MutatorSettings::VT_OVERTIMEOPTION, Some(OvertimeOption::Unlimited)).unwrap()}
  }
  #[inline]
  pub fn seriesLengthOption(&self) -> SeriesLengthOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SeriesLengthOption>(MutatorSettings::VT_SERIESLENGTHOPTION, Some(SeriesLengthOption::Unlimited)).unwrap()}
  }
  #[inline]
  pub fn gameSpeedOption(&self) -> GameSpeedOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameSpeedOption>(MutatorSettings::VT_GAMESPEEDOPTION, Some(GameSpeedOption::Default)).unwrap()}
  }
  #[inline]
  pub fn ballMaxSpeedOption(&self) -> BallMaxSpeedOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BallMaxSpeedOption>(MutatorSettings::VT_BALLMAXSPEEDOPTION, Some(BallMaxSpeedOption::Default)).unwrap()}
  }
  #[inline]
  pub fn ballTypeOption(&self) -> BallTypeOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BallTypeOption>(MutatorSettings::VT_BALLTYPEOPTION, Some(BallTypeOption::Default)).unwrap()}
  }
  #[inline]
  pub fn ballWeightOption(&self) -> BallWeightOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BallWeightOption>(MutatorSettings::VT_BALLWEIGHTOPTION, Some(BallWeightOption::Default)).unwrap()}
  }
  #[inline]
  pub fn ballSizeOption(&self) -> BallSizeOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BallSizeOption>(MutatorSettings::VT_BALLSIZEOPTION, Some(BallSizeOption::Default)).unwrap()}
  }
  #[inline]
  pub fn ballBouncinessOption(&self) -> BallBouncinessOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BallBouncinessOption>(MutatorSettings::VT_BALLBOUNCINESSOPTION, Some(BallBouncinessOption::Default)).unwrap()}
  }
  #[inline]
  pub fn boostOption(&self) -> BoostOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BoostOption>(MutatorSettings::VT_BOOSTOPTION, Some(BoostOption::Normal_Boost)).unwrap()}
  }
  #[inline]
  pub fn rumbleOption(&self) -> RumbleOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RumbleOption>(MutatorSettings::VT_RUMBLEOPTION, Some(RumbleOption::No_Rumble)).unwrap()}
  }
  #[inline]
  pub fn boostStrengthOption(&self) -> BoostStrengthOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BoostStrengthOption>(MutatorSettings::VT_BOOSTSTRENGTHOPTION, Some(BoostStrengthOption::One)).unwrap()}
  }
  #[inline]
  pub fn gravityOption(&self) -> GravityOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GravityOption>(MutatorSettings::VT_GRAVITYOPTION, Some(GravityOption::Default)).unwrap()}
  }
  #[inline]
  pub fn demolishOption(&self) -> DemolishOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DemolishOption>(MutatorSettings::VT_DEMOLISHOPTION, Some(DemolishOption::Default)).unwrap()}
  }
  #[inline]
  pub fn respawnTimeOption(&self) -> RespawnTimeOption {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RespawnTimeOption>(MutatorSettings::VT_RESPAWNTIMEOPTION, Some(RespawnTimeOption::Three_Seconds)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MutatorSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MatchLength>("matchLength", Self::VT_MATCHLENGTH, false)?
     .visit_field::<MaxScore>("maxScore", Self::VT_MAXSCORE, false)?
     .visit_field::<OvertimeOption>("overtimeOption", Self::VT_OVERTIMEOPTION, false)?
     .visit_field::<SeriesLengthOption>("seriesLengthOption", Self::VT_SERIESLENGTHOPTION, false)?
     .visit_field::<GameSpeedOption>("gameSpeedOption", Self::VT_GAMESPEEDOPTION, false)?
     .visit_field::<BallMaxSpeedOption>("ballMaxSpeedOption", Self::VT_BALLMAXSPEEDOPTION, false)?
     .visit_field::<BallTypeOption>("ballTypeOption", Self::VT_BALLTYPEOPTION, false)?
     .visit_field::<BallWeightOption>("ballWeightOption", Self::VT_BALLWEIGHTOPTION, false)?
     .visit_field::<BallSizeOption>("ballSizeOption", Self::VT_BALLSIZEOPTION, false)?
     .visit_field::<BallBouncinessOption>("ballBouncinessOption", Self::VT_BALLBOUNCINESSOPTION, false)?
     .visit_field::<BoostOption>("boostOption", Self::VT_BOOSTOPTION, false)?
     .visit_field::<RumbleOption>("rumbleOption", Self::VT_RUMBLEOPTION, false)?
     .visit_field::<BoostStrengthOption>("boostStrengthOption", Self::VT_BOOSTSTRENGTHOPTION, false)?
     .visit_field::<GravityOption>("gravityOption", Self::VT_GRAVITYOPTION, false)?
     .visit_field::<DemolishOption>("demolishOption", Self::VT_DEMOLISHOPTION, false)?
     .visit_field::<RespawnTimeOption>("respawnTimeOption", Self::VT_RESPAWNTIMEOPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct MutatorSettingsArgs {
    pub matchLength: MatchLength,
    pub maxScore: MaxScore,
    pub overtimeOption: OvertimeOption,
    pub seriesLengthOption: SeriesLengthOption,
    pub gameSpeedOption: GameSpeedOption,
    pub ballMaxSpeedOption: BallMaxSpeedOption,
    pub ballTypeOption: BallTypeOption,
    pub ballWeightOption: BallWeightOption,
    pub ballSizeOption: BallSizeOption,
    pub ballBouncinessOption: BallBouncinessOption,
    pub boostOption: BoostOption,
    pub rumbleOption: RumbleOption,
    pub boostStrengthOption: BoostStrengthOption,
    pub gravityOption: GravityOption,
    pub demolishOption: DemolishOption,
    pub respawnTimeOption: RespawnTimeOption,
}
impl<'a> Default for MutatorSettingsArgs {
  #[inline]
  fn default() -> Self {
    MutatorSettingsArgs {
      matchLength: MatchLength::Five_Minutes,
      maxScore: MaxScore::Unlimited,
      overtimeOption: OvertimeOption::Unlimited,
      seriesLengthOption: SeriesLengthOption::Unlimited,
      gameSpeedOption: GameSpeedOption::Default,
      ballMaxSpeedOption: BallMaxSpeedOption::Default,
      ballTypeOption: BallTypeOption::Default,
      ballWeightOption: BallWeightOption::Default,
      ballSizeOption: BallSizeOption::Default,
      ballBouncinessOption: BallBouncinessOption::Default,
      boostOption: BoostOption::Normal_Boost,
      rumbleOption: RumbleOption::No_Rumble,
      boostStrengthOption: BoostStrengthOption::One,
      gravityOption: GravityOption::Default,
      demolishOption: DemolishOption::Default,
      respawnTimeOption: RespawnTimeOption::Three_Seconds,
    }
  }
}

pub struct MutatorSettingsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MutatorSettingsBuilder<'a, 'b> {
  #[inline]
  pub fn add_matchLength(&mut self, matchLength: MatchLength) {
    self.fbb_.push_slot::<MatchLength>(MutatorSettings::VT_MATCHLENGTH, matchLength, MatchLength::Five_Minutes);
  }
  #[inline]
  pub fn add_maxScore(&mut self, maxScore: MaxScore) {
    self.fbb_.push_slot::<MaxScore>(MutatorSettings::VT_MAXSCORE, maxScore, MaxScore::Unlimited);
  }
  #[inline]
  pub fn add_overtimeOption(&mut self, overtimeOption: OvertimeOption) {
    self.fbb_.push_slot::<OvertimeOption>(MutatorSettings::VT_OVERTIMEOPTION, overtimeOption, OvertimeOption::Unlimited);
  }
  #[inline]
  pub fn add_seriesLengthOption(&mut self, seriesLengthOption: SeriesLengthOption) {
    self.fbb_.push_slot::<SeriesLengthOption>(MutatorSettings::VT_SERIESLENGTHOPTION, seriesLengthOption, SeriesLengthOption::Unlimited);
  }
  #[inline]
  pub fn add_gameSpeedOption(&mut self, gameSpeedOption: GameSpeedOption) {
    self.fbb_.push_slot::<GameSpeedOption>(MutatorSettings::VT_GAMESPEEDOPTION, gameSpeedOption, GameSpeedOption::Default);
  }
  #[inline]
  pub fn add_ballMaxSpeedOption(&mut self, ballMaxSpeedOption: BallMaxSpeedOption) {
    self.fbb_.push_slot::<BallMaxSpeedOption>(MutatorSettings::VT_BALLMAXSPEEDOPTION, ballMaxSpeedOption, BallMaxSpeedOption::Default);
  }
  #[inline]
  pub fn add_ballTypeOption(&mut self, ballTypeOption: BallTypeOption) {
    self.fbb_.push_slot::<BallTypeOption>(MutatorSettings::VT_BALLTYPEOPTION, ballTypeOption, BallTypeOption::Default);
  }
  #[inline]
  pub fn add_ballWeightOption(&mut self, ballWeightOption: BallWeightOption) {
    self.fbb_.push_slot::<BallWeightOption>(MutatorSettings::VT_BALLWEIGHTOPTION, ballWeightOption, BallWeightOption::Default);
  }
  #[inline]
  pub fn add_ballSizeOption(&mut self, ballSizeOption: BallSizeOption) {
    self.fbb_.push_slot::<BallSizeOption>(MutatorSettings::VT_BALLSIZEOPTION, ballSizeOption, BallSizeOption::Default);
  }
  #[inline]
  pub fn add_ballBouncinessOption(&mut self, ballBouncinessOption: BallBouncinessOption) {
    self.fbb_.push_slot::<BallBouncinessOption>(MutatorSettings::VT_BALLBOUNCINESSOPTION, ballBouncinessOption, BallBouncinessOption::Default);
  }
  #[inline]
  pub fn add_boostOption(&mut self, boostOption: BoostOption) {
    self.fbb_.push_slot::<BoostOption>(MutatorSettings::VT_BOOSTOPTION, boostOption, BoostOption::Normal_Boost);
  }
  #[inline]
  pub fn add_rumbleOption(&mut self, rumbleOption: RumbleOption) {
    self.fbb_.push_slot::<RumbleOption>(MutatorSettings::VT_RUMBLEOPTION, rumbleOption, RumbleOption::No_Rumble);
  }
  #[inline]
  pub fn add_boostStrengthOption(&mut self, boostStrengthOption: BoostStrengthOption) {
    self.fbb_.push_slot::<BoostStrengthOption>(MutatorSettings::VT_BOOSTSTRENGTHOPTION, boostStrengthOption, BoostStrengthOption::One);
  }
  #[inline]
  pub fn add_gravityOption(&mut self, gravityOption: GravityOption) {
    self.fbb_.push_slot::<GravityOption>(MutatorSettings::VT_GRAVITYOPTION, gravityOption, GravityOption::Default);
  }
  #[inline]
  pub fn add_demolishOption(&mut self, demolishOption: DemolishOption) {
    self.fbb_.push_slot::<DemolishOption>(MutatorSettings::VT_DEMOLISHOPTION, demolishOption, DemolishOption::Default);
  }
  #[inline]
  pub fn add_respawnTimeOption(&mut self, respawnTimeOption: RespawnTimeOption) {
    self.fbb_.push_slot::<RespawnTimeOption>(MutatorSettings::VT_RESPAWNTIMEOPTION, respawnTimeOption, RespawnTimeOption::Three_Seconds);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MutatorSettingsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MutatorSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MutatorSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MutatorSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MutatorSettings");
      ds.field("matchLength", &self.matchLength());
      ds.field("maxScore", &self.maxScore());
      ds.field("overtimeOption", &self.overtimeOption());
      ds.field("seriesLengthOption", &self.seriesLengthOption());
      ds.field("gameSpeedOption", &self.gameSpeedOption());
      ds.field("ballMaxSpeedOption", &self.ballMaxSpeedOption());
      ds.field("ballTypeOption", &self.ballTypeOption());
      ds.field("ballWeightOption", &self.ballWeightOption());
      ds.field("ballSizeOption", &self.ballSizeOption());
      ds.field("ballBouncinessOption", &self.ballBouncinessOption());
      ds.field("boostOption", &self.boostOption());
      ds.field("rumbleOption", &self.rumbleOption());
      ds.field("boostStrengthOption", &self.boostStrengthOption());
      ds.field("gravityOption", &self.gravityOption());
      ds.field("demolishOption", &self.demolishOption());
      ds.field("respawnTimeOption", &self.respawnTimeOption());
      ds.finish()
  }
}
pub enum MatchSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatchSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatchSettings<'a> {
  type Inner = MatchSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MatchSettings<'a> {
  pub const VT_PLAYERCONFIGURATIONS: flatbuffers::VOffsetT = 4;
  pub const VT_GAMEMODE: flatbuffers::VOffsetT = 6;
  pub const VT_GAMEMAP: flatbuffers::VOffsetT = 8;
  pub const VT_SKIPREPLAYS: flatbuffers::VOffsetT = 10;
  pub const VT_INSTANTSTART: flatbuffers::VOffsetT = 12;
  pub const VT_MUTATORSETTINGS: flatbuffers::VOffsetT = 14;
  pub const VT_EXISTINGMATCHBEHAVIOR: flatbuffers::VOffsetT = 16;
  pub const VT_ENABLELOCKSTEP: flatbuffers::VOffsetT = 18;
  pub const VT_ENABLERENDERING: flatbuffers::VOffsetT = 20;
  pub const VT_ENABLESTATESETTING: flatbuffers::VOffsetT = 22;
  pub const VT_AUTOSAVEREPLAY: flatbuffers::VOffsetT = 24;
  pub const VT_GAMEMAPUPK: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatchSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MatchSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<MatchSettings<'bldr>> {
    let mut builder = MatchSettingsBuilder::new(_fbb);
    if let Some(x) = args.gameMapUpk { builder.add_gameMapUpk(x); }
    if let Some(x) = args.mutatorSettings { builder.add_mutatorSettings(x); }
    if let Some(x) = args.playerConfigurations { builder.add_playerConfigurations(x); }
    builder.add_autoSaveReplay(args.autoSaveReplay);
    builder.add_enableStateSetting(args.enableStateSetting);
    builder.add_enableRendering(args.enableRendering);
    builder.add_enableLockstep(args.enableLockstep);
    builder.add_existingMatchBehavior(args.existingMatchBehavior);
    builder.add_instantStart(args.instantStart);
    builder.add_skipReplays(args.skipReplays);
    builder.add_gameMap(args.gameMap);
    builder.add_gameMode(args.gameMode);
    builder.finish()
  }


  #[inline]
  pub fn playerConfigurations(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration>>>>(MatchSettings::VT_PLAYERCONFIGURATIONS, None)}
  }
  #[inline]
  pub fn gameMode(&self) -> GameMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameMode>(MatchSettings::VT_GAMEMODE, Some(GameMode::Soccer)).unwrap()}
  }
  #[inline]
  pub fn gameMap(&self) -> GameMap {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameMap>(MatchSettings::VT_GAMEMAP, Some(GameMap::DFHStadium)).unwrap()}
  }
  #[inline]
  pub fn skipReplays(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_SKIPREPLAYS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn instantStart(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_INSTANTSTART, Some(false)).unwrap()}
  }
  #[inline]
  pub fn mutatorSettings(&self) -> Option<MutatorSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<MutatorSettings>>(MatchSettings::VT_MUTATORSETTINGS, None)}
  }
  #[inline]
  pub fn existingMatchBehavior(&self) -> ExistingMatchBehavior {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ExistingMatchBehavior>(MatchSettings::VT_EXISTINGMATCHBEHAVIOR, Some(ExistingMatchBehavior::Restart_If_Different)).unwrap()}
  }
  #[inline]
  pub fn enableLockstep(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_ENABLELOCKSTEP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn enableRendering(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_ENABLERENDERING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn enableStateSetting(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_ENABLESTATESETTING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn autoSaveReplay(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MatchSettings::VT_AUTOSAVEREPLAY, Some(false)).unwrap()}
  }
  /// The name of a upk file, like UtopiaStadium_P, which should be loaded.
  /// If specified, this overrides gameMap. On Steam version of Rocket League,
  /// this can be used to load custom map files, but on Epic version it only
  /// works on the Psyonix maps. Still useful because maintaining the gameMap
  /// enum as new Psyonix maps are added is annoying.
  #[inline]
  pub fn gameMapUpk(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MatchSettings::VT_GAMEMAPUPK, None)}
  }
}

impl flatbuffers::Verifiable for MatchSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerConfiguration>>>>("playerConfigurations", Self::VT_PLAYERCONFIGURATIONS, false)?
     .visit_field::<GameMode>("gameMode", Self::VT_GAMEMODE, false)?
     .visit_field::<GameMap>("gameMap", Self::VT_GAMEMAP, false)?
     .visit_field::<bool>("skipReplays", Self::VT_SKIPREPLAYS, false)?
     .visit_field::<bool>("instantStart", Self::VT_INSTANTSTART, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<MutatorSettings>>("mutatorSettings", Self::VT_MUTATORSETTINGS, false)?
     .visit_field::<ExistingMatchBehavior>("existingMatchBehavior", Self::VT_EXISTINGMATCHBEHAVIOR, false)?
     .visit_field::<bool>("enableLockstep", Self::VT_ENABLELOCKSTEP, false)?
     .visit_field::<bool>("enableRendering", Self::VT_ENABLERENDERING, false)?
     .visit_field::<bool>("enableStateSetting", Self::VT_ENABLESTATESETTING, false)?
     .visit_field::<bool>("autoSaveReplay", Self::VT_AUTOSAVEREPLAY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("gameMapUpk", Self::VT_GAMEMAPUPK, false)?
     .finish();
    Ok(())
  }
}
pub struct MatchSettingsArgs<'a> {
    pub playerConfigurations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>>>,
    pub gameMode: GameMode,
    pub gameMap: GameMap,
    pub skipReplays: bool,
    pub instantStart: bool,
    pub mutatorSettings: Option<flatbuffers::WIPOffset<MutatorSettings<'a>>>,
    pub existingMatchBehavior: ExistingMatchBehavior,
    pub enableLockstep: bool,
    pub enableRendering: bool,
    pub enableStateSetting: bool,
    pub autoSaveReplay: bool,
    pub gameMapUpk: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MatchSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    MatchSettingsArgs {
      playerConfigurations: None,
      gameMode: GameMode::Soccer,
      gameMap: GameMap::DFHStadium,
      skipReplays: false,
      instantStart: false,
      mutatorSettings: None,
      existingMatchBehavior: ExistingMatchBehavior::Restart_If_Different,
      enableLockstep: false,
      enableRendering: false,
      enableStateSetting: false,
      autoSaveReplay: false,
      gameMapUpk: None,
    }
  }
}

pub struct MatchSettingsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatchSettingsBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerConfigurations(&mut self, playerConfigurations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PlayerConfiguration<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchSettings::VT_PLAYERCONFIGURATIONS, playerConfigurations);
  }
  #[inline]
  pub fn add_gameMode(&mut self, gameMode: GameMode) {
    self.fbb_.push_slot::<GameMode>(MatchSettings::VT_GAMEMODE, gameMode, GameMode::Soccer);
  }
  #[inline]
  pub fn add_gameMap(&mut self, gameMap: GameMap) {
    self.fbb_.push_slot::<GameMap>(MatchSettings::VT_GAMEMAP, gameMap, GameMap::DFHStadium);
  }
  #[inline]
  pub fn add_skipReplays(&mut self, skipReplays: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_SKIPREPLAYS, skipReplays, false);
  }
  #[inline]
  pub fn add_instantStart(&mut self, instantStart: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_INSTANTSTART, instantStart, false);
  }
  #[inline]
  pub fn add_mutatorSettings(&mut self, mutatorSettings: flatbuffers::WIPOffset<MutatorSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<MutatorSettings>>(MatchSettings::VT_MUTATORSETTINGS, mutatorSettings);
  }
  #[inline]
  pub fn add_existingMatchBehavior(&mut self, existingMatchBehavior: ExistingMatchBehavior) {
    self.fbb_.push_slot::<ExistingMatchBehavior>(MatchSettings::VT_EXISTINGMATCHBEHAVIOR, existingMatchBehavior, ExistingMatchBehavior::Restart_If_Different);
  }
  #[inline]
  pub fn add_enableLockstep(&mut self, enableLockstep: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_ENABLELOCKSTEP, enableLockstep, false);
  }
  #[inline]
  pub fn add_enableRendering(&mut self, enableRendering: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_ENABLERENDERING, enableRendering, false);
  }
  #[inline]
  pub fn add_enableStateSetting(&mut self, enableStateSetting: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_ENABLESTATESETTING, enableStateSetting, false);
  }
  #[inline]
  pub fn add_autoSaveReplay(&mut self, autoSaveReplay: bool) {
    self.fbb_.push_slot::<bool>(MatchSettings::VT_AUTOSAVEREPLAY, autoSaveReplay, false);
  }
  #[inline]
  pub fn add_gameMapUpk(&mut self, gameMapUpk: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MatchSettings::VT_GAMEMAPUPK, gameMapUpk);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatchSettingsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatchSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatchSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatchSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatchSettings");
      ds.field("playerConfigurations", &self.playerConfigurations());
      ds.field("gameMode", &self.gameMode());
      ds.field("gameMap", &self.gameMap());
      ds.field("skipReplays", &self.skipReplays());
      ds.field("instantStart", &self.instantStart());
      ds.field("mutatorSettings", &self.mutatorSettings());
      ds.field("existingMatchBehavior", &self.existingMatchBehavior());
      ds.field("enableLockstep", &self.enableLockstep());
      ds.field("enableRendering", &self.enableRendering());
      ds.field("enableStateSetting", &self.enableStateSetting());
      ds.field("autoSaveReplay", &self.autoSaveReplay());
      ds.field("gameMapUpk", &self.gameMapUpk());
      ds.finish()
  }
}
pub enum QuickChatMessagesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuickChatMessages<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuickChatMessages<'a> {
  type Inner = QuickChatMessages<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> QuickChatMessages<'a> {
  pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuickChatMessages { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args QuickChatMessagesArgs<'args>
  ) -> flatbuffers::WIPOffset<QuickChatMessages<'bldr>> {
    let mut builder = QuickChatMessagesBuilder::new(_fbb);
    if let Some(x) = args.messages { builder.add_messages(x); }
    builder.finish()
  }


  #[inline]
  pub fn messages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat>>>>(QuickChatMessages::VT_MESSAGES, None)}
  }
}

impl flatbuffers::Verifiable for QuickChatMessages<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<QuickChat>>>>("messages", Self::VT_MESSAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct QuickChatMessagesArgs<'a> {
    pub messages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat<'a>>>>>,
}
impl<'a> Default for QuickChatMessagesArgs<'a> {
  #[inline]
  fn default() -> Self {
    QuickChatMessagesArgs {
      messages: None,
    }
  }
}

pub struct QuickChatMessagesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuickChatMessagesBuilder<'a, 'b> {
  #[inline]
  pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<QuickChat<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuickChatMessages::VT_MESSAGES, messages);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuickChatMessagesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuickChatMessagesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuickChatMessages<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuickChatMessages<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuickChatMessages");
      ds.field("messages", &self.messages());
      ds.finish()
  }
}
pub enum ReadyMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Sent when connecting to RLBot to indicate what type of messages are desired.
/// This could be sent by a bot, or a bot manager governing several bots, an
/// overlay, or any other utility that connects to the RLBot process.
pub struct ReadyMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadyMessage<'a> {
  type Inner = ReadyMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ReadyMessage<'a> {
  pub const VT_WANTSBALLPREDICTIONS: flatbuffers::VOffsetT = 4;
  pub const VT_WANTSQUICKCHAT: flatbuffers::VOffsetT = 6;
  pub const VT_WANTSGAMEMESSAGES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReadyMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReadyMessageArgs
  ) -> flatbuffers::WIPOffset<ReadyMessage<'bldr>> {
    let mut builder = ReadyMessageBuilder::new(_fbb);
    builder.add_wantsGameMessages(args.wantsGameMessages);
    builder.add_wantsQuickChat(args.wantsQuickChat);
    builder.add_wantsBallPredictions(args.wantsBallPredictions);
    builder.finish()
  }


  #[inline]
  pub fn wantsBallPredictions(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ReadyMessage::VT_WANTSBALLPREDICTIONS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn wantsQuickChat(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ReadyMessage::VT_WANTSQUICKCHAT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn wantsGameMessages(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ReadyMessage::VT_WANTSGAMEMESSAGES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ReadyMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("wantsBallPredictions", Self::VT_WANTSBALLPREDICTIONS, false)?
     .visit_field::<bool>("wantsQuickChat", Self::VT_WANTSQUICKCHAT, false)?
     .visit_field::<bool>("wantsGameMessages", Self::VT_WANTSGAMEMESSAGES, false)?
     .finish();
    Ok(())
  }
}
pub struct ReadyMessageArgs {
    pub wantsBallPredictions: bool,
    pub wantsQuickChat: bool,
    pub wantsGameMessages: bool,
}
impl<'a> Default for ReadyMessageArgs {
  #[inline]
  fn default() -> Self {
    ReadyMessageArgs {
      wantsBallPredictions: false,
      wantsQuickChat: false,
      wantsGameMessages: false,
    }
  }
}

pub struct ReadyMessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadyMessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_wantsBallPredictions(&mut self, wantsBallPredictions: bool) {
    self.fbb_.push_slot::<bool>(ReadyMessage::VT_WANTSBALLPREDICTIONS, wantsBallPredictions, false);
  }
  #[inline]
  pub fn add_wantsQuickChat(&mut self, wantsQuickChat: bool) {
    self.fbb_.push_slot::<bool>(ReadyMessage::VT_WANTSQUICKCHAT, wantsQuickChat, false);
  }
  #[inline]
  pub fn add_wantsGameMessages(&mut self, wantsGameMessages: bool) {
    self.fbb_.push_slot::<bool>(ReadyMessage::VT_WANTSGAMEMESSAGES, wantsGameMessages, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadyMessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReadyMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReadyMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReadyMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReadyMessage");
      ds.field("wantsBallPredictions", &self.wantsBallPredictions());
      ds.field("wantsQuickChat", &self.wantsQuickChat());
      ds.field("wantsGameMessages", &self.wantsGameMessages());
      ds.finish()
  }
}
pub enum PlayerStatEventOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Notification that a player triggers some in-game event, such as:
///		Win, Loss, TimePlayed;
///		Shot, Assist, Center, Clear, PoolShot;
///		Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
///		AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
///		Save, EpicSave, FreezeSave;
///		HatTrick, Savior, Playmaker, MVP;
///		FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
///		MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
///		CarTouches, Demolition, Demolish;
///		LowFive, HighFive;
pub struct PlayerStatEvent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerStatEvent<'a> {
  type Inner = PlayerStatEvent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerStatEvent<'a> {
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
  pub const VT_STATTYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerStatEvent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerStatEventArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerStatEvent<'bldr>> {
    let mut builder = PlayerStatEventBuilder::new(_fbb);
    if let Some(x) = args.statType { builder.add_statType(x); }
    builder.add_playerIndex(args.playerIndex);
    builder.finish()
  }


  /// index of the player associated with the event
  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerStatEvent::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
  /// Event type
  #[inline]
  pub fn statType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PlayerStatEvent::VT_STATTYPE, None)}
  }
}

impl flatbuffers::Verifiable for PlayerStatEvent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("statType", Self::VT_STATTYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerStatEventArgs<'a> {
    pub playerIndex: i32,
    pub statType: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PlayerStatEventArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerStatEventArgs {
      playerIndex: 0,
      statType: None,
    }
  }
}

pub struct PlayerStatEventBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerStatEventBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(PlayerStatEvent::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn add_statType(&mut self, statType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerStatEvent::VT_STATTYPE, statType);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerStatEventBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerStatEventBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerStatEvent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerStatEvent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerStatEvent");
      ds.field("playerIndex", &self.playerIndex());
      ds.field("statType", &self.statType());
      ds.finish()
  }
}
pub enum PlayerSpectateOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Notification when the local player is spectating another player.
pub struct PlayerSpectate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerSpectate<'a> {
  type Inner = PlayerSpectate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerSpectate<'a> {
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerSpectate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerSpectateArgs
  ) -> flatbuffers::WIPOffset<PlayerSpectate<'bldr>> {
    let mut builder = PlayerSpectateBuilder::new(_fbb);
    builder.add_playerIndex(args.playerIndex);
    builder.finish()
  }


  /// index of the player that is being spectated. Will be -1 if not spectating anyone.
  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerSpectate::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PlayerSpectate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerSpectateArgs {
    pub playerIndex: i32,
}
impl<'a> Default for PlayerSpectateArgs {
  #[inline]
  fn default() -> Self {
    PlayerSpectateArgs {
      playerIndex: 0,
    }
  }
}

pub struct PlayerSpectateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerSpectateBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(PlayerSpectate::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerSpectateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerSpectateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerSpectate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerSpectate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerSpectate");
      ds.field("playerIndex", &self.playerIndex());
      ds.finish()
  }
}
pub enum PlayerInputChangeOffset {}
#[derive(Copy, Clone, PartialEq)]

/// Rocket League is notifying us that some player has moved their controller. This is an *output*
pub struct PlayerInputChange<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerInputChange<'a> {
  type Inner = PlayerInputChange<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerInputChange<'a> {
  pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
  pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;
  pub const VT_DODGEFORWARD: flatbuffers::VOffsetT = 8;
  pub const VT_DODGERIGHT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerInputChange { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerInputChangeArgs<'args>
  ) -> flatbuffers::WIPOffset<PlayerInputChange<'bldr>> {
    let mut builder = PlayerInputChangeBuilder::new(_fbb);
    builder.add_dodgeRight(args.dodgeRight);
    builder.add_dodgeForward(args.dodgeForward);
    if let Some(x) = args.controllerState { builder.add_controllerState(x); }
    builder.add_playerIndex(args.playerIndex);
    builder.finish()
  }


  #[inline]
  pub fn playerIndex(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PlayerInputChange::VT_PLAYERINDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn controllerState(&self) -> Option<ControllerState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ControllerState>>(PlayerInputChange::VT_CONTROLLERSTATE, None)}
  }
  #[inline]
  pub fn dodgeForward(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PlayerInputChange::VT_DODGEFORWARD, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn dodgeRight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PlayerInputChange::VT_DODGERIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PlayerInputChange<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>("controllerState", Self::VT_CONTROLLERSTATE, false)?
     .visit_field::<f32>("dodgeForward", Self::VT_DODGEFORWARD, false)?
     .visit_field::<f32>("dodgeRight", Self::VT_DODGERIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerInputChangeArgs<'a> {
    pub playerIndex: i32,
    pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
    pub dodgeForward: f32,
    pub dodgeRight: f32,
}
impl<'a> Default for PlayerInputChangeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerInputChangeArgs {
      playerIndex: 0,
      controllerState: None,
      dodgeForward: 0.0,
      dodgeRight: 0.0,
    }
  }
}

pub struct PlayerInputChangeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerInputChangeBuilder<'a, 'b> {
  #[inline]
  pub fn add_playerIndex(&mut self, playerIndex: i32) {
    self.fbb_.push_slot::<i32>(PlayerInputChange::VT_PLAYERINDEX, playerIndex, 0);
  }
  #[inline]
  pub fn add_controllerState(&mut self, controllerState: flatbuffers::WIPOffset<ControllerState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(PlayerInputChange::VT_CONTROLLERSTATE, controllerState);
  }
  #[inline]
  pub fn add_dodgeForward(&mut self, dodgeForward: f32) {
    self.fbb_.push_slot::<f32>(PlayerInputChange::VT_DODGEFORWARD, dodgeForward, 0.0);
  }
  #[inline]
  pub fn add_dodgeRight(&mut self, dodgeRight: f32) {
    self.fbb_.push_slot::<f32>(PlayerInputChange::VT_DODGERIGHT, dodgeRight, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerInputChangeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerInputChangeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInputChange<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerInputChange<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerInputChange");
      ds.field("playerIndex", &self.playerIndex());
      ds.field("controllerState", &self.controllerState());
      ds.field("dodgeForward", &self.dodgeForward());
      ds.field("dodgeRight", &self.dodgeRight());
      ds.finish()
  }
}
pub enum GameMessageWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GameMessageWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GameMessageWrapper<'a> {
  type Inner = GameMessageWrapper<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GameMessageWrapper<'a> {
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GameMessageWrapper { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GameMessageWrapperArgs
  ) -> flatbuffers::WIPOffset<GameMessageWrapper<'bldr>> {
    let mut builder = GameMessageWrapperBuilder::new(_fbb);
    if let Some(x) = args.Message { builder.add_Message(x); }
    builder.add_Message_type(args.Message_type);
    builder.finish()
  }


  #[inline]
  pub fn Message_type(&self) -> GameMessage {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameMessage>(GameMessageWrapper::VT_MESSAGE_TYPE, Some(GameMessage::NONE)).unwrap()}
  }
  #[inline]
  pub fn Message(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(GameMessageWrapper::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn Message_as_player_stat_event(&self) -> Option<PlayerStatEvent<'a>> {
    if self.Message_type() == GameMessage::PlayerStatEvent {
      self.Message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayerStatEvent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn Message_as_player_spectate(&self) -> Option<PlayerSpectate<'a>> {
    if self.Message_type() == GameMessage::PlayerSpectate {
      self.Message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayerSpectate::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn Message_as_player_input_change(&self) -> Option<PlayerInputChange<'a>> {
    if self.Message_type() == GameMessage::PlayerInputChange {
      self.Message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PlayerInputChange::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for GameMessageWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GameMessage, _>("Message_type", Self::VT_MESSAGE_TYPE, "Message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          GameMessage::PlayerStatEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerStatEvent>>("GameMessage::PlayerStatEvent", pos),
          GameMessage::PlayerSpectate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerSpectate>>("GameMessage::PlayerSpectate", pos),
          GameMessage::PlayerInputChange => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerInputChange>>("GameMessage::PlayerInputChange", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GameMessageWrapperArgs {
    pub Message_type: GameMessage,
    pub Message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GameMessageWrapperArgs {
  #[inline]
  fn default() -> Self {
    GameMessageWrapperArgs {
      Message_type: GameMessage::NONE,
      Message: None,
    }
  }
}

pub struct GameMessageWrapperBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GameMessageWrapperBuilder<'a, 'b> {
  #[inline]
  pub fn add_Message_type(&mut self, Message_type: GameMessage) {
    self.fbb_.push_slot::<GameMessage>(GameMessageWrapper::VT_MESSAGE_TYPE, Message_type, GameMessage::NONE);
  }
  #[inline]
  pub fn add_Message(&mut self, Message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GameMessageWrapper::VT_MESSAGE, Message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GameMessageWrapperBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GameMessageWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GameMessageWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GameMessageWrapper<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GameMessageWrapper");
      ds.field("Message_type", &self.Message_type());
      match self.Message_type() {
        GameMessage::PlayerStatEvent => {
          if let Some(x) = self.Message_as_player_stat_event() {
            ds.field("Message", &x)
          } else {
            ds.field("Message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GameMessage::PlayerSpectate => {
          if let Some(x) = self.Message_as_player_spectate() {
            ds.field("Message", &x)
          } else {
            ds.field("Message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GameMessage::PlayerInputChange => {
          if let Some(x) = self.Message_as_player_input_change() {
            ds.field("Message", &x)
          } else {
            ds.field("Message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("Message", &x)
        },
      };
      ds.finish()
  }
}
pub enum MessagePacketOffset {}
#[derive(Copy, Clone, PartialEq)]

/// We have some very small messages that are only a few bytes but potentially sent at high frequency.
/// Bundle them into a packet to reduce the overhead of sending data over TCP.
pub struct MessagePacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MessagePacket<'a> {
  type Inner = MessagePacket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MessagePacket<'a> {
  pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;
  pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
  pub const VT_FRAMENUM: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MessagePacket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessagePacketArgs<'args>
  ) -> flatbuffers::WIPOffset<MessagePacket<'bldr>> {
    let mut builder = MessagePacketBuilder::new(_fbb);
    builder.add_frameNum(args.frameNum);
    builder.add_gameSeconds(args.gameSeconds);
    if let Some(x) = args.messages { builder.add_messages(x); }
    builder.finish()
  }


  #[inline]
  pub fn messages(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper>>>>(MessagePacket::VT_MESSAGES, None)}
  }
  #[inline]
  pub fn gameSeconds(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(MessagePacket::VT_GAMESECONDS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn frameNum(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(MessagePacket::VT_FRAMENUM, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for MessagePacket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GameMessageWrapper>>>>("messages", Self::VT_MESSAGES, false)?
     .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
     .visit_field::<i32>("frameNum", Self::VT_FRAMENUM, false)?
     .finish();
    Ok(())
  }
}
pub struct MessagePacketArgs<'a> {
    pub messages: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper<'a>>>>>,
    pub gameSeconds: f32,
    pub frameNum: i32,
}
impl<'a> Default for MessagePacketArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessagePacketArgs {
      messages: None,
      gameSeconds: 0.0,
      frameNum: 0,
    }
  }
}

pub struct MessagePacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessagePacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_messages(&mut self, messages: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<GameMessageWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MessagePacket::VT_MESSAGES, messages);
  }
  #[inline]
  pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
    self.fbb_.push_slot::<f32>(MessagePacket::VT_GAMESECONDS, gameSeconds, 0.0);
  }
  #[inline]
  pub fn add_frameNum(&mut self, frameNum: i32) {
    self.fbb_.push_slot::<i32>(MessagePacket::VT_FRAMENUM, frameNum, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessagePacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessagePacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MessagePacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MessagePacket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MessagePacket");
      ds.field("messages", &self.messages());
      ds.field("gameSeconds", &self.gameSeconds());
      ds.field("frameNum", &self.frameNum());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `QuickChat`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_quick_chat_unchecked`.
pub fn root_as_quick_chat(buf: &[u8]) -> Result<QuickChat, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<QuickChat>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `QuickChat` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_quick_chat_unchecked`.
pub fn size_prefixed_root_as_quick_chat(buf: &[u8]) -> Result<QuickChat, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<QuickChat>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `QuickChat` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_quick_chat_unchecked`.
pub fn root_as_quick_chat_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<QuickChat<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<QuickChat<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `QuickChat` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_quick_chat_unchecked`.
pub fn size_prefixed_root_as_quick_chat_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<QuickChat<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<QuickChat<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a QuickChat and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `QuickChat`.
pub unsafe fn root_as_quick_chat_unchecked(buf: &[u8]) -> QuickChat {
  flatbuffers::root_unchecked::<QuickChat>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed QuickChat and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `QuickChat`.
pub unsafe fn size_prefixed_root_as_quick_chat_unchecked(buf: &[u8]) -> QuickChat {
  flatbuffers::size_prefixed_root_unchecked::<QuickChat>(buf)
}
#[inline]
pub fn finish_quick_chat_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<QuickChat<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_quick_chat_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<QuickChat<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod flat
}  // pub mod rlbot

