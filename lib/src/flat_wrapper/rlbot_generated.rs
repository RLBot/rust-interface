// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rlbot {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod flat {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};

        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_COLLISION_SHAPE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_COLLISION_SHAPE: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_COLLISION_SHAPE: [CollisionShape; 4] = [
            CollisionShape::NONE,
            CollisionShape::BoxShape,
            CollisionShape::SphereShape,
            CollisionShape::CylinderShape,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct CollisionShape(pub u8);
        #[allow(non_upper_case_globals)]
        impl CollisionShape {
            pub const NONE: Self = Self(0);
            pub const BoxShape: Self = Self(1);
            pub const SphereShape: Self = Self(2);
            pub const CylinderShape: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::BoxShape,
                Self::SphereShape,
                Self::CylinderShape,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::BoxShape => Some("BoxShape"),
                    Self::SphereShape => Some("SphereShape"),
                    Self::CylinderShape => Some("CylinderShape"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for CollisionShape {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for CollisionShape {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for CollisionShape {
            type Output = CollisionShape;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for CollisionShape {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for CollisionShape {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for CollisionShape {}
        pub struct CollisionShapeUnionTableOffset {}

        #[allow(clippy::upper_case_acronyms)]
        #[derive(Debug, Clone, PartialEq)]
        pub enum CollisionShapeObject {
            NONE,
            BoxShape(Box<BoxShapeObject>),
            SphereShape(Box<SphereShapeObject>),
            CylinderShape(Box<CylinderShapeObject>),
        }
        impl Default for CollisionShapeObject {
            fn default() -> Self {
                Self::NONE
            }
        }
        impl CollisionShapeObject {
            pub fn collision_shape_type(&self) -> CollisionShape {
                match self {
                    Self::NONE => CollisionShape::NONE,
                    Self::BoxShape(_) => CollisionShape::BoxShape,
                    Self::SphereShape(_) => CollisionShape::SphereShape,
                    Self::CylinderShape(_) => CollisionShape::CylinderShape,
                }
            }
            pub fn pack(
                &self,
                fbb: &mut flatbuffers::FlatBufferBuilder,
            ) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
                match self {
                    Self::NONE => None,
                    Self::BoxShape(v) => Some(v.pack(fbb).as_union_value()),
                    Self::SphereShape(v) => Some(v.pack(fbb).as_union_value()),
                    Self::CylinderShape(v) => Some(v.pack(fbb).as_union_value()),
                }
            }
            /// If the union variant matches, return the owned BoxShapeObject, setting the union to NONE.
            pub fn take_box_shape(&mut self) -> Option<Box<BoxShapeObject>> {
                if let Self::BoxShape(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::BoxShape(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the BoxShapeObject.
            pub fn as_box_shape(&self) -> Option<&BoxShapeObject> {
                if let Self::BoxShape(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the BoxShapeObject.
            pub fn as_box_shape_mut(&mut self) -> Option<&mut BoxShapeObject> {
                if let Self::BoxShape(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned SphereShapeObject, setting the union to NONE.
            pub fn take_sphere_shape(&mut self) -> Option<Box<SphereShapeObject>> {
                if let Self::SphereShape(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::SphereShape(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the SphereShapeObject.
            pub fn as_sphere_shape(&self) -> Option<&SphereShapeObject> {
                if let Self::SphereShape(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the SphereShapeObject.
            pub fn as_sphere_shape_mut(&mut self) -> Option<&mut SphereShapeObject> {
                if let Self::SphereShape(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned CylinderShapeObject, setting the union to NONE.
            pub fn take_cylinder_shape(&mut self) -> Option<Box<CylinderShapeObject>> {
                if let Self::CylinderShape(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::CylinderShape(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the CylinderShapeObject.
            pub fn as_cylinder_shape(&self) -> Option<&CylinderShapeObject> {
                if let Self::CylinderShape(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the CylinderShapeObject.
            pub fn as_cylinder_shape_mut(&mut self) -> Option<&mut CylinderShapeObject> {
                if let Self::CylinderShape(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
        }
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_TILE_STATE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_TILE_STATE: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_TILE_STATE: [TileState; 4] = [
            TileState::Unknown,
            TileState::Filled,
            TileState::Damaged,
            TileState::Open,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct TileState(pub i8);
        #[allow(non_upper_case_globals)]
        impl TileState {
            pub const Unknown: Self = Self(0);
            /// The default state of the tiles.
            pub const Filled: Self = Self(1);
            /// The state when a tile has been damaged.
            pub const Damaged: Self = Self(2);
            /// The state of a tile when it is open and a goal can be scored.
            pub const Open: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Unknown, Self::Filled, Self::Damaged, Self::Open];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Unknown => Some("Unknown"),
                    Self::Filled => Some("Filled"),
                    Self::Damaged => Some("Damaged"),
                    Self::Open => Some("Open"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for TileState {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for TileState {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for TileState {
            type Output = TileState;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for TileState {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for TileState {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for TileState {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_RENDER_TYPE: i8 = 1;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_RENDER_TYPE: i8 = 8;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_RENDER_TYPE: [RenderType; 8] = [
            RenderType::DrawLine2D,
            RenderType::DrawLine3D,
            RenderType::DrawLine2D_3D,
            RenderType::DrawRect2D,
            RenderType::DrawRect3D,
            RenderType::DrawString2D,
            RenderType::DrawString3D,
            RenderType::DrawCenteredRect3D,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct RenderType(pub i8);
        #[allow(non_upper_case_globals)]
        impl RenderType {
            pub const DrawLine2D: Self = Self(1);
            pub const DrawLine3D: Self = Self(2);
            pub const DrawLine2D_3D: Self = Self(3);
            pub const DrawRect2D: Self = Self(4);
            pub const DrawRect3D: Self = Self(5);
            pub const DrawString2D: Self = Self(6);
            pub const DrawString3D: Self = Self(7);
            pub const DrawCenteredRect3D: Self = Self(8);

            pub const ENUM_MIN: i8 = 1;
            pub const ENUM_MAX: i8 = 8;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::DrawLine2D,
                Self::DrawLine3D,
                Self::DrawLine2D_3D,
                Self::DrawRect2D,
                Self::DrawRect3D,
                Self::DrawString2D,
                Self::DrawString3D,
                Self::DrawCenteredRect3D,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::DrawLine2D => Some("DrawLine2D"),
                    Self::DrawLine3D => Some("DrawLine3D"),
                    Self::DrawLine2D_3D => Some("DrawLine2D_3D"),
                    Self::DrawRect2D => Some("DrawRect2D"),
                    Self::DrawRect3D => Some("DrawRect3D"),
                    Self::DrawString2D => Some("DrawString2D"),
                    Self::DrawString3D => Some("DrawString3D"),
                    Self::DrawCenteredRect3D => Some("DrawCenteredRect3D"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for RenderType {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for RenderType {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for RenderType {
            type Output = RenderType;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for RenderType {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for RenderType {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for RenderType {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_QUICK_CHAT_SELECTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_QUICK_CHAT_SELECTION: i8 = 62;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_QUICK_CHAT_SELECTION: [QuickChatSelection; 63] = [
            QuickChatSelection::Information_IGotIt,
            QuickChatSelection::Information_NeedBoost,
            QuickChatSelection::Information_TakeTheShot,
            QuickChatSelection::Information_Defending,
            QuickChatSelection::Information_GoForIt,
            QuickChatSelection::Information_Centering,
            QuickChatSelection::Information_AllYours,
            QuickChatSelection::Information_InPosition,
            QuickChatSelection::Information_Incoming,
            QuickChatSelection::Compliments_NiceShot,
            QuickChatSelection::Compliments_GreatPass,
            QuickChatSelection::Compliments_Thanks,
            QuickChatSelection::Compliments_WhatASave,
            QuickChatSelection::Compliments_NiceOne,
            QuickChatSelection::Compliments_WhatAPlay,
            QuickChatSelection::Compliments_GreatClear,
            QuickChatSelection::Compliments_NiceBlock,
            QuickChatSelection::Reactions_OMG,
            QuickChatSelection::Reactions_Noooo,
            QuickChatSelection::Reactions_Wow,
            QuickChatSelection::Reactions_CloseOne,
            QuickChatSelection::Reactions_NoWay,
            QuickChatSelection::Reactions_HolyCow,
            QuickChatSelection::Reactions_Whew,
            QuickChatSelection::Reactions_Siiiick,
            QuickChatSelection::Reactions_Calculated,
            QuickChatSelection::Reactions_Savage,
            QuickChatSelection::Reactions_Okay,
            QuickChatSelection::Apologies_Cursing,
            QuickChatSelection::Apologies_NoProblem,
            QuickChatSelection::Apologies_Whoops,
            QuickChatSelection::Apologies_Sorry,
            QuickChatSelection::Apologies_MyBad,
            QuickChatSelection::Apologies_Oops,
            QuickChatSelection::Apologies_MyFault,
            QuickChatSelection::PostGame_Gg,
            QuickChatSelection::PostGame_WellPlayed,
            QuickChatSelection::PostGame_ThatWasFun,
            QuickChatSelection::PostGame_Rematch,
            QuickChatSelection::PostGame_OneMoreGame,
            QuickChatSelection::PostGame_WhatAGame,
            QuickChatSelection::PostGame_NiceMoves,
            QuickChatSelection::PostGame_EverybodyDance,
            QuickChatSelection::MaxPysonixQuickChatPresets,
            QuickChatSelection::Custom_Toxic_WasteCPU,
            QuickChatSelection::Custom_Toxic_GitGut,
            QuickChatSelection::Custom_Toxic_DeAlloc,
            QuickChatSelection::Custom_Toxic_404NoSkill,
            QuickChatSelection::Custom_Toxic_CatchVirus,
            QuickChatSelection::Custom_Useful_Passing,
            QuickChatSelection::Custom_Useful_Faking,
            QuickChatSelection::Custom_Useful_Demoing,
            QuickChatSelection::Custom_Useful_Bumping,
            QuickChatSelection::Custom_Compliments_TinyChances,
            QuickChatSelection::Custom_Compliments_SkillLevel,
            QuickChatSelection::Custom_Compliments_proud,
            QuickChatSelection::Custom_Compliments_GC,
            QuickChatSelection::Custom_Compliments_Pro,
            QuickChatSelection::Custom_Excuses_Lag,
            QuickChatSelection::Custom_Excuses_GhostInputs,
            QuickChatSelection::Custom_Excuses_Rigged,
            QuickChatSelection::Custom_Toxic_MafiaPlays,
            QuickChatSelection::Custom_Exclamation_Yeet,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct QuickChatSelection(pub i8);
        #[allow(non_upper_case_globals)]
        impl QuickChatSelection {
            pub const Information_IGotIt: Self = Self(0);
            pub const Information_NeedBoost: Self = Self(1);
            pub const Information_TakeTheShot: Self = Self(2);
            pub const Information_Defending: Self = Self(3);
            pub const Information_GoForIt: Self = Self(4);
            pub const Information_Centering: Self = Self(5);
            pub const Information_AllYours: Self = Self(6);
            pub const Information_InPosition: Self = Self(7);
            pub const Information_Incoming: Self = Self(8);
            pub const Compliments_NiceShot: Self = Self(9);
            pub const Compliments_GreatPass: Self = Self(10);
            pub const Compliments_Thanks: Self = Self(11);
            pub const Compliments_WhatASave: Self = Self(12);
            pub const Compliments_NiceOne: Self = Self(13);
            pub const Compliments_WhatAPlay: Self = Self(14);
            pub const Compliments_GreatClear: Self = Self(15);
            pub const Compliments_NiceBlock: Self = Self(16);
            pub const Reactions_OMG: Self = Self(17);
            pub const Reactions_Noooo: Self = Self(18);
            pub const Reactions_Wow: Self = Self(19);
            pub const Reactions_CloseOne: Self = Self(20);
            pub const Reactions_NoWay: Self = Self(21);
            pub const Reactions_HolyCow: Self = Self(22);
            pub const Reactions_Whew: Self = Self(23);
            pub const Reactions_Siiiick: Self = Self(24);
            pub const Reactions_Calculated: Self = Self(25);
            pub const Reactions_Savage: Self = Self(26);
            pub const Reactions_Okay: Self = Self(27);
            pub const Apologies_Cursing: Self = Self(28);
            pub const Apologies_NoProblem: Self = Self(29);
            pub const Apologies_Whoops: Self = Self(30);
            pub const Apologies_Sorry: Self = Self(31);
            pub const Apologies_MyBad: Self = Self(32);
            pub const Apologies_Oops: Self = Self(33);
            pub const Apologies_MyFault: Self = Self(34);
            pub const PostGame_Gg: Self = Self(35);
            pub const PostGame_WellPlayed: Self = Self(36);
            pub const PostGame_ThatWasFun: Self = Self(37);
            pub const PostGame_Rematch: Self = Self(38);
            pub const PostGame_OneMoreGame: Self = Self(39);
            pub const PostGame_WhatAGame: Self = Self(40);
            pub const PostGame_NiceMoves: Self = Self(41);
            pub const PostGame_EverybodyDance: Self = Self(42);
            /// Custom text chats made by bot makers
            pub const MaxPysonixQuickChatPresets: Self = Self(43);
            /// Waste of CPU cycles
            pub const Custom_Toxic_WasteCPU: Self = Self(44);
            /// Git gud*
            pub const Custom_Toxic_GitGut: Self = Self(45);
            /// De-Allocate Yourself
            pub const Custom_Toxic_DeAlloc: Self = Self(46);
            /// 404: Your skill not found
            pub const Custom_Toxic_404NoSkill: Self = Self(47);
            /// Get a virus
            pub const Custom_Toxic_CatchVirus: Self = Self(48);
            /// Passing!
            pub const Custom_Useful_Passing: Self = Self(49);
            /// Faking!
            pub const Custom_Useful_Faking: Self = Self(50);
            /// Demoing!
            pub const Custom_Useful_Demoing: Self = Self(51);
            /// BOOPING
            pub const Custom_Useful_Bumping: Self = Self(52);
            /// The chances of that was 47525 to 1*
            pub const Custom_Compliments_TinyChances: Self = Self(53);
            /// Who upped your skill level?
            pub const Custom_Compliments_SkillLevel: Self = Self(54);
            /// Your programmer should be proud
            pub const Custom_Compliments_proud: Self = Self(55);
            /// You're the GC of Bots
            pub const Custom_Compliments_GC: Self = Self(56);
            /// Are you [Insert Pro]Bot? *
            pub const Custom_Compliments_Pro: Self = Self(57);
            /// Lag
            pub const Custom_Excuses_Lag: Self = Self(58);
            /// Ghost inputs
            pub const Custom_Excuses_GhostInputs: Self = Self(59);
            /// RIGGED
            pub const Custom_Excuses_Rigged: Self = Self(60);
            /// Mafia plays!
            pub const Custom_Toxic_MafiaPlays: Self = Self(61);
            /// Yeet!
            pub const Custom_Exclamation_Yeet: Self = Self(62);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 62;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Information_IGotIt,
                Self::Information_NeedBoost,
                Self::Information_TakeTheShot,
                Self::Information_Defending,
                Self::Information_GoForIt,
                Self::Information_Centering,
                Self::Information_AllYours,
                Self::Information_InPosition,
                Self::Information_Incoming,
                Self::Compliments_NiceShot,
                Self::Compliments_GreatPass,
                Self::Compliments_Thanks,
                Self::Compliments_WhatASave,
                Self::Compliments_NiceOne,
                Self::Compliments_WhatAPlay,
                Self::Compliments_GreatClear,
                Self::Compliments_NiceBlock,
                Self::Reactions_OMG,
                Self::Reactions_Noooo,
                Self::Reactions_Wow,
                Self::Reactions_CloseOne,
                Self::Reactions_NoWay,
                Self::Reactions_HolyCow,
                Self::Reactions_Whew,
                Self::Reactions_Siiiick,
                Self::Reactions_Calculated,
                Self::Reactions_Savage,
                Self::Reactions_Okay,
                Self::Apologies_Cursing,
                Self::Apologies_NoProblem,
                Self::Apologies_Whoops,
                Self::Apologies_Sorry,
                Self::Apologies_MyBad,
                Self::Apologies_Oops,
                Self::Apologies_MyFault,
                Self::PostGame_Gg,
                Self::PostGame_WellPlayed,
                Self::PostGame_ThatWasFun,
                Self::PostGame_Rematch,
                Self::PostGame_OneMoreGame,
                Self::PostGame_WhatAGame,
                Self::PostGame_NiceMoves,
                Self::PostGame_EverybodyDance,
                Self::MaxPysonixQuickChatPresets,
                Self::Custom_Toxic_WasteCPU,
                Self::Custom_Toxic_GitGut,
                Self::Custom_Toxic_DeAlloc,
                Self::Custom_Toxic_404NoSkill,
                Self::Custom_Toxic_CatchVirus,
                Self::Custom_Useful_Passing,
                Self::Custom_Useful_Faking,
                Self::Custom_Useful_Demoing,
                Self::Custom_Useful_Bumping,
                Self::Custom_Compliments_TinyChances,
                Self::Custom_Compliments_SkillLevel,
                Self::Custom_Compliments_proud,
                Self::Custom_Compliments_GC,
                Self::Custom_Compliments_Pro,
                Self::Custom_Excuses_Lag,
                Self::Custom_Excuses_GhostInputs,
                Self::Custom_Excuses_Rigged,
                Self::Custom_Toxic_MafiaPlays,
                Self::Custom_Exclamation_Yeet,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Information_IGotIt => Some("Information_IGotIt"),
                    Self::Information_NeedBoost => Some("Information_NeedBoost"),
                    Self::Information_TakeTheShot => Some("Information_TakeTheShot"),
                    Self::Information_Defending => Some("Information_Defending"),
                    Self::Information_GoForIt => Some("Information_GoForIt"),
                    Self::Information_Centering => Some("Information_Centering"),
                    Self::Information_AllYours => Some("Information_AllYours"),
                    Self::Information_InPosition => Some("Information_InPosition"),
                    Self::Information_Incoming => Some("Information_Incoming"),
                    Self::Compliments_NiceShot => Some("Compliments_NiceShot"),
                    Self::Compliments_GreatPass => Some("Compliments_GreatPass"),
                    Self::Compliments_Thanks => Some("Compliments_Thanks"),
                    Self::Compliments_WhatASave => Some("Compliments_WhatASave"),
                    Self::Compliments_NiceOne => Some("Compliments_NiceOne"),
                    Self::Compliments_WhatAPlay => Some("Compliments_WhatAPlay"),
                    Self::Compliments_GreatClear => Some("Compliments_GreatClear"),
                    Self::Compliments_NiceBlock => Some("Compliments_NiceBlock"),
                    Self::Reactions_OMG => Some("Reactions_OMG"),
                    Self::Reactions_Noooo => Some("Reactions_Noooo"),
                    Self::Reactions_Wow => Some("Reactions_Wow"),
                    Self::Reactions_CloseOne => Some("Reactions_CloseOne"),
                    Self::Reactions_NoWay => Some("Reactions_NoWay"),
                    Self::Reactions_HolyCow => Some("Reactions_HolyCow"),
                    Self::Reactions_Whew => Some("Reactions_Whew"),
                    Self::Reactions_Siiiick => Some("Reactions_Siiiick"),
                    Self::Reactions_Calculated => Some("Reactions_Calculated"),
                    Self::Reactions_Savage => Some("Reactions_Savage"),
                    Self::Reactions_Okay => Some("Reactions_Okay"),
                    Self::Apologies_Cursing => Some("Apologies_Cursing"),
                    Self::Apologies_NoProblem => Some("Apologies_NoProblem"),
                    Self::Apologies_Whoops => Some("Apologies_Whoops"),
                    Self::Apologies_Sorry => Some("Apologies_Sorry"),
                    Self::Apologies_MyBad => Some("Apologies_MyBad"),
                    Self::Apologies_Oops => Some("Apologies_Oops"),
                    Self::Apologies_MyFault => Some("Apologies_MyFault"),
                    Self::PostGame_Gg => Some("PostGame_Gg"),
                    Self::PostGame_WellPlayed => Some("PostGame_WellPlayed"),
                    Self::PostGame_ThatWasFun => Some("PostGame_ThatWasFun"),
                    Self::PostGame_Rematch => Some("PostGame_Rematch"),
                    Self::PostGame_OneMoreGame => Some("PostGame_OneMoreGame"),
                    Self::PostGame_WhatAGame => Some("PostGame_WhatAGame"),
                    Self::PostGame_NiceMoves => Some("PostGame_NiceMoves"),
                    Self::PostGame_EverybodyDance => Some("PostGame_EverybodyDance"),
                    Self::MaxPysonixQuickChatPresets => Some("MaxPysonixQuickChatPresets"),
                    Self::Custom_Toxic_WasteCPU => Some("Custom_Toxic_WasteCPU"),
                    Self::Custom_Toxic_GitGut => Some("Custom_Toxic_GitGut"),
                    Self::Custom_Toxic_DeAlloc => Some("Custom_Toxic_DeAlloc"),
                    Self::Custom_Toxic_404NoSkill => Some("Custom_Toxic_404NoSkill"),
                    Self::Custom_Toxic_CatchVirus => Some("Custom_Toxic_CatchVirus"),
                    Self::Custom_Useful_Passing => Some("Custom_Useful_Passing"),
                    Self::Custom_Useful_Faking => Some("Custom_Useful_Faking"),
                    Self::Custom_Useful_Demoing => Some("Custom_Useful_Demoing"),
                    Self::Custom_Useful_Bumping => Some("Custom_Useful_Bumping"),
                    Self::Custom_Compliments_TinyChances => Some("Custom_Compliments_TinyChances"),
                    Self::Custom_Compliments_SkillLevel => Some("Custom_Compliments_SkillLevel"),
                    Self::Custom_Compliments_proud => Some("Custom_Compliments_proud"),
                    Self::Custom_Compliments_GC => Some("Custom_Compliments_GC"),
                    Self::Custom_Compliments_Pro => Some("Custom_Compliments_Pro"),
                    Self::Custom_Excuses_Lag => Some("Custom_Excuses_Lag"),
                    Self::Custom_Excuses_GhostInputs => Some("Custom_Excuses_GhostInputs"),
                    Self::Custom_Excuses_Rigged => Some("Custom_Excuses_Rigged"),
                    Self::Custom_Toxic_MafiaPlays => Some("Custom_Toxic_MafiaPlays"),
                    Self::Custom_Exclamation_Yeet => Some("Custom_Exclamation_Yeet"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for QuickChatSelection {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for QuickChatSelection {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for QuickChatSelection {
            type Output = QuickChatSelection;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for QuickChatSelection {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for QuickChatSelection {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for QuickChatSelection {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_PLAYER_CLASS: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_PLAYER_CLASS: u8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_PLAYER_CLASS: [PlayerClass; 5] = [
            PlayerClass::NONE,
            PlayerClass::RLBotPlayer,
            PlayerClass::HumanPlayer,
            PlayerClass::PsyonixBotPlayer,
            PlayerClass::PartyMemberBotPlayer,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct PlayerClass(pub u8);
        #[allow(non_upper_case_globals)]
        impl PlayerClass {
            pub const NONE: Self = Self(0);
            pub const RLBotPlayer: Self = Self(1);
            pub const HumanPlayer: Self = Self(2);
            pub const PsyonixBotPlayer: Self = Self(3);
            pub const PartyMemberBotPlayer: Self = Self(4);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::RLBotPlayer,
                Self::HumanPlayer,
                Self::PsyonixBotPlayer,
                Self::PartyMemberBotPlayer,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::RLBotPlayer => Some("RLBotPlayer"),
                    Self::HumanPlayer => Some("HumanPlayer"),
                    Self::PsyonixBotPlayer => Some("PsyonixBotPlayer"),
                    Self::PartyMemberBotPlayer => Some("PartyMemberBotPlayer"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for PlayerClass {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for PlayerClass {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for PlayerClass {
            type Output = PlayerClass;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for PlayerClass {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for PlayerClass {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for PlayerClass {}
        pub struct PlayerClassUnionTableOffset {}

        #[allow(clippy::upper_case_acronyms)]
        #[derive(Debug, Clone, PartialEq)]
        pub enum PlayerClassObject {
            NONE,
            RLBotPlayer(Box<RLBotPlayerObject>),
            HumanPlayer(Box<HumanPlayerObject>),
            PsyonixBotPlayer(Box<PsyonixBotPlayerObject>),
            PartyMemberBotPlayer(Box<PartyMemberBotPlayerObject>),
        }
        impl Default for PlayerClassObject {
            fn default() -> Self {
                Self::NONE
            }
        }
        impl PlayerClassObject {
            pub fn player_class_type(&self) -> PlayerClass {
                match self {
                    Self::NONE => PlayerClass::NONE,
                    Self::RLBotPlayer(_) => PlayerClass::RLBotPlayer,
                    Self::HumanPlayer(_) => PlayerClass::HumanPlayer,
                    Self::PsyonixBotPlayer(_) => PlayerClass::PsyonixBotPlayer,
                    Self::PartyMemberBotPlayer(_) => PlayerClass::PartyMemberBotPlayer,
                }
            }
            pub fn pack(
                &self,
                fbb: &mut flatbuffers::FlatBufferBuilder,
            ) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
                match self {
                    Self::NONE => None,
                    Self::RLBotPlayer(v) => Some(v.pack(fbb).as_union_value()),
                    Self::HumanPlayer(v) => Some(v.pack(fbb).as_union_value()),
                    Self::PsyonixBotPlayer(v) => Some(v.pack(fbb).as_union_value()),
                    Self::PartyMemberBotPlayer(v) => Some(v.pack(fbb).as_union_value()),
                }
            }
            /// If the union variant matches, return the owned RLBotPlayerObject, setting the union to NONE.
            pub fn take_rlbot_player(&mut self) -> Option<Box<RLBotPlayerObject>> {
                if let Self::RLBotPlayer(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::RLBotPlayer(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the RLBotPlayerObject.
            pub fn as_rlbot_player(&self) -> Option<&RLBotPlayerObject> {
                if let Self::RLBotPlayer(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the RLBotPlayerObject.
            pub fn as_rlbot_player_mut(&mut self) -> Option<&mut RLBotPlayerObject> {
                if let Self::RLBotPlayer(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned HumanPlayerObject, setting the union to NONE.
            pub fn take_human_player(&mut self) -> Option<Box<HumanPlayerObject>> {
                if let Self::HumanPlayer(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::HumanPlayer(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the HumanPlayerObject.
            pub fn as_human_player(&self) -> Option<&HumanPlayerObject> {
                if let Self::HumanPlayer(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the HumanPlayerObject.
            pub fn as_human_player_mut(&mut self) -> Option<&mut HumanPlayerObject> {
                if let Self::HumanPlayer(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned PsyonixBotPlayerObject, setting the union to NONE.
            pub fn take_psyonix_bot_player(&mut self) -> Option<Box<PsyonixBotPlayerObject>> {
                if let Self::PsyonixBotPlayer(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::PsyonixBotPlayer(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the PsyonixBotPlayerObject.
            pub fn as_psyonix_bot_player(&self) -> Option<&PsyonixBotPlayerObject> {
                if let Self::PsyonixBotPlayer(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the PsyonixBotPlayerObject.
            pub fn as_psyonix_bot_player_mut(&mut self) -> Option<&mut PsyonixBotPlayerObject> {
                if let Self::PsyonixBotPlayer(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned PartyMemberBotPlayerObject, setting the union to NONE.
            pub fn take_party_member_bot_player(
                &mut self,
            ) -> Option<Box<PartyMemberBotPlayerObject>> {
                if let Self::PartyMemberBotPlayer(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::PartyMemberBotPlayer(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the PartyMemberBotPlayerObject.
            pub fn as_party_member_bot_player(&self) -> Option<&PartyMemberBotPlayerObject> {
                if let Self::PartyMemberBotPlayer(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the PartyMemberBotPlayerObject.
            pub fn as_party_member_bot_player_mut(
                &mut self,
            ) -> Option<&mut PartyMemberBotPlayerObject> {
                if let Self::PartyMemberBotPlayer(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
        }
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GAME_MODE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GAME_MODE: i8 = 6;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GAME_MODE: [GameMode; 7] = [
            GameMode::Soccer,
            GameMode::Hoops,
            GameMode::Dropshot,
            GameMode::Hockey,
            GameMode::Rumble,
            GameMode::Heatseeker,
            GameMode::Gridiron,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GameMode(pub i8);
        #[allow(non_upper_case_globals)]
        impl GameMode {
            pub const Soccer: Self = Self(0);
            pub const Hoops: Self = Self(1);
            pub const Dropshot: Self = Self(2);
            pub const Hockey: Self = Self(3);
            pub const Rumble: Self = Self(4);
            pub const Heatseeker: Self = Self(5);
            pub const Gridiron: Self = Self(6);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 6;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Soccer,
                Self::Hoops,
                Self::Dropshot,
                Self::Hockey,
                Self::Rumble,
                Self::Heatseeker,
                Self::Gridiron,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Soccer => Some("Soccer"),
                    Self::Hoops => Some("Hoops"),
                    Self::Dropshot => Some("Dropshot"),
                    Self::Hockey => Some("Hockey"),
                    Self::Rumble => Some("Rumble"),
                    Self::Heatseeker => Some("Heatseeker"),
                    Self::Gridiron => Some("Gridiron"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for GameMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for GameMode {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for GameMode {
            type Output = GameMode;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for GameMode {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for GameMode {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for GameMode {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GAME_MAP: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GAME_MAP: i8 = 59;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GAME_MAP: [GameMap; 60] = [
            GameMap::DFHStadium,
            GameMap::Mannfield,
            GameMap::ChampionsField,
            GameMap::UrbanCentral,
            GameMap::BeckwithPark,
            GameMap::UtopiaColiseum,
            GameMap::Wasteland,
            GameMap::NeoTokyo,
            GameMap::AquaDome,
            GameMap::StarbaseArc,
            GameMap::Farmstead,
            GameMap::SaltyShores,
            GameMap::DFHStadium_Stormy,
            GameMap::DFHStadium_Day,
            GameMap::Mannfield_Stormy,
            GameMap::Mannfield_Night,
            GameMap::ChampionsField_Day,
            GameMap::BeckwithPark_Stormy,
            GameMap::BeckwithPark_Midnight,
            GameMap::UrbanCentral_Night,
            GameMap::UrbanCentral_Dawn,
            GameMap::UtopiaColiseum_Dusk,
            GameMap::DFHStadium_Snowy,
            GameMap::Mannfield_Snowy,
            GameMap::UtopiaColiseum_Snowy,
            GameMap::Badlands,
            GameMap::Badlands_Night,
            GameMap::TokyoUnderpass,
            GameMap::Arctagon,
            GameMap::Pillars,
            GameMap::Cosmic,
            GameMap::DoubleGoal,
            GameMap::Octagon,
            GameMap::Underpass,
            GameMap::UtopiaRetro,
            GameMap::Hoops_DunkHouse,
            GameMap::DropShot_Core707,
            GameMap::ThrowbackStadium,
            GameMap::ForbiddenTemple,
            GameMap::RivalsArena,
            GameMap::Farmstead_Night,
            GameMap::SaltyShores_Night,
            GameMap::NeonFields,
            GameMap::DFHStadium_Circuit,
            GameMap::DeadeyeCanyon,
            GameMap::StarbaseArc_Aftermath,
            GameMap::Wasteland_Night,
            GameMap::BeckwithPark_GothamNight,
            GameMap::ForbiddenTemple_Day,
            GameMap::UrbanCentral_Haunted,
            GameMap::ChampionsField_NFL,
            GameMap::ThrowbackStadium_Snowy,
            GameMap::Basin,
            GameMap::Corridor,
            GameMap::Loophole,
            GameMap::Galleon,
            GameMap::GalleonRetro,
            GameMap::Hourglass,
            GameMap::Barricade,
            GameMap::Colossus,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GameMap(pub i8);
        #[allow(non_upper_case_globals)]
        impl GameMap {
            pub const DFHStadium: Self = Self(0);
            pub const Mannfield: Self = Self(1);
            pub const ChampionsField: Self = Self(2);
            pub const UrbanCentral: Self = Self(3);
            pub const BeckwithPark: Self = Self(4);
            pub const UtopiaColiseum: Self = Self(5);
            pub const Wasteland: Self = Self(6);
            pub const NeoTokyo: Self = Self(7);
            pub const AquaDome: Self = Self(8);
            pub const StarbaseArc: Self = Self(9);
            pub const Farmstead: Self = Self(10);
            pub const SaltyShores: Self = Self(11);
            pub const DFHStadium_Stormy: Self = Self(12);
            pub const DFHStadium_Day: Self = Self(13);
            pub const Mannfield_Stormy: Self = Self(14);
            pub const Mannfield_Night: Self = Self(15);
            pub const ChampionsField_Day: Self = Self(16);
            pub const BeckwithPark_Stormy: Self = Self(17);
            pub const BeckwithPark_Midnight: Self = Self(18);
            pub const UrbanCentral_Night: Self = Self(19);
            pub const UrbanCentral_Dawn: Self = Self(20);
            pub const UtopiaColiseum_Dusk: Self = Self(21);
            pub const DFHStadium_Snowy: Self = Self(22);
            pub const Mannfield_Snowy: Self = Self(23);
            pub const UtopiaColiseum_Snowy: Self = Self(24);
            pub const Badlands: Self = Self(25);
            pub const Badlands_Night: Self = Self(26);
            pub const TokyoUnderpass: Self = Self(27);
            pub const Arctagon: Self = Self(28);
            pub const Pillars: Self = Self(29);
            pub const Cosmic: Self = Self(30);
            pub const DoubleGoal: Self = Self(31);
            pub const Octagon: Self = Self(32);
            pub const Underpass: Self = Self(33);
            pub const UtopiaRetro: Self = Self(34);
            pub const Hoops_DunkHouse: Self = Self(35);
            pub const DropShot_Core707: Self = Self(36);
            pub const ThrowbackStadium: Self = Self(37);
            pub const ForbiddenTemple: Self = Self(38);
            pub const RivalsArena: Self = Self(39);
            pub const Farmstead_Night: Self = Self(40);
            pub const SaltyShores_Night: Self = Self(41);
            pub const NeonFields: Self = Self(42);
            pub const DFHStadium_Circuit: Self = Self(43);
            pub const DeadeyeCanyon: Self = Self(44);
            pub const StarbaseArc_Aftermath: Self = Self(45);
            pub const Wasteland_Night: Self = Self(46);
            pub const BeckwithPark_GothamNight: Self = Self(47);
            pub const ForbiddenTemple_Day: Self = Self(48);
            pub const UrbanCentral_Haunted: Self = Self(49);
            pub const ChampionsField_NFL: Self = Self(50);
            pub const ThrowbackStadium_Snowy: Self = Self(51);
            pub const Basin: Self = Self(52);
            pub const Corridor: Self = Self(53);
            pub const Loophole: Self = Self(54);
            pub const Galleon: Self = Self(55);
            pub const GalleonRetro: Self = Self(56);
            pub const Hourglass: Self = Self(57);
            pub const Barricade: Self = Self(58);
            pub const Colossus: Self = Self(59);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 59;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::DFHStadium,
                Self::Mannfield,
                Self::ChampionsField,
                Self::UrbanCentral,
                Self::BeckwithPark,
                Self::UtopiaColiseum,
                Self::Wasteland,
                Self::NeoTokyo,
                Self::AquaDome,
                Self::StarbaseArc,
                Self::Farmstead,
                Self::SaltyShores,
                Self::DFHStadium_Stormy,
                Self::DFHStadium_Day,
                Self::Mannfield_Stormy,
                Self::Mannfield_Night,
                Self::ChampionsField_Day,
                Self::BeckwithPark_Stormy,
                Self::BeckwithPark_Midnight,
                Self::UrbanCentral_Night,
                Self::UrbanCentral_Dawn,
                Self::UtopiaColiseum_Dusk,
                Self::DFHStadium_Snowy,
                Self::Mannfield_Snowy,
                Self::UtopiaColiseum_Snowy,
                Self::Badlands,
                Self::Badlands_Night,
                Self::TokyoUnderpass,
                Self::Arctagon,
                Self::Pillars,
                Self::Cosmic,
                Self::DoubleGoal,
                Self::Octagon,
                Self::Underpass,
                Self::UtopiaRetro,
                Self::Hoops_DunkHouse,
                Self::DropShot_Core707,
                Self::ThrowbackStadium,
                Self::ForbiddenTemple,
                Self::RivalsArena,
                Self::Farmstead_Night,
                Self::SaltyShores_Night,
                Self::NeonFields,
                Self::DFHStadium_Circuit,
                Self::DeadeyeCanyon,
                Self::StarbaseArc_Aftermath,
                Self::Wasteland_Night,
                Self::BeckwithPark_GothamNight,
                Self::ForbiddenTemple_Day,
                Self::UrbanCentral_Haunted,
                Self::ChampionsField_NFL,
                Self::ThrowbackStadium_Snowy,
                Self::Basin,
                Self::Corridor,
                Self::Loophole,
                Self::Galleon,
                Self::GalleonRetro,
                Self::Hourglass,
                Self::Barricade,
                Self::Colossus,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::DFHStadium => Some("DFHStadium"),
                    Self::Mannfield => Some("Mannfield"),
                    Self::ChampionsField => Some("ChampionsField"),
                    Self::UrbanCentral => Some("UrbanCentral"),
                    Self::BeckwithPark => Some("BeckwithPark"),
                    Self::UtopiaColiseum => Some("UtopiaColiseum"),
                    Self::Wasteland => Some("Wasteland"),
                    Self::NeoTokyo => Some("NeoTokyo"),
                    Self::AquaDome => Some("AquaDome"),
                    Self::StarbaseArc => Some("StarbaseArc"),
                    Self::Farmstead => Some("Farmstead"),
                    Self::SaltyShores => Some("SaltyShores"),
                    Self::DFHStadium_Stormy => Some("DFHStadium_Stormy"),
                    Self::DFHStadium_Day => Some("DFHStadium_Day"),
                    Self::Mannfield_Stormy => Some("Mannfield_Stormy"),
                    Self::Mannfield_Night => Some("Mannfield_Night"),
                    Self::ChampionsField_Day => Some("ChampionsField_Day"),
                    Self::BeckwithPark_Stormy => Some("BeckwithPark_Stormy"),
                    Self::BeckwithPark_Midnight => Some("BeckwithPark_Midnight"),
                    Self::UrbanCentral_Night => Some("UrbanCentral_Night"),
                    Self::UrbanCentral_Dawn => Some("UrbanCentral_Dawn"),
                    Self::UtopiaColiseum_Dusk => Some("UtopiaColiseum_Dusk"),
                    Self::DFHStadium_Snowy => Some("DFHStadium_Snowy"),
                    Self::Mannfield_Snowy => Some("Mannfield_Snowy"),
                    Self::UtopiaColiseum_Snowy => Some("UtopiaColiseum_Snowy"),
                    Self::Badlands => Some("Badlands"),
                    Self::Badlands_Night => Some("Badlands_Night"),
                    Self::TokyoUnderpass => Some("TokyoUnderpass"),
                    Self::Arctagon => Some("Arctagon"),
                    Self::Pillars => Some("Pillars"),
                    Self::Cosmic => Some("Cosmic"),
                    Self::DoubleGoal => Some("DoubleGoal"),
                    Self::Octagon => Some("Octagon"),
                    Self::Underpass => Some("Underpass"),
                    Self::UtopiaRetro => Some("UtopiaRetro"),
                    Self::Hoops_DunkHouse => Some("Hoops_DunkHouse"),
                    Self::DropShot_Core707 => Some("DropShot_Core707"),
                    Self::ThrowbackStadium => Some("ThrowbackStadium"),
                    Self::ForbiddenTemple => Some("ForbiddenTemple"),
                    Self::RivalsArena => Some("RivalsArena"),
                    Self::Farmstead_Night => Some("Farmstead_Night"),
                    Self::SaltyShores_Night => Some("SaltyShores_Night"),
                    Self::NeonFields => Some("NeonFields"),
                    Self::DFHStadium_Circuit => Some("DFHStadium_Circuit"),
                    Self::DeadeyeCanyon => Some("DeadeyeCanyon"),
                    Self::StarbaseArc_Aftermath => Some("StarbaseArc_Aftermath"),
                    Self::Wasteland_Night => Some("Wasteland_Night"),
                    Self::BeckwithPark_GothamNight => Some("BeckwithPark_GothamNight"),
                    Self::ForbiddenTemple_Day => Some("ForbiddenTemple_Day"),
                    Self::UrbanCentral_Haunted => Some("UrbanCentral_Haunted"),
                    Self::ChampionsField_NFL => Some("ChampionsField_NFL"),
                    Self::ThrowbackStadium_Snowy => Some("ThrowbackStadium_Snowy"),
                    Self::Basin => Some("Basin"),
                    Self::Corridor => Some("Corridor"),
                    Self::Loophole => Some("Loophole"),
                    Self::Galleon => Some("Galleon"),
                    Self::GalleonRetro => Some("GalleonRetro"),
                    Self::Hourglass => Some("Hourglass"),
                    Self::Barricade => Some("Barricade"),
                    Self::Colossus => Some("Colossus"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for GameMap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for GameMap {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for GameMap {
            type Output = GameMap;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for GameMap {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for GameMap {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for GameMap {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_MATCH_LENGTH: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_MATCH_LENGTH: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_MATCH_LENGTH: [MatchLength; 4] = [
            MatchLength::Five_Minutes,
            MatchLength::Ten_Minutes,
            MatchLength::Twenty_Minutes,
            MatchLength::Unlimited,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct MatchLength(pub i8);
        #[allow(non_upper_case_globals)]
        impl MatchLength {
            pub const Five_Minutes: Self = Self(0);
            pub const Ten_Minutes: Self = Self(1);
            pub const Twenty_Minutes: Self = Self(2);
            pub const Unlimited: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Five_Minutes,
                Self::Ten_Minutes,
                Self::Twenty_Minutes,
                Self::Unlimited,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Five_Minutes => Some("Five_Minutes"),
                    Self::Ten_Minutes => Some("Ten_Minutes"),
                    Self::Twenty_Minutes => Some("Twenty_Minutes"),
                    Self::Unlimited => Some("Unlimited"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for MatchLength {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for MatchLength {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for MatchLength {
            type Output = MatchLength;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for MatchLength {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for MatchLength {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for MatchLength {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_MAX_SCORE: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_MAX_SCORE: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_MAX_SCORE: [MaxScore; 4] = [
            MaxScore::Unlimited,
            MaxScore::One_Goal,
            MaxScore::Three_Goals,
            MaxScore::Five_Goals,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct MaxScore(pub i8);
        #[allow(non_upper_case_globals)]
        impl MaxScore {
            pub const Unlimited: Self = Self(0);
            pub const One_Goal: Self = Self(1);
            pub const Three_Goals: Self = Self(2);
            pub const Five_Goals: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Unlimited,
                Self::One_Goal,
                Self::Three_Goals,
                Self::Five_Goals,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Unlimited => Some("Unlimited"),
                    Self::One_Goal => Some("One_Goal"),
                    Self::Three_Goals => Some("Three_Goals"),
                    Self::Five_Goals => Some("Five_Goals"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for MaxScore {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for MaxScore {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for MaxScore {
            type Output = MaxScore;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for MaxScore {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for MaxScore {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for MaxScore {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_OVERTIME_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_OVERTIME_OPTION: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_OVERTIME_OPTION: [OvertimeOption; 3] = [
            OvertimeOption::Unlimited,
            OvertimeOption::Five_Max_First_Score,
            OvertimeOption::Five_Max_Random_Team,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct OvertimeOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl OvertimeOption {
            pub const Unlimited: Self = Self(0);
            pub const Five_Max_First_Score: Self = Self(1);
            pub const Five_Max_Random_Team: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Unlimited,
                Self::Five_Max_First_Score,
                Self::Five_Max_Random_Team,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Unlimited => Some("Unlimited"),
                    Self::Five_Max_First_Score => Some("Five_Max_First_Score"),
                    Self::Five_Max_Random_Team => Some("Five_Max_Random_Team"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for OvertimeOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for OvertimeOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for OvertimeOption {
            type Output = OvertimeOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for OvertimeOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for OvertimeOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for OvertimeOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_SERIES_LENGTH_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_SERIES_LENGTH_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_SERIES_LENGTH_OPTION: [SeriesLengthOption; 4] = [
            SeriesLengthOption::Unlimited,
            SeriesLengthOption::Three_Games,
            SeriesLengthOption::Five_Games,
            SeriesLengthOption::Seven_Games,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct SeriesLengthOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl SeriesLengthOption {
            pub const Unlimited: Self = Self(0);
            pub const Three_Games: Self = Self(1);
            pub const Five_Games: Self = Self(2);
            pub const Seven_Games: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Unlimited,
                Self::Three_Games,
                Self::Five_Games,
                Self::Seven_Games,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Unlimited => Some("Unlimited"),
                    Self::Three_Games => Some("Three_Games"),
                    Self::Five_Games => Some("Five_Games"),
                    Self::Seven_Games => Some("Seven_Games"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for SeriesLengthOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for SeriesLengthOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for SeriesLengthOption {
            type Output = SeriesLengthOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for SeriesLengthOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for SeriesLengthOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for SeriesLengthOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GAME_SPEED_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GAME_SPEED_OPTION: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GAME_SPEED_OPTION: [GameSpeedOption; 3] = [
            GameSpeedOption::Default,
            GameSpeedOption::Slo_Mo,
            GameSpeedOption::Time_Warp,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GameSpeedOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl GameSpeedOption {
            pub const Default: Self = Self(0);
            pub const Slo_Mo: Self = Self(1);
            pub const Time_Warp: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Slo_Mo, Self::Time_Warp];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Slo_Mo => Some("Slo_Mo"),
                    Self::Time_Warp => Some("Time_Warp"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for GameSpeedOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for GameSpeedOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for GameSpeedOption {
            type Output = GameSpeedOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for GameSpeedOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for GameSpeedOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for GameSpeedOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BALL_MAX_SPEED_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BALL_MAX_SPEED_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BALL_MAX_SPEED_OPTION: [BallMaxSpeedOption; 4] = [
            BallMaxSpeedOption::Default,
            BallMaxSpeedOption::Slow,
            BallMaxSpeedOption::Fast,
            BallMaxSpeedOption::Super_Fast,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BallMaxSpeedOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BallMaxSpeedOption {
            pub const Default: Self = Self(0);
            pub const Slow: Self = Self(1);
            pub const Fast: Self = Self(2);
            pub const Super_Fast: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Slow, Self::Fast, Self::Super_Fast];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Slow => Some("Slow"),
                    Self::Fast => Some("Fast"),
                    Self::Super_Fast => Some("Super_Fast"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BallMaxSpeedOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BallMaxSpeedOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BallMaxSpeedOption {
            type Output = BallMaxSpeedOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BallMaxSpeedOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BallMaxSpeedOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BallMaxSpeedOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BALL_TYPE_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BALL_TYPE_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BALL_TYPE_OPTION: [BallTypeOption; 4] = [
            BallTypeOption::Default,
            BallTypeOption::Cube,
            BallTypeOption::Puck,
            BallTypeOption::Basketball,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BallTypeOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BallTypeOption {
            pub const Default: Self = Self(0);
            pub const Cube: Self = Self(1);
            pub const Puck: Self = Self(2);
            pub const Basketball: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Cube, Self::Puck, Self::Basketball];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Cube => Some("Cube"),
                    Self::Puck => Some("Puck"),
                    Self::Basketball => Some("Basketball"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BallTypeOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BallTypeOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BallTypeOption {
            type Output = BallTypeOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BallTypeOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BallTypeOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BallTypeOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BALL_WEIGHT_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BALL_WEIGHT_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BALL_WEIGHT_OPTION: [BallWeightOption; 4] = [
            BallWeightOption::Default,
            BallWeightOption::Light,
            BallWeightOption::Heavy,
            BallWeightOption::Super_Light,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BallWeightOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BallWeightOption {
            pub const Default: Self = Self(0);
            pub const Light: Self = Self(1);
            pub const Heavy: Self = Self(2);
            pub const Super_Light: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Light, Self::Heavy, Self::Super_Light];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Light => Some("Light"),
                    Self::Heavy => Some("Heavy"),
                    Self::Super_Light => Some("Super_Light"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BallWeightOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BallWeightOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BallWeightOption {
            type Output = BallWeightOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BallWeightOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BallWeightOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BallWeightOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BALL_SIZE_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BALL_SIZE_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BALL_SIZE_OPTION: [BallSizeOption; 4] = [
            BallSizeOption::Default,
            BallSizeOption::Small,
            BallSizeOption::Large,
            BallSizeOption::Gigantic,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BallSizeOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BallSizeOption {
            pub const Default: Self = Self(0);
            pub const Small: Self = Self(1);
            pub const Large: Self = Self(2);
            pub const Gigantic: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Small, Self::Large, Self::Gigantic];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Small => Some("Small"),
                    Self::Large => Some("Large"),
                    Self::Gigantic => Some("Gigantic"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BallSizeOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BallSizeOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BallSizeOption {
            type Output = BallSizeOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BallSizeOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BallSizeOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BallSizeOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BALL_BOUNCINESS_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BALL_BOUNCINESS_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BALL_BOUNCINESS_OPTION: [BallBouncinessOption; 4] = [
            BallBouncinessOption::Default,
            BallBouncinessOption::Low,
            BallBouncinessOption::High,
            BallBouncinessOption::Super_High,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BallBouncinessOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BallBouncinessOption {
            pub const Default: Self = Self(0);
            pub const Low: Self = Self(1);
            pub const High: Self = Self(2);
            pub const Super_High: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Low, Self::High, Self::Super_High];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Low => Some("Low"),
                    Self::High => Some("High"),
                    Self::Super_High => Some("Super_High"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BallBouncinessOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BallBouncinessOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BallBouncinessOption {
            type Output = BallBouncinessOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BallBouncinessOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BallBouncinessOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BallBouncinessOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BOOST_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BOOST_OPTION: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BOOST_OPTION: [BoostOption; 5] = [
            BoostOption::Normal_Boost,
            BoostOption::Unlimited_Boost,
            BoostOption::Slow_Recharge,
            BoostOption::Rapid_Recharge,
            BoostOption::No_Boost,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BoostOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BoostOption {
            pub const Normal_Boost: Self = Self(0);
            pub const Unlimited_Boost: Self = Self(1);
            pub const Slow_Recharge: Self = Self(2);
            pub const Rapid_Recharge: Self = Self(3);
            pub const No_Boost: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Normal_Boost,
                Self::Unlimited_Boost,
                Self::Slow_Recharge,
                Self::Rapid_Recharge,
                Self::No_Boost,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Normal_Boost => Some("Normal_Boost"),
                    Self::Unlimited_Boost => Some("Unlimited_Boost"),
                    Self::Slow_Recharge => Some("Slow_Recharge"),
                    Self::Rapid_Recharge => Some("Rapid_Recharge"),
                    Self::No_Boost => Some("No_Boost"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BoostOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BoostOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BoostOption {
            type Output = BoostOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BoostOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BoostOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BoostOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_RUMBLE_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_RUMBLE_OPTION: i8 = 7;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_RUMBLE_OPTION: [RumbleOption; 8] = [
            RumbleOption::No_Rumble,
            RumbleOption::Default,
            RumbleOption::Slow,
            RumbleOption::Civilized,
            RumbleOption::Destruction_Derby,
            RumbleOption::Spring_Loaded,
            RumbleOption::Spikes_Only,
            RumbleOption::Spike_Rush,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct RumbleOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl RumbleOption {
            pub const No_Rumble: Self = Self(0);
            pub const Default: Self = Self(1);
            pub const Slow: Self = Self(2);
            pub const Civilized: Self = Self(3);
            pub const Destruction_Derby: Self = Self(4);
            pub const Spring_Loaded: Self = Self(5);
            pub const Spikes_Only: Self = Self(6);
            pub const Spike_Rush: Self = Self(7);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 7;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::No_Rumble,
                Self::Default,
                Self::Slow,
                Self::Civilized,
                Self::Destruction_Derby,
                Self::Spring_Loaded,
                Self::Spikes_Only,
                Self::Spike_Rush,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::No_Rumble => Some("No_Rumble"),
                    Self::Default => Some("Default"),
                    Self::Slow => Some("Slow"),
                    Self::Civilized => Some("Civilized"),
                    Self::Destruction_Derby => Some("Destruction_Derby"),
                    Self::Spring_Loaded => Some("Spring_Loaded"),
                    Self::Spikes_Only => Some("Spikes_Only"),
                    Self::Spike_Rush => Some("Spike_Rush"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for RumbleOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for RumbleOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for RumbleOption {
            type Output = RumbleOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for RumbleOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for RumbleOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for RumbleOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_BOOST_STRENGTH_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_BOOST_STRENGTH_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_BOOST_STRENGTH_OPTION: [BoostStrengthOption; 4] = [
            BoostStrengthOption::One,
            BoostStrengthOption::OneAndAHalf,
            BoostStrengthOption::Two,
            BoostStrengthOption::Ten,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct BoostStrengthOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl BoostStrengthOption {
            pub const One: Self = Self(0);
            pub const OneAndAHalf: Self = Self(1);
            pub const Two: Self = Self(2);
            pub const Ten: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::One, Self::OneAndAHalf, Self::Two, Self::Ten];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::One => Some("One"),
                    Self::OneAndAHalf => Some("OneAndAHalf"),
                    Self::Two => Some("Two"),
                    Self::Ten => Some("Ten"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for BoostStrengthOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for BoostStrengthOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for BoostStrengthOption {
            type Output = BoostStrengthOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for BoostStrengthOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for BoostStrengthOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for BoostStrengthOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GRAVITY_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GRAVITY_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GRAVITY_OPTION: [GravityOption; 4] = [
            GravityOption::Default,
            GravityOption::Low,
            GravityOption::High,
            GravityOption::Super_High,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GravityOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl GravityOption {
            pub const Default: Self = Self(0);
            pub const Low: Self = Self(1);
            pub const High: Self = Self(2);
            pub const Super_High: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] =
                &[Self::Default, Self::Low, Self::High, Self::Super_High];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Low => Some("Low"),
                    Self::High => Some("High"),
                    Self::Super_High => Some("Super_High"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for GravityOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for GravityOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for GravityOption {
            type Output = GravityOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for GravityOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for GravityOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for GravityOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_DEMOLISH_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_DEMOLISH_OPTION: i8 = 4;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_DEMOLISH_OPTION: [DemolishOption; 5] = [
            DemolishOption::Default,
            DemolishOption::Disabled,
            DemolishOption::Friendly_Fire,
            DemolishOption::On_Contact,
            DemolishOption::On_Contact_FF,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct DemolishOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl DemolishOption {
            pub const Default: Self = Self(0);
            pub const Disabled: Self = Self(1);
            pub const Friendly_Fire: Self = Self(2);
            pub const On_Contact: Self = Self(3);
            pub const On_Contact_FF: Self = Self(4);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 4;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Default,
                Self::Disabled,
                Self::Friendly_Fire,
                Self::On_Contact,
                Self::On_Contact_FF,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Default => Some("Default"),
                    Self::Disabled => Some("Disabled"),
                    Self::Friendly_Fire => Some("Friendly_Fire"),
                    Self::On_Contact => Some("On_Contact"),
                    Self::On_Contact_FF => Some("On_Contact_FF"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for DemolishOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for DemolishOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for DemolishOption {
            type Output = DemolishOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for DemolishOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for DemolishOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for DemolishOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_RESPAWN_TIME_OPTION: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_RESPAWN_TIME_OPTION: i8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_RESPAWN_TIME_OPTION: [RespawnTimeOption; 4] = [
            RespawnTimeOption::Three_Seconds,
            RespawnTimeOption::Two_Seconds,
            RespawnTimeOption::One_Seconds,
            RespawnTimeOption::Disable_Goal_Reset,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct RespawnTimeOption(pub i8);
        #[allow(non_upper_case_globals)]
        impl RespawnTimeOption {
            pub const Three_Seconds: Self = Self(0);
            pub const Two_Seconds: Self = Self(1);
            pub const One_Seconds: Self = Self(2);
            pub const Disable_Goal_Reset: Self = Self(3);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Three_Seconds,
                Self::Two_Seconds,
                Self::One_Seconds,
                Self::Disable_Goal_Reset,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Three_Seconds => Some("Three_Seconds"),
                    Self::Two_Seconds => Some("Two_Seconds"),
                    Self::One_Seconds => Some("One_Seconds"),
                    Self::Disable_Goal_Reset => Some("Disable_Goal_Reset"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for RespawnTimeOption {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for RespawnTimeOption {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for RespawnTimeOption {
            type Output = RespawnTimeOption;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for RespawnTimeOption {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for RespawnTimeOption {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for RespawnTimeOption {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_EXISTING_MATCH_BEHAVIOR: i8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_EXISTING_MATCH_BEHAVIOR: i8 = 2;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_EXISTING_MATCH_BEHAVIOR: [ExistingMatchBehavior; 3] = [
            ExistingMatchBehavior::Restart_If_Different,
            ExistingMatchBehavior::Restart,
            ExistingMatchBehavior::Continue_And_Spawn,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct ExistingMatchBehavior(pub i8);
        #[allow(non_upper_case_globals)]
        impl ExistingMatchBehavior {
            /// Restart the match if any match settings differ. This is the default because old RLBot always worked this way.
            pub const Restart_If_Different: Self = Self(0);
            /// Always restart the match, even if config is identical
            pub const Restart: Self = Self(1);
            /// Never restart an existing match, just try to remove or spawn cars to match the configuration.
            /// If we are not in the middle of a match, a match will be started. Handy for LAN matches.
            pub const Continue_And_Spawn: Self = Self(2);

            pub const ENUM_MIN: i8 = 0;
            pub const ENUM_MAX: i8 = 2;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::Restart_If_Different,
                Self::Restart,
                Self::Continue_And_Spawn,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::Restart_If_Different => Some("Restart_If_Different"),
                    Self::Restart => Some("Restart"),
                    Self::Continue_And_Spawn => Some("Continue_And_Spawn"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for ExistingMatchBehavior {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for ExistingMatchBehavior {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for ExistingMatchBehavior {
            type Output = ExistingMatchBehavior;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<i8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for ExistingMatchBehavior {
            type Scalar = i8;
            #[inline]
            fn to_little_endian(self) -> i8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: i8) -> Self {
                let b = i8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for ExistingMatchBehavior {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                i8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for ExistingMatchBehavior {}
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MIN_GAME_MESSAGE: u8 = 0;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        pub const ENUM_MAX_GAME_MESSAGE: u8 = 3;
        #[deprecated(
            since = "2.0.0",
            note = "Use associated constants instead. This will no longer be generated in 2021."
        )]
        #[allow(non_camel_case_types)]
        pub const ENUM_VALUES_GAME_MESSAGE: [GameMessage; 4] = [
            GameMessage::NONE,
            GameMessage::PlayerStatEvent,
            GameMessage::PlayerSpectate,
            GameMessage::PlayerInputChange,
        ];

        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
        #[repr(transparent)]
        pub struct GameMessage(pub u8);
        #[allow(non_upper_case_globals)]
        impl GameMessage {
            pub const NONE: Self = Self(0);
            pub const PlayerStatEvent: Self = Self(1);
            pub const PlayerSpectate: Self = Self(2);
            pub const PlayerInputChange: Self = Self(3);

            pub const ENUM_MIN: u8 = 0;
            pub const ENUM_MAX: u8 = 3;
            pub const ENUM_VALUES: &'static [Self] = &[
                Self::NONE,
                Self::PlayerStatEvent,
                Self::PlayerSpectate,
                Self::PlayerInputChange,
            ];
            /// Returns the variant's name or "" if unknown.
            pub fn variant_name(self) -> Option<&'static str> {
                match self {
                    Self::NONE => Some("NONE"),
                    Self::PlayerStatEvent => Some("PlayerStatEvent"),
                    Self::PlayerSpectate => Some("PlayerSpectate"),
                    Self::PlayerInputChange => Some("PlayerInputChange"),
                    _ => None,
                }
            }
        }
        impl core::fmt::Debug for GameMessage {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if let Some(name) = self.variant_name() {
                    f.write_str(name)
                } else {
                    f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                }
            }
        }
        impl<'a> flatbuffers::Follow<'a> for GameMessage {
            type Inner = Self;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
                Self(b)
            }
        }

        impl flatbuffers::Push for GameMessage {
            type Output = GameMessage;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                flatbuffers::emplace_scalar::<u8>(dst, self.0);
            }
        }

        impl flatbuffers::EndianScalar for GameMessage {
            type Scalar = u8;
            #[inline]
            fn to_little_endian(self) -> u8 {
                self.0.to_le()
            }
            #[inline]
            #[allow(clippy::wrong_self_convention)]
            fn from_little_endian(v: u8) -> Self {
                let b = u8::from_le(v);
                Self(b)
            }
        }

        impl<'a> flatbuffers::Verifiable for GameMessage {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                u8::run_verifier(v, pos)
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for GameMessage {}
        pub struct GameMessageUnionTableOffset {}

        #[allow(clippy::upper_case_acronyms)]
        #[derive(Debug, Clone, PartialEq)]
        pub enum GameMessageObject {
            NONE,
            PlayerStatEvent(Box<PlayerStatEventObject>),
            PlayerSpectate(Box<PlayerSpectateObject>),
            PlayerInputChange(Box<PlayerInputChangeObject>),
        }
        impl Default for GameMessageObject {
            fn default() -> Self {
                Self::NONE
            }
        }
        impl GameMessageObject {
            pub fn game_message_type(&self) -> GameMessage {
                match self {
                    Self::NONE => GameMessage::NONE,
                    Self::PlayerStatEvent(_) => GameMessage::PlayerStatEvent,
                    Self::PlayerSpectate(_) => GameMessage::PlayerSpectate,
                    Self::PlayerInputChange(_) => GameMessage::PlayerInputChange,
                }
            }
            pub fn pack(
                &self,
                fbb: &mut flatbuffers::FlatBufferBuilder,
            ) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
                match self {
                    Self::NONE => None,
                    Self::PlayerStatEvent(v) => Some(v.pack(fbb).as_union_value()),
                    Self::PlayerSpectate(v) => Some(v.pack(fbb).as_union_value()),
                    Self::PlayerInputChange(v) => Some(v.pack(fbb).as_union_value()),
                }
            }
            /// If the union variant matches, return the owned PlayerStatEventObject, setting the union to NONE.
            pub fn take_player_stat_event(&mut self) -> Option<Box<PlayerStatEventObject>> {
                if let Self::PlayerStatEvent(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::PlayerStatEvent(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the PlayerStatEventObject.
            pub fn as_player_stat_event(&self) -> Option<&PlayerStatEventObject> {
                if let Self::PlayerStatEvent(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the PlayerStatEventObject.
            pub fn as_player_stat_event_mut(&mut self) -> Option<&mut PlayerStatEventObject> {
                if let Self::PlayerStatEvent(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned PlayerSpectateObject, setting the union to NONE.
            pub fn take_player_spectate(&mut self) -> Option<Box<PlayerSpectateObject>> {
                if let Self::PlayerSpectate(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::PlayerSpectate(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the PlayerSpectateObject.
            pub fn as_player_spectate(&self) -> Option<&PlayerSpectateObject> {
                if let Self::PlayerSpectate(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the PlayerSpectateObject.
            pub fn as_player_spectate_mut(&mut self) -> Option<&mut PlayerSpectateObject> {
                if let Self::PlayerSpectate(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
            /// If the union variant matches, return the owned PlayerInputChangeObject, setting the union to NONE.
            pub fn take_player_input_change(&mut self) -> Option<Box<PlayerInputChangeObject>> {
                if let Self::PlayerInputChange(_) = self {
                    let v = core::mem::replace(self, Self::NONE);
                    if let Self::PlayerInputChange(w) = v {
                        Some(w)
                    } else {
                        unreachable!()
                    }
                } else {
                    None
                }
            }
            /// If the union variant matches, return a reference to the PlayerInputChangeObject.
            pub fn as_player_input_change(&self) -> Option<&PlayerInputChangeObject> {
                if let Self::PlayerInputChange(v) = self {
                    Some(v.as_ref())
                } else {
                    None
                }
            }
            /// If the union variant matches, return a mutable reference to the PlayerInputChangeObject.
            pub fn as_player_input_change_mut(&mut self) -> Option<&mut PlayerInputChangeObject> {
                if let Self::PlayerInputChange(v) = self {
                    Some(v.as_mut())
                } else {
                    None
                }
            }
        }
        // struct Vector3, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Vector3(pub [u8; 12]);
        impl Default for Vector3 {
            fn default() -> Self {
                Self([0; 12])
            }
        }
        impl core::fmt::Debug for Vector3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Vector3")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("z", &self.z())
                    .finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Vector3 {}
        impl<'a> flatbuffers::Follow<'a> for Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Vector3>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Vector3 {
            type Inner = &'a Vector3;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Vector3>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Vector3 {
            type Output = Vector3;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = ::core::slice::from_raw_parts(
                    self as *const Vector3 as *const u8,
                    Self::size(),
                );
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Vector3 {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Vector3 {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: f32, y: f32, z: f32) -> Self {
                let mut s = Self([0; 12]);
                s.set_x(x);
                s.set_y(y);
                s.set_z(z);
                s
            }

            pub fn x(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn z(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_z(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> Vector3Object {
                Vector3Object {
                    x: self.x(),
                    y: self.y(),
                    z: self.z(),
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct Vector3Object {
            pub x: f32,
            pub y: f32,
            pub z: f32,
        }
        impl Vector3Object {
            pub fn pack(&self) -> Vector3 {
                Vector3::new(self.x, self.y, self.z)
            }
        }

        /// Expresses the rotation state of an object in Euler angles, with values in radians.
        // struct Rotator, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rotator(pub [u8; 12]);
        impl Default for Rotator {
            fn default() -> Self {
                Self([0; 12])
            }
        }
        impl core::fmt::Debug for Rotator {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rotator")
                    .field("pitch", &self.pitch())
                    .field("yaw", &self.yaw())
                    .field("roll", &self.roll())
                    .finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Rotator {}
        impl<'a> flatbuffers::Follow<'a> for Rotator {
            type Inner = &'a Rotator;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Rotator>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Rotator {
            type Inner = &'a Rotator;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Rotator>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Rotator {
            type Output = Rotator;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = ::core::slice::from_raw_parts(
                    self as *const Rotator as *const u8,
                    Self::size(),
                );
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Rotator {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Rotator {
            #[allow(clippy::too_many_arguments)]
            pub fn new(pitch: f32, yaw: f32, roll: f32) -> Self {
                let mut s = Self([0; 12]);
                s.set_pitch(pitch);
                s.set_yaw(yaw);
                s.set_roll(roll);
                s
            }

            pub fn pitch(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_pitch(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn yaw(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_yaw(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn roll(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_roll(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> RotatorObject {
                RotatorObject {
                    pitch: self.pitch(),
                    yaw: self.yaw(),
                    roll: self.roll(),
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct RotatorObject {
            pub pitch: f32,
            pub yaw: f32,
            pub roll: f32,
        }
        impl RotatorObject {
            pub fn pack(&self) -> Rotator {
                Rotator::new(self.pitch, self.yaw, self.roll)
            }
        }

        /// Expresses the rotation state of an object.
        /// Learn about quaternions here: https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation
        /// You can tinker with them here to build an intuition: https://quaternions.online/
        // struct Quaternion, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Quaternion(pub [u8; 16]);
        impl Default for Quaternion {
            fn default() -> Self {
                Self([0; 16])
            }
        }
        impl core::fmt::Debug for Quaternion {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Quaternion")
                    .field("x", &self.x())
                    .field("y", &self.y())
                    .field("z", &self.z())
                    .field("w", &self.w())
                    .finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Quaternion {}
        impl<'a> flatbuffers::Follow<'a> for Quaternion {
            type Inner = &'a Quaternion;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Quaternion>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Quaternion {
            type Inner = &'a Quaternion;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Quaternion>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Quaternion {
            type Output = Quaternion;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src = ::core::slice::from_raw_parts(
                    self as *const Quaternion as *const u8,
                    Self::size(),
                );
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Quaternion {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Quaternion {
            #[allow(clippy::too_many_arguments)]
            pub fn new(x: f32, y: f32, z: f32, w: f32) -> Self {
                let mut s = Self([0; 16]);
                s.set_x(x);
                s.set_y(y);
                s.set_z(z);
                s.set_w(w);
                s
            }

            pub fn x(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_x(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn y(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[4..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_y(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[4..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn z(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[8..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_z(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[8..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn w(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[12..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_w(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[12..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> QuaternionObject {
                QuaternionObject {
                    x: self.x(),
                    y: self.y(),
                    z: self.z(),
                    w: self.w(),
                }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct QuaternionObject {
            pub x: f32,
            pub y: f32,
            pub z: f32,
            pub w: f32,
        }
        impl QuaternionObject {
            pub fn pack(&self) -> Quaternion {
                Quaternion::new(self.x, self.y, self.z, self.w)
            }
        }

        // struct Float, aligned to 4
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Float(pub [u8; 4]);
        impl Default for Float {
            fn default() -> Self {
                Self([0; 4])
            }
        }
        impl core::fmt::Debug for Float {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Float").field("val", &self.val()).finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Float {}
        impl<'a> flatbuffers::Follow<'a> for Float {
            type Inner = &'a Float;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Float>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Float {
            type Inner = &'a Float;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Float>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Float {
            type Output = Float;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src =
                    ::core::slice::from_raw_parts(self as *const Float as *const u8, Self::size());
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Float {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Float {
            #[allow(clippy::too_many_arguments)]
            pub fn new(val: f32) -> Self {
                let mut s = Self([0; 4]);
                s.set_val(val);
                s
            }

            pub fn val(&self) -> f32 {
                let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_val(&mut self, x: f32) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> FloatObject {
                FloatObject { val: self.val() }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct FloatObject {
            pub val: f32,
        }
        impl FloatObject {
            pub fn pack(&self) -> Float {
                Float::new(self.val)
            }
        }

        // struct Bool, aligned to 1
        #[repr(transparent)]
        #[derive(Clone, Copy, PartialEq)]
        pub struct Bool(pub [u8; 1]);
        impl Default for Bool {
            fn default() -> Self {
                Self([0; 1])
            }
        }
        impl core::fmt::Debug for Bool {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bool").field("val", &self.val()).finish()
            }
        }

        impl flatbuffers::SimpleToVerifyInSlice for Bool {}
        impl<'a> flatbuffers::Follow<'a> for Bool {
            type Inner = &'a Bool;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                <&'a Bool>::follow(buf, loc)
            }
        }
        impl<'a> flatbuffers::Follow<'a> for &'a Bool {
            type Inner = &'a Bool;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                flatbuffers::follow_cast_ref::<Bool>(buf, loc)
            }
        }
        impl<'b> flatbuffers::Push for Bool {
            type Output = Bool;
            #[inline]
            unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                let src =
                    ::core::slice::from_raw_parts(self as *const Bool as *const u8, Self::size());
                dst.copy_from_slice(src);
            }
        }

        impl<'a> flatbuffers::Verifiable for Bool {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.in_buffer::<Self>(pos)
            }
        }

        impl<'a> Bool {
            #[allow(clippy::too_many_arguments)]
            pub fn new(val: bool) -> Self {
                let mut s = Self([0; 1]);
                s.set_val(val);
                s
            }

            pub fn val(&self) -> bool {
                let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                EndianScalar::from_little_endian(unsafe {
                    core::ptr::copy_nonoverlapping(
                        self.0[0..].as_ptr(),
                        mem.as_mut_ptr() as *mut u8,
                        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
                    );
                    mem.assume_init()
                })
            }

            pub fn set_val(&mut self, x: bool) {
                let x_le = x.to_little_endian();
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid value in this slot
                unsafe {
                    core::ptr::copy_nonoverlapping(
                        &x_le as *const _ as *const u8,
                        self.0[0..].as_mut_ptr(),
                        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
                    );
                }
            }

            pub fn unpack(&self) -> BoolObject {
                BoolObject { val: self.val() }
            }
        }

        #[derive(Debug, Clone, PartialEq, Default)]
        pub struct BoolObject {
            pub val: bool,
        }
        impl BoolObject {
            pub fn pack(&self) -> Bool {
                Bool::new(self.val)
            }
        }

        pub enum ControllerStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ControllerState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ControllerState<'a> {
            type Inner = ControllerState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ControllerState<'a> {
            pub const VT_THROTTLE: flatbuffers::VOffsetT = 4;
            pub const VT_STEER: flatbuffers::VOffsetT = 6;
            pub const VT_PITCH: flatbuffers::VOffsetT = 8;
            pub const VT_YAW: flatbuffers::VOffsetT = 10;
            pub const VT_ROLL: flatbuffers::VOffsetT = 12;
            pub const VT_JUMP: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;
            pub const VT_HANDBRAKE: flatbuffers::VOffsetT = 18;
            pub const VT_USEITEM: flatbuffers::VOffsetT = 20;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ControllerState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ControllerStateArgs,
            ) -> flatbuffers::WIPOffset<ControllerState<'bldr>> {
                let mut builder = ControllerStateBuilder::new(_fbb);
                builder.add_roll(args.roll);
                builder.add_yaw(args.yaw);
                builder.add_pitch(args.pitch);
                builder.add_steer(args.steer);
                builder.add_throttle(args.throttle);
                builder.add_useItem(args.useItem);
                builder.add_handbrake(args.handbrake);
                builder.add_boost(args.boost);
                builder.add_jump(args.jump);
                builder.finish()
            }

            pub fn unpack(&self) -> ControllerStateObject {
                let throttle = self.throttle();
                let steer = self.steer();
                let pitch = self.pitch();
                let yaw = self.yaw();
                let roll = self.roll();
                let jump = self.jump();
                let boost = self.boost();
                let handbrake = self.handbrake();
                let useItem = self.useItem();
                ControllerStateObject {
                    throttle,
                    steer,
                    pitch,
                    yaw,
                    roll,
                    jump,
                    boost,
                    handbrake,
                    useItem,
                }
            }

            /// -1 for full reverse, 1 for full forward
            #[inline]
            pub fn throttle(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(ControllerState::VT_THROTTLE, Some(0.0))
                        .unwrap()
                }
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn steer(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(ControllerState::VT_STEER, Some(0.0))
                        .unwrap()
                }
            }
            /// -1 for nose down, 1 for nose up
            #[inline]
            pub fn pitch(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(ControllerState::VT_PITCH, Some(0.0))
                        .unwrap()
                }
            }
            /// -1 for full left, 1 for full right
            #[inline]
            pub fn yaw(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(ControllerState::VT_YAW, Some(0.0))
                        .unwrap()
                }
            }
            /// -1 for roll left, 1 for roll right
            #[inline]
            pub fn roll(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(ControllerState::VT_ROLL, Some(0.0))
                        .unwrap()
                }
            }
            /// true if you want to press the jump button
            #[inline]
            pub fn jump(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ControllerState::VT_JUMP, Some(false))
                        .unwrap()
                }
            }
            /// true if you want to press the boost button
            #[inline]
            pub fn boost(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ControllerState::VT_BOOST, Some(false))
                        .unwrap()
                }
            }
            /// true if you want to press the handbrake button
            #[inline]
            pub fn handbrake(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ControllerState::VT_HANDBRAKE, Some(false))
                        .unwrap()
                }
            }
            /// true if you want to press the 'use item' button, used in rumble etc.
            #[inline]
            pub fn useItem(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ControllerState::VT_USEITEM, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ControllerState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("throttle", Self::VT_THROTTLE, false)?
                    .visit_field::<f32>("steer", Self::VT_STEER, false)?
                    .visit_field::<f32>("pitch", Self::VT_PITCH, false)?
                    .visit_field::<f32>("yaw", Self::VT_YAW, false)?
                    .visit_field::<f32>("roll", Self::VT_ROLL, false)?
                    .visit_field::<bool>("jump", Self::VT_JUMP, false)?
                    .visit_field::<bool>("boost", Self::VT_BOOST, false)?
                    .visit_field::<bool>("handbrake", Self::VT_HANDBRAKE, false)?
                    .visit_field::<bool>("useItem", Self::VT_USEITEM, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ControllerStateArgs {
            pub throttle: f32,
            pub steer: f32,
            pub pitch: f32,
            pub yaw: f32,
            pub roll: f32,
            pub jump: bool,
            pub boost: bool,
            pub handbrake: bool,
            pub useItem: bool,
        }
        impl<'a> Default for ControllerStateArgs {
            #[inline]
            fn default() -> Self {
                ControllerStateArgs {
                    throttle: 0.0,
                    steer: 0.0,
                    pitch: 0.0,
                    yaw: 0.0,
                    roll: 0.0,
                    jump: false,
                    boost: false,
                    handbrake: false,
                    useItem: false,
                }
            }
        }

        pub struct ControllerStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ControllerStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_throttle(&mut self, throttle: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_THROTTLE, throttle, 0.0);
            }
            #[inline]
            pub fn add_steer(&mut self, steer: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_STEER, steer, 0.0);
            }
            #[inline]
            pub fn add_pitch(&mut self, pitch: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_PITCH, pitch, 0.0);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_YAW, yaw, 0.0);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: f32) {
                self.fbb_
                    .push_slot::<f32>(ControllerState::VT_ROLL, roll, 0.0);
            }
            #[inline]
            pub fn add_jump(&mut self, jump: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_JUMP, jump, false);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_BOOST, boost, false);
            }
            #[inline]
            pub fn add_handbrake(&mut self, handbrake: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_HANDBRAKE, handbrake, false);
            }
            #[inline]
            pub fn add_useItem(&mut self, useItem: bool) {
                self.fbb_
                    .push_slot::<bool>(ControllerState::VT_USEITEM, useItem, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ControllerStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ControllerStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ControllerState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ControllerState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ControllerState");
                ds.field("throttle", &self.throttle());
                ds.field("steer", &self.steer());
                ds.field("pitch", &self.pitch());
                ds.field("yaw", &self.yaw());
                ds.field("roll", &self.roll());
                ds.field("jump", &self.jump());
                ds.field("boost", &self.boost());
                ds.field("handbrake", &self.handbrake());
                ds.field("useItem", &self.useItem());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct ControllerStateObject {
            pub throttle: f32,
            pub steer: f32,
            pub pitch: f32,
            pub yaw: f32,
            pub roll: f32,
            pub jump: bool,
            pub boost: bool,
            pub handbrake: bool,
            pub useItem: bool,
        }
        impl Default for ControllerStateObject {
            fn default() -> Self {
                Self {
                    throttle: 0.0,
                    steer: 0.0,
                    pitch: 0.0,
                    yaw: 0.0,
                    roll: 0.0,
                    jump: false,
                    boost: false,
                    handbrake: false,
                    useItem: false,
                }
            }
        }
        impl ControllerStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<ControllerState<'b>> {
                let throttle = self.throttle;
                let steer = self.steer;
                let pitch = self.pitch;
                let yaw = self.yaw;
                let roll = self.roll;
                let jump = self.jump;
                let boost = self.boost;
                let handbrake = self.handbrake;
                let useItem = self.useItem;
                ControllerState::create(
                    _fbb,
                    &ControllerStateArgs {
                        throttle,
                        steer,
                        pitch,
                        yaw,
                        roll,
                        jump,
                        boost,
                        handbrake,
                        useItem,
                    },
                )
            }
        }
        pub enum PlayerInputOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PlayerInput<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInput<'a> {
            type Inner = PlayerInput<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerInput<'a> {
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInput { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInputArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInput<'bldr>> {
                let mut builder = PlayerInputBuilder::new(_fbb);
                if let Some(x) = args.controllerState {
                    builder.add_controllerState(x);
                }
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerInputObject {
                let playerIndex = self.playerIndex();
                let controllerState = self.controllerState().map(|x| Box::new(x.unpack()));
                PlayerInputObject {
                    playerIndex,
                    controllerState,
                }
            }

            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerInput::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn controllerState(&self) -> Option<ControllerState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<ControllerState>>(
                            PlayerInput::VT_CONTROLLERSTATE,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerInput<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>(
                        "controllerState",
                        Self::VT_CONTROLLERSTATE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerInputArgs<'a> {
            pub playerIndex: i32,
            pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
        }
        impl<'a> Default for PlayerInputArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInputArgs {
                    playerIndex: 0,
                    controllerState: None,
                }
            }
        }

        pub struct PlayerInputBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInputBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerInput::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_controllerState(
                &mut self,
                controllerState: flatbuffers::WIPOffset<ControllerState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(
                        PlayerInput::VT_CONTROLLERSTATE,
                        controllerState,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInputBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInputBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInput<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerInput<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerInput");
                ds.field("playerIndex", &self.playerIndex());
                ds.field("controllerState", &self.controllerState());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerInputObject {
            pub playerIndex: i32,
            pub controllerState: Option<Box<ControllerStateObject>>,
        }
        impl Default for PlayerInputObject {
            fn default() -> Self {
                Self {
                    playerIndex: 0,
                    controllerState: None,
                }
            }
        }
        impl PlayerInputObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerInput<'b>> {
                let playerIndex = self.playerIndex;
                let controllerState = self.controllerState.as_ref().map(|x| x.pack(_fbb));
                PlayerInput::create(
                    _fbb,
                    &PlayerInputArgs {
                        playerIndex,
                        controllerState,
                    },
                )
            }
        }
        pub enum BoxShapeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BoxShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoxShape<'a> {
            type Inner = BoxShape<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BoxShape<'a> {
            pub const VT_LENGTH: flatbuffers::VOffsetT = 4;
            pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoxShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoxShapeArgs,
            ) -> flatbuffers::WIPOffset<BoxShape<'bldr>> {
                let mut builder = BoxShapeBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_width(args.width);
                builder.add_length(args.length);
                builder.finish()
            }

            pub fn unpack(&self) -> BoxShapeObject {
                let length = self.length();
                let width = self.width();
                let height = self.height();
                BoxShapeObject {
                    length,
                    width,
                    height,
                }
            }

            #[inline]
            pub fn length(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(BoxShape::VT_LENGTH, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn width(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<f32>(BoxShape::VT_WIDTH, Some(0.0)).unwrap() }
            }
            #[inline]
            pub fn height(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(BoxShape::VT_HEIGHT, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for BoxShape<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("length", Self::VT_LENGTH, false)?
                    .visit_field::<f32>("width", Self::VT_WIDTH, false)?
                    .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BoxShapeArgs {
            pub length: f32,
            pub width: f32,
            pub height: f32,
        }
        impl<'a> Default for BoxShapeArgs {
            #[inline]
            fn default() -> Self {
                BoxShapeArgs {
                    length: 0.0,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }

        pub struct BoxShapeBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoxShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_length(&mut self, length: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_LENGTH, length, 0.0);
            }
            #[inline]
            pub fn add_width(&mut self, width: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_WIDTH, width, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_.push_slot::<f32>(BoxShape::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoxShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoxShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoxShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BoxShape<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BoxShape");
                ds.field("length", &self.length());
                ds.field("width", &self.width());
                ds.field("height", &self.height());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BoxShapeObject {
            pub length: f32,
            pub width: f32,
            pub height: f32,
        }
        impl Default for BoxShapeObject {
            fn default() -> Self {
                Self {
                    length: 0.0,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }
        impl BoxShapeObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BoxShape<'b>> {
                let length = self.length;
                let width = self.width;
                let height = self.height;
                BoxShape::create(
                    _fbb,
                    &BoxShapeArgs {
                        length,
                        width,
                        height,
                    },
                )
            }
        }
        pub enum SphereShapeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct SphereShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for SphereShape<'a> {
            type Inner = SphereShape<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> SphereShape<'a> {
            pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                SphereShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args SphereShapeArgs,
            ) -> flatbuffers::WIPOffset<SphereShape<'bldr>> {
                let mut builder = SphereShapeBuilder::new(_fbb);
                builder.add_diameter(args.diameter);
                builder.finish()
            }

            pub fn unpack(&self) -> SphereShapeObject {
                let diameter = self.diameter();
                SphereShapeObject { diameter }
            }

            #[inline]
            pub fn diameter(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(SphereShape::VT_DIAMETER, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for SphereShape<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("diameter", Self::VT_DIAMETER, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct SphereShapeArgs {
            pub diameter: f32,
        }
        impl<'a> Default for SphereShapeArgs {
            #[inline]
            fn default() -> Self {
                SphereShapeArgs { diameter: 0.0 }
            }
        }

        pub struct SphereShapeBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> SphereShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_diameter(&mut self, diameter: f32) {
                self.fbb_
                    .push_slot::<f32>(SphereShape::VT_DIAMETER, diameter, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> SphereShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                SphereShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<SphereShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for SphereShape<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("SphereShape");
                ds.field("diameter", &self.diameter());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct SphereShapeObject {
            pub diameter: f32,
        }
        impl Default for SphereShapeObject {
            fn default() -> Self {
                Self { diameter: 0.0 }
            }
        }
        impl SphereShapeObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<SphereShape<'b>> {
                let diameter = self.diameter;
                SphereShape::create(_fbb, &SphereShapeArgs { diameter })
            }
        }
        pub enum CylinderShapeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct CylinderShape<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for CylinderShape<'a> {
            type Inner = CylinderShape<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> CylinderShape<'a> {
            pub const VT_DIAMETER: flatbuffers::VOffsetT = 4;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                CylinderShape { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args CylinderShapeArgs,
            ) -> flatbuffers::WIPOffset<CylinderShape<'bldr>> {
                let mut builder = CylinderShapeBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_diameter(args.diameter);
                builder.finish()
            }

            pub fn unpack(&self) -> CylinderShapeObject {
                let diameter = self.diameter();
                let height = self.height();
                CylinderShapeObject { diameter, height }
            }

            #[inline]
            pub fn diameter(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(CylinderShape::VT_DIAMETER, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn height(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(CylinderShape::VT_HEIGHT, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for CylinderShape<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("diameter", Self::VT_DIAMETER, false)?
                    .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct CylinderShapeArgs {
            pub diameter: f32,
            pub height: f32,
        }
        impl<'a> Default for CylinderShapeArgs {
            #[inline]
            fn default() -> Self {
                CylinderShapeArgs {
                    diameter: 0.0,
                    height: 0.0,
                }
            }
        }

        pub struct CylinderShapeBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> CylinderShapeBuilder<'a, 'b> {
            #[inline]
            pub fn add_diameter(&mut self, diameter: f32) {
                self.fbb_
                    .push_slot::<f32>(CylinderShape::VT_DIAMETER, diameter, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_
                    .push_slot::<f32>(CylinderShape::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> CylinderShapeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                CylinderShapeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<CylinderShape<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for CylinderShape<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("CylinderShape");
                ds.field("diameter", &self.diameter());
                ds.field("height", &self.height());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct CylinderShapeObject {
            pub diameter: f32,
            pub height: f32,
        }
        impl Default for CylinderShapeObject {
            fn default() -> Self {
                Self {
                    diameter: 0.0,
                    height: 0.0,
                }
            }
        }
        impl CylinderShapeObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<CylinderShape<'b>> {
                let diameter = self.diameter;
                let height = self.height;
                CylinderShape::create(_fbb, &CylinderShapeArgs { diameter, height })
            }
        }
        pub enum TouchOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Touch<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Touch<'a> {
            type Inner = Touch<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Touch<'a> {
            pub const VT_PLAYERNAME: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 8;
            pub const VT_NORMAL: flatbuffers::VOffsetT = 10;
            pub const VT_TEAM: flatbuffers::VOffsetT = 12;
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Touch { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TouchArgs<'args>,
            ) -> flatbuffers::WIPOffset<Touch<'bldr>> {
                let mut builder = TouchBuilder::new(_fbb);
                builder.add_playerIndex(args.playerIndex);
                builder.add_team(args.team);
                if let Some(x) = args.normal {
                    builder.add_normal(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                if let Some(x) = args.playerName {
                    builder.add_playerName(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> TouchObject {
                let playerName = self.playerName().map(|x| x.to_string());
                let gameSeconds = self.gameSeconds();
                let location = self.location().map(|x| x.unpack());
                let normal = self.normal().map(|x| x.unpack());
                let team = self.team();
                let playerIndex = self.playerIndex();
                TouchObject {
                    playerName,
                    gameSeconds,
                    location,
                    normal,
                    team,
                    playerIndex,
                }
            }

            /// The name of the player involved with the touch.
            #[inline]
            pub fn playerName(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(Touch::VT_PLAYERNAME, None)
                }
            }
            /// Seconds that had elapsed in the game when the touch occurred.
            #[inline]
            pub fn gameSeconds(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(Touch::VT_GAMESECONDS, Some(0.0))
                        .unwrap()
                }
            }
            /// The point of contact for the touch.
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(Touch::VT_LOCATION, None) }
            }
            /// The direction of the touch.
            #[inline]
            pub fn normal(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(Touch::VT_NORMAL, None) }
            }
            /// The Team which the touch belongs to, 0 for blue 1 for orange.
            #[inline]
            pub fn team(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(Touch::VT_TEAM, Some(0)).unwrap() }
            }
            /// The index of the player involved with the touch.
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(Touch::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for Touch<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "playerName",
                        Self::VT_PLAYERNAME,
                        false,
                    )?
                    .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Vector3>("normal", Self::VT_NORMAL, false)?
                    .visit_field::<i32>("team", Self::VT_TEAM, false)?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TouchArgs<'a> {
            pub playerName: Option<flatbuffers::WIPOffset<&'a str>>,
            pub gameSeconds: f32,
            pub location: Option<&'a Vector3>,
            pub normal: Option<&'a Vector3>,
            pub team: i32,
            pub playerIndex: i32,
        }
        impl<'a> Default for TouchArgs<'a> {
            #[inline]
            fn default() -> Self {
                TouchArgs {
                    playerName: None,
                    gameSeconds: 0.0,
                    location: None,
                    normal: None,
                    team: 0,
                    playerIndex: 0,
                }
            }
        }

        pub struct TouchBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TouchBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerName(&mut self, playerName: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    Touch::VT_PLAYERNAME,
                    playerName,
                );
            }
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(Touch::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_normal(&mut self, normal: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Touch::VT_NORMAL, normal);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(Touch::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(Touch::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TouchBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TouchBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Touch<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Touch<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Touch");
                ds.field("playerName", &self.playerName());
                ds.field("gameSeconds", &self.gameSeconds());
                ds.field("location", &self.location());
                ds.field("normal", &self.normal());
                ds.field("team", &self.team());
                ds.field("playerIndex", &self.playerIndex());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct TouchObject {
            pub playerName: Option<String>,
            pub gameSeconds: f32,
            pub location: Option<Vector3Object>,
            pub normal: Option<Vector3Object>,
            pub team: i32,
            pub playerIndex: i32,
        }
        impl Default for TouchObject {
            fn default() -> Self {
                Self {
                    playerName: None,
                    gameSeconds: 0.0,
                    location: None,
                    normal: None,
                    team: 0,
                    playerIndex: 0,
                }
            }
        }
        impl TouchObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Touch<'b>> {
                let playerName = self.playerName.as_ref().map(|x| _fbb.create_string(x));
                let gameSeconds = self.gameSeconds;
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let normal_tmp = self.normal.as_ref().map(|x| x.pack());
                let normal = normal_tmp.as_ref();
                let team = self.team;
                let playerIndex = self.playerIndex;
                Touch::create(
                    _fbb,
                    &TouchArgs {
                        playerName,
                        gameSeconds,
                        location,
                        normal,
                        team,
                        playerIndex,
                    },
                )
            }
        }
        pub enum ScoreInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct ScoreInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ScoreInfo<'a> {
            type Inner = ScoreInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ScoreInfo<'a> {
            pub const VT_SCORE: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;
            pub const VT_OWNGOALS: flatbuffers::VOffsetT = 8;
            pub const VT_ASSISTS: flatbuffers::VOffsetT = 10;
            pub const VT_SAVES: flatbuffers::VOffsetT = 12;
            pub const VT_SHOTS: flatbuffers::VOffsetT = 14;
            pub const VT_DEMOLITIONS: flatbuffers::VOffsetT = 16;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ScoreInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ScoreInfoArgs,
            ) -> flatbuffers::WIPOffset<ScoreInfo<'bldr>> {
                let mut builder = ScoreInfoBuilder::new(_fbb);
                builder.add_demolitions(args.demolitions);
                builder.add_shots(args.shots);
                builder.add_saves(args.saves);
                builder.add_assists(args.assists);
                builder.add_ownGoals(args.ownGoals);
                builder.add_goals(args.goals);
                builder.add_score(args.score);
                builder.finish()
            }

            pub fn unpack(&self) -> ScoreInfoObject {
                let score = self.score();
                let goals = self.goals();
                let ownGoals = self.ownGoals();
                let assists = self.assists();
                let saves = self.saves();
                let shots = self.shots();
                let demolitions = self.demolitions();
                ScoreInfoObject {
                    score,
                    goals,
                    ownGoals,
                    assists,
                    saves,
                    shots,
                    demolitions,
                }
            }

            #[inline]
            pub fn score(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(ScoreInfo::VT_SCORE, Some(0)).unwrap() }
            }
            #[inline]
            pub fn goals(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(ScoreInfo::VT_GOALS, Some(0)).unwrap() }
            }
            #[inline]
            pub fn ownGoals(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(ScoreInfo::VT_OWNGOALS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn assists(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(ScoreInfo::VT_ASSISTS, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn saves(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(ScoreInfo::VT_SAVES, Some(0)).unwrap() }
            }
            #[inline]
            pub fn shots(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(ScoreInfo::VT_SHOTS, Some(0)).unwrap() }
            }
            #[inline]
            pub fn demolitions(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(ScoreInfo::VT_DEMOLITIONS, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ScoreInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("score", Self::VT_SCORE, false)?
                    .visit_field::<i32>("goals", Self::VT_GOALS, false)?
                    .visit_field::<i32>("ownGoals", Self::VT_OWNGOALS, false)?
                    .visit_field::<i32>("assists", Self::VT_ASSISTS, false)?
                    .visit_field::<i32>("saves", Self::VT_SAVES, false)?
                    .visit_field::<i32>("shots", Self::VT_SHOTS, false)?
                    .visit_field::<i32>("demolitions", Self::VT_DEMOLITIONS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ScoreInfoArgs {
            pub score: i32,
            pub goals: i32,
            pub ownGoals: i32,
            pub assists: i32,
            pub saves: i32,
            pub shots: i32,
            pub demolitions: i32,
        }
        impl<'a> Default for ScoreInfoArgs {
            #[inline]
            fn default() -> Self {
                ScoreInfoArgs {
                    score: 0,
                    goals: 0,
                    ownGoals: 0,
                    assists: 0,
                    saves: 0,
                    shots: 0,
                    demolitions: 0,
                }
            }
        }

        pub struct ScoreInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ScoreInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_score(&mut self, score: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SCORE, score, 0);
            }
            #[inline]
            pub fn add_goals(&mut self, goals: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_GOALS, goals, 0);
            }
            #[inline]
            pub fn add_ownGoals(&mut self, ownGoals: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_OWNGOALS, ownGoals, 0);
            }
            #[inline]
            pub fn add_assists(&mut self, assists: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_ASSISTS, assists, 0);
            }
            #[inline]
            pub fn add_saves(&mut self, saves: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SAVES, saves, 0);
            }
            #[inline]
            pub fn add_shots(&mut self, shots: i32) {
                self.fbb_.push_slot::<i32>(ScoreInfo::VT_SHOTS, shots, 0);
            }
            #[inline]
            pub fn add_demolitions(&mut self, demolitions: i32) {
                self.fbb_
                    .push_slot::<i32>(ScoreInfo::VT_DEMOLITIONS, demolitions, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ScoreInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ScoreInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ScoreInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ScoreInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ScoreInfo");
                ds.field("score", &self.score());
                ds.field("goals", &self.goals());
                ds.field("ownGoals", &self.ownGoals());
                ds.field("assists", &self.assists());
                ds.field("saves", &self.saves());
                ds.field("shots", &self.shots());
                ds.field("demolitions", &self.demolitions());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct ScoreInfoObject {
            pub score: i32,
            pub goals: i32,
            pub ownGoals: i32,
            pub assists: i32,
            pub saves: i32,
            pub shots: i32,
            pub demolitions: i32,
        }
        impl Default for ScoreInfoObject {
            fn default() -> Self {
                Self {
                    score: 0,
                    goals: 0,
                    ownGoals: 0,
                    assists: 0,
                    saves: 0,
                    shots: 0,
                    demolitions: 0,
                }
            }
        }
        impl ScoreInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<ScoreInfo<'b>> {
                let score = self.score;
                let goals = self.goals;
                let ownGoals = self.ownGoals;
                let assists = self.assists;
                let saves = self.saves;
                let shots = self.shots;
                let demolitions = self.demolitions;
                ScoreInfo::create(
                    _fbb,
                    &ScoreInfoArgs {
                        score,
                        goals,
                        ownGoals,
                        assists,
                        saves,
                        shots,
                        demolitions,
                    },
                )
            }
        }
        pub enum PhysicsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Physics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Physics<'a> {
            type Inner = Physics<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Physics<'a> {
            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Physics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PhysicsArgs<'args>,
            ) -> flatbuffers::WIPOffset<Physics<'bldr>> {
                let mut builder = PhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> PhysicsObject {
                let location = self.location().map(|x| x.unpack());
                let rotation = self.rotation().map(|x| x.unpack());
                let velocity = self.velocity().map(|x| x.unpack());
                let angularVelocity = self.angularVelocity().map(|x| x.unpack());
                PhysicsObject {
                    location,
                    rotation,
                    velocity,
                    angularVelocity,
                }
            }

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(Physics::VT_LOCATION, None) }
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Rotator> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Rotator>(Physics::VT_ROTATION, None) }
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(Physics::VT_VELOCITY, None) }
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(Physics::VT_ANGULARVELOCITY, None) }
            }
        }

        impl flatbuffers::Verifiable for Physics<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Rotator>("rotation", Self::VT_ROTATION, false)?
                    .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
                    .visit_field::<Vector3>("angularVelocity", Self::VT_ANGULARVELOCITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PhysicsArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub angularVelocity: Option<&'a Vector3>,
        }
        impl<'a> Default for PhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                PhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }

        pub struct PhysicsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(Physics::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_angularVelocity(&mut self, angularVelocity: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(Physics::VT_ANGULARVELOCITY, angularVelocity);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Physics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Physics<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Physics");
                ds.field("location", &self.location());
                ds.field("rotation", &self.rotation());
                ds.field("velocity", &self.velocity());
                ds.field("angularVelocity", &self.angularVelocity());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PhysicsObject {
            pub location: Option<Vector3Object>,
            pub rotation: Option<RotatorObject>,
            pub velocity: Option<Vector3Object>,
            pub angularVelocity: Option<Vector3Object>,
        }
        impl Default for PhysicsObject {
            fn default() -> Self {
                Self {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        impl PhysicsObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Physics<'b>> {
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let rotation_tmp = self.rotation.as_ref().map(|x| x.pack());
                let rotation = rotation_tmp.as_ref();
                let velocity_tmp = self.velocity.as_ref().map(|x| x.pack());
                let velocity = velocity_tmp.as_ref();
                let angularVelocity_tmp = self.angularVelocity.as_ref().map(|x| x.pack());
                let angularVelocity = angularVelocity_tmp.as_ref();
                Physics::create(
                    _fbb,
                    &PhysicsArgs {
                        location,
                        rotation,
                        velocity,
                        angularVelocity,
                    },
                )
            }
        }
        pub enum PlayerInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PlayerInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInfo<'a> {
            type Inner = PlayerInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerInfo<'a> {
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_SCOREINFO: flatbuffers::VOffsetT = 6;
            pub const VT_ISDEMOLISHED: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_ISBOT: flatbuffers::VOffsetT = 14;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 16;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 18;
            pub const VT_NAME: flatbuffers::VOffsetT = 20;
            pub const VT_TEAM: flatbuffers::VOffsetT = 22;
            pub const VT_BOOST: flatbuffers::VOffsetT = 24;
            pub const VT_HITBOX: flatbuffers::VOffsetT = 26;
            pub const VT_HITBOXOFFSET: flatbuffers::VOffsetT = 28;
            pub const VT_SPAWNID: flatbuffers::VOffsetT = 30;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInfo<'bldr>> {
                let mut builder = PlayerInfoBuilder::new(_fbb);
                builder.add_spawnId(args.spawnId);
                if let Some(x) = args.hitboxOffset {
                    builder.add_hitboxOffset(x);
                }
                if let Some(x) = args.hitbox {
                    builder.add_hitbox(x);
                }
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.scoreInfo {
                    builder.add_scoreInfo(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_doubleJumped(args.doubleJumped);
                builder.add_jumped(args.jumped);
                builder.add_isBot(args.isBot);
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.add_isDemolished(args.isDemolished);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerInfoObject {
                let physics = self.physics().map(|x| Box::new(x.unpack()));
                let scoreInfo = self.scoreInfo().map(|x| Box::new(x.unpack()));
                let isDemolished = self.isDemolished();
                let hasWheelContact = self.hasWheelContact();
                let isSupersonic = self.isSupersonic();
                let isBot = self.isBot();
                let jumped = self.jumped();
                let doubleJumped = self.doubleJumped();
                let name = self.name().map(|x| x.to_string());
                let team = self.team();
                let boost = self.boost();
                let hitbox = self.hitbox().map(|x| Box::new(x.unpack()));
                let hitboxOffset = self.hitboxOffset().map(|x| x.unpack());
                let spawnId = self.spawnId();
                PlayerInfoObject {
                    physics,
                    scoreInfo,
                    isDemolished,
                    hasWheelContact,
                    isSupersonic,
                    isBot,
                    jumped,
                    doubleJumped,
                    name,
                    team,
                    boost,
                    hitbox,
                    hitboxOffset,
                    spawnId,
                }
            }

            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Physics>>(PlayerInfo::VT_PHYSICS, None)
                }
            }
            #[inline]
            pub fn scoreInfo(&self) -> Option<ScoreInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<ScoreInfo>>(
                        PlayerInfo::VT_SCOREINFO,
                        None,
                    )
                }
            }
            #[inline]
            pub fn isDemolished(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_ISDEMOLISHED, Some(false))
                        .unwrap()
                }
            }
            /// True if your wheels are on the ground, the wall, or the ceiling. False if you're midair or turtling.
            #[inline]
            pub fn hasWheelContact(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_HASWHEELCONTACT, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn isSupersonic(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_ISSUPERSONIC, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn isBot(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_ISBOT, Some(false))
                        .unwrap()
                }
            }
            /// True if the player has jumped. Falling off the ceiling / driving off the goal post does not count.
            #[inline]
            pub fn jumped(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_JUMPED, Some(false))
                        .unwrap()
                }
            }
            ///  True if player has double jumped. False does not mean you have a jump remaining, because the
            ///  aerial timer can run out, and that doesn't affect this flag.
            #[inline]
            pub fn doubleJumped(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(PlayerInfo::VT_DOUBLEJUMPED, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(PlayerInfo::VT_NAME, None)
                }
            }
            #[inline]
            pub fn team(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(PlayerInfo::VT_TEAM, Some(0)).unwrap() }
            }
            #[inline]
            pub fn boost(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(PlayerInfo::VT_BOOST, Some(0)).unwrap() }
            }
            #[inline]
            pub fn hitbox(&self) -> Option<BoxShape<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<BoxShape>>(PlayerInfo::VT_HITBOX, None)
                }
            }
            #[inline]
            pub fn hitboxOffset(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(PlayerInfo::VT_HITBOXOFFSET, None) }
            }
            /// In the case where the requested player index is not available, spawnId will help
            /// the framework figure out what index was actually assigned to this player instead.
            #[inline]
            pub fn spawnId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerInfo::VT_SPAWNID, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<Physics>>(
                        "physics",
                        Self::VT_PHYSICS,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<ScoreInfo>>(
                        "scoreInfo",
                        Self::VT_SCOREINFO,
                        false,
                    )?
                    .visit_field::<bool>("isDemolished", Self::VT_ISDEMOLISHED, false)?
                    .visit_field::<bool>("hasWheelContact", Self::VT_HASWHEELCONTACT, false)?
                    .visit_field::<bool>("isSupersonic", Self::VT_ISSUPERSONIC, false)?
                    .visit_field::<bool>("isBot", Self::VT_ISBOT, false)?
                    .visit_field::<bool>("jumped", Self::VT_JUMPED, false)?
                    .visit_field::<bool>("doubleJumped", Self::VT_DOUBLEJUMPED, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "name",
                        Self::VT_NAME,
                        false,
                    )?
                    .visit_field::<i32>("team", Self::VT_TEAM, false)?
                    .visit_field::<i32>("boost", Self::VT_BOOST, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<BoxShape>>(
                        "hitbox",
                        Self::VT_HITBOX,
                        false,
                    )?
                    .visit_field::<Vector3>("hitboxOffset", Self::VT_HITBOXOFFSET, false)?
                    .visit_field::<i32>("spawnId", Self::VT_SPAWNID, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub scoreInfo: Option<flatbuffers::WIPOffset<ScoreInfo<'a>>>,
            pub isDemolished: bool,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub isBot: bool,
            pub jumped: bool,
            pub doubleJumped: bool,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub team: i32,
            pub boost: i32,
            pub hitbox: Option<flatbuffers::WIPOffset<BoxShape<'a>>>,
            pub hitboxOffset: Option<&'a Vector3>,
            pub spawnId: i32,
        }
        impl<'a> Default for PlayerInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInfoArgs {
                    physics: None,
                    scoreInfo: None,
                    isDemolished: false,
                    hasWheelContact: false,
                    isSupersonic: false,
                    isBot: false,
                    jumped: false,
                    doubleJumped: false,
                    name: None,
                    team: 0,
                    boost: 0,
                    hitbox: None,
                    hitboxOffset: None,
                    spawnId: 0,
                }
            }
        }

        pub struct PlayerInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        PlayerInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_scoreInfo(&mut self, scoreInfo: flatbuffers::WIPOffset<ScoreInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ScoreInfo>>(
                        PlayerInfo::VT_SCOREINFO,
                        scoreInfo,
                    );
            }
            #[inline]
            pub fn add_isDemolished(&mut self, isDemolished: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISDEMOLISHED, isDemolished, false);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_isBot(&mut self, isBot: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_ISBOT, isBot, false);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_JUMPED, jumped, false);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: bool) {
                self.fbb_
                    .push_slot::<bool>(PlayerInfo::VT_DOUBLEJUMPED, doubleJumped, false);
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(PlayerInfo::VT_NAME, name);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(PlayerInfo::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn add_hitbox(&mut self, hitbox: flatbuffers::WIPOffset<BoxShape<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BoxShape>>(
                        PlayerInfo::VT_HITBOX,
                        hitbox,
                    );
            }
            #[inline]
            pub fn add_hitboxOffset(&mut self, hitboxOffset: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(PlayerInfo::VT_HITBOXOFFSET, hitboxOffset);
            }
            #[inline]
            pub fn add_spawnId(&mut self, spawnId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerInfo::VT_SPAWNID, spawnId, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerInfo");
                ds.field("physics", &self.physics());
                ds.field("scoreInfo", &self.scoreInfo());
                ds.field("isDemolished", &self.isDemolished());
                ds.field("hasWheelContact", &self.hasWheelContact());
                ds.field("isSupersonic", &self.isSupersonic());
                ds.field("isBot", &self.isBot());
                ds.field("jumped", &self.jumped());
                ds.field("doubleJumped", &self.doubleJumped());
                ds.field("name", &self.name());
                ds.field("team", &self.team());
                ds.field("boost", &self.boost());
                ds.field("hitbox", &self.hitbox());
                ds.field("hitboxOffset", &self.hitboxOffset());
                ds.field("spawnId", &self.spawnId());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerInfoObject {
            pub physics: Option<Box<PhysicsObject>>,
            pub scoreInfo: Option<Box<ScoreInfoObject>>,
            pub isDemolished: bool,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub isBot: bool,
            pub jumped: bool,
            pub doubleJumped: bool,
            pub name: Option<String>,
            pub team: i32,
            pub boost: i32,
            pub hitbox: Option<Box<BoxShapeObject>>,
            pub hitboxOffset: Option<Vector3Object>,
            pub spawnId: i32,
        }
        impl Default for PlayerInfoObject {
            fn default() -> Self {
                Self {
                    physics: None,
                    scoreInfo: None,
                    isDemolished: false,
                    hasWheelContact: false,
                    isSupersonic: false,
                    isBot: false,
                    jumped: false,
                    doubleJumped: false,
                    name: None,
                    team: 0,
                    boost: 0,
                    hitbox: None,
                    hitboxOffset: None,
                    spawnId: 0,
                }
            }
        }
        impl PlayerInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerInfo<'b>> {
                let physics = self.physics.as_ref().map(|x| x.pack(_fbb));
                let scoreInfo = self.scoreInfo.as_ref().map(|x| x.pack(_fbb));
                let isDemolished = self.isDemolished;
                let hasWheelContact = self.hasWheelContact;
                let isSupersonic = self.isSupersonic;
                let isBot = self.isBot;
                let jumped = self.jumped;
                let doubleJumped = self.doubleJumped;
                let name = self.name.as_ref().map(|x| _fbb.create_string(x));
                let team = self.team;
                let boost = self.boost;
                let hitbox = self.hitbox.as_ref().map(|x| x.pack(_fbb));
                let hitboxOffset_tmp = self.hitboxOffset.as_ref().map(|x| x.pack());
                let hitboxOffset = hitboxOffset_tmp.as_ref();
                let spawnId = self.spawnId;
                PlayerInfo::create(
                    _fbb,
                    &PlayerInfoArgs {
                        physics,
                        scoreInfo,
                        isDemolished,
                        hasWheelContact,
                        isSupersonic,
                        isBot,
                        jumped,
                        doubleJumped,
                        name,
                        team,
                        boost,
                        hitbox,
                        hitboxOffset,
                        spawnId,
                    },
                )
            }
        }
        pub enum DropShotBallInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DropShotBallInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DropShotBallInfo<'a> {
            type Inner = DropShotBallInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DropShotBallInfo<'a> {
            pub const VT_ABSORBEDFORCE: flatbuffers::VOffsetT = 4;
            pub const VT_DAMAGEINDEX: flatbuffers::VOffsetT = 6;
            pub const VT_FORCEACCUMRECENT: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DropShotBallInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DropShotBallInfoArgs,
            ) -> flatbuffers::WIPOffset<DropShotBallInfo<'bldr>> {
                let mut builder = DropShotBallInfoBuilder::new(_fbb);
                builder.add_forceAccumRecent(args.forceAccumRecent);
                builder.add_damageIndex(args.damageIndex);
                builder.add_absorbedForce(args.absorbedForce);
                builder.finish()
            }

            pub fn unpack(&self) -> DropShotBallInfoObject {
                let absorbedForce = self.absorbedForce();
                let damageIndex = self.damageIndex();
                let forceAccumRecent = self.forceAccumRecent();
                DropShotBallInfoObject {
                    absorbedForce,
                    damageIndex,
                    forceAccumRecent,
                }
            }

            #[inline]
            pub fn absorbedForce(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn damageIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn forceAccumRecent(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(DropShotBallInfo::VT_FORCEACCUMRECENT, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DropShotBallInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("absorbedForce", Self::VT_ABSORBEDFORCE, false)?
                    .visit_field::<i32>("damageIndex", Self::VT_DAMAGEINDEX, false)?
                    .visit_field::<f32>("forceAccumRecent", Self::VT_FORCEACCUMRECENT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DropShotBallInfoArgs {
            pub absorbedForce: f32,
            pub damageIndex: i32,
            pub forceAccumRecent: f32,
        }
        impl<'a> Default for DropShotBallInfoArgs {
            #[inline]
            fn default() -> Self {
                DropShotBallInfoArgs {
                    absorbedForce: 0.0,
                    damageIndex: 0,
                    forceAccumRecent: 0.0,
                }
            }
        }

        pub struct DropShotBallInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DropShotBallInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_absorbedForce(&mut self, absorbedForce: f32) {
                self.fbb_
                    .push_slot::<f32>(DropShotBallInfo::VT_ABSORBEDFORCE, absorbedForce, 0.0);
            }
            #[inline]
            pub fn add_damageIndex(&mut self, damageIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(DropShotBallInfo::VT_DAMAGEINDEX, damageIndex, 0);
            }
            #[inline]
            pub fn add_forceAccumRecent(&mut self, forceAccumRecent: f32) {
                self.fbb_.push_slot::<f32>(
                    DropShotBallInfo::VT_FORCEACCUMRECENT,
                    forceAccumRecent,
                    0.0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DropShotBallInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DropShotBallInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DropShotBallInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DropShotBallInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DropShotBallInfo");
                ds.field("absorbedForce", &self.absorbedForce());
                ds.field("damageIndex", &self.damageIndex());
                ds.field("forceAccumRecent", &self.forceAccumRecent());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DropShotBallInfoObject {
            pub absorbedForce: f32,
            pub damageIndex: i32,
            pub forceAccumRecent: f32,
        }
        impl Default for DropShotBallInfoObject {
            fn default() -> Self {
                Self {
                    absorbedForce: 0.0,
                    damageIndex: 0,
                    forceAccumRecent: 0.0,
                }
            }
        }
        impl DropShotBallInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DropShotBallInfo<'b>> {
                let absorbedForce = self.absorbedForce;
                let damageIndex = self.damageIndex;
                let forceAccumRecent = self.forceAccumRecent;
                DropShotBallInfo::create(
                    _fbb,
                    &DropShotBallInfoArgs {
                        absorbedForce,
                        damageIndex,
                        forceAccumRecent,
                    },
                )
            }
        }
        pub enum BallInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BallInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallInfo<'a> {
            type Inner = BallInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BallInfo<'a> {
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_LATESTTOUCH: flatbuffers::VOffsetT = 6;
            pub const VT_DROPSHOTINFO: flatbuffers::VOffsetT = 8;
            pub const VT_SHAPE_TYPE: flatbuffers::VOffsetT = 10;
            pub const VT_SHAPE: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallInfo<'bldr>> {
                let mut builder = BallInfoBuilder::new(_fbb);
                if let Some(x) = args.shape {
                    builder.add_shape(x);
                }
                if let Some(x) = args.dropShotInfo {
                    builder.add_dropShotInfo(x);
                }
                if let Some(x) = args.latestTouch {
                    builder.add_latestTouch(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_shape_type(args.shape_type);
                builder.finish()
            }

            pub fn unpack(&self) -> BallInfoObject {
                let physics = self.physics().map(|x| Box::new(x.unpack()));
                let latestTouch = self.latestTouch().map(|x| Box::new(x.unpack()));
                let dropShotInfo = self.dropShotInfo().map(|x| Box::new(x.unpack()));
                let shape = match self.shape_type() {
                    CollisionShape::NONE => CollisionShapeObject::NONE,
                    CollisionShape::BoxShape => CollisionShapeObject::BoxShape(Box::new(
                        self.shape_as_box_shape()
                            .expect("Invalid union table, expected `CollisionShape::BoxShape`.")
                            .unpack(),
                    )),
                    CollisionShape::SphereShape => CollisionShapeObject::SphereShape(Box::new(
                        self.shape_as_sphere_shape()
                            .expect("Invalid union table, expected `CollisionShape::SphereShape`.")
                            .unpack(),
                    )),
                    CollisionShape::CylinderShape => CollisionShapeObject::CylinderShape(Box::new(
                        self.shape_as_cylinder_shape()
                            .expect(
                                "Invalid union table, expected `CollisionShape::CylinderShape`.",
                            )
                            .unpack(),
                    )),
                    _ => CollisionShapeObject::NONE,
                };
                BallInfoObject {
                    physics,
                    latestTouch,
                    dropShotInfo,
                    shape,
                }
            }

            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Physics>>(BallInfo::VT_PHYSICS, None)
                }
            }
            #[inline]
            pub fn latestTouch(&self) -> Option<Touch<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Touch>>(BallInfo::VT_LATESTTOUCH, None)
                }
            }
            #[inline]
            pub fn dropShotInfo(&self) -> Option<DropShotBallInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<DropShotBallInfo>>(
                            BallInfo::VT_DROPSHOTINFO,
                            None,
                        )
                }
            }
            #[inline]
            pub fn shape_type(&self) -> CollisionShape {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<CollisionShape>(BallInfo::VT_SHAPE_TYPE, Some(CollisionShape::NONE))
                        .unwrap()
                }
            }
            #[inline]
            pub fn shape(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            BallInfo::VT_SHAPE,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_box_shape(&self) -> Option<BoxShape<'a>> {
                if self.shape_type() == CollisionShape::BoxShape {
                    self.shape().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { BoxShape::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_sphere_shape(&self) -> Option<SphereShape<'a>> {
                if self.shape_type() == CollisionShape::SphereShape {
                    self.shape().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { SphereShape::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn shape_as_cylinder_shape(&self) -> Option<CylinderShape<'a>> {
                if self.shape_type() == CollisionShape::CylinderShape {
                    self.shape().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { CylinderShape::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for BallInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Physics>>("physics", Self::VT_PHYSICS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Touch>>("latestTouch", Self::VT_LATESTTOUCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DropShotBallInfo>>("dropShotInfo", Self::VT_DROPSHOTINFO, false)?
     .visit_union::<CollisionShape, _>("shape_type", Self::VT_SHAPE_TYPE, "shape", Self::VT_SHAPE, false, |key, v, pos| {
        match key {
          CollisionShape::BoxShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BoxShape>>("CollisionShape::BoxShape", pos),
          CollisionShape::SphereShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SphereShape>>("CollisionShape::SphereShape", pos),
          CollisionShape::CylinderShape => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CylinderShape>>("CollisionShape::CylinderShape", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct BallInfoArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
            pub latestTouch: Option<flatbuffers::WIPOffset<Touch<'a>>>,
            pub dropShotInfo: Option<flatbuffers::WIPOffset<DropShotBallInfo<'a>>>,
            pub shape_type: CollisionShape,
            pub shape: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for BallInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallInfoArgs {
                    physics: None,
                    latestTouch: None,
                    dropShotInfo: None,
                    shape_type: CollisionShape::NONE,
                    shape: None,
                }
            }
        }

        pub struct BallInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        BallInfo::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_latestTouch(&mut self, latestTouch: flatbuffers::WIPOffset<Touch<'b>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Touch>>(
                    BallInfo::VT_LATESTTOUCH,
                    latestTouch,
                );
            }
            #[inline]
            pub fn add_dropShotInfo(
                &mut self,
                dropShotInfo: flatbuffers::WIPOffset<DropShotBallInfo<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DropShotBallInfo>>(
                        BallInfo::VT_DROPSHOTINFO,
                        dropShotInfo,
                    );
            }
            #[inline]
            pub fn add_shape_type(&mut self, shape_type: CollisionShape) {
                self.fbb_.push_slot::<CollisionShape>(
                    BallInfo::VT_SHAPE_TYPE,
                    shape_type,
                    CollisionShape::NONE,
                );
            }
            #[inline]
            pub fn add_shape(
                &mut self,
                shape: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(BallInfo::VT_SHAPE, shape);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BallInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BallInfo");
                ds.field("physics", &self.physics());
                ds.field("latestTouch", &self.latestTouch());
                ds.field("dropShotInfo", &self.dropShotInfo());
                ds.field("shape_type", &self.shape_type());
                match self.shape_type() {
                    CollisionShape::BoxShape => {
                        if let Some(x) = self.shape_as_box_shape() {
                            ds.field("shape", &x)
                        } else {
                            ds.field(
                                "shape",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    CollisionShape::SphereShape => {
                        if let Some(x) = self.shape_as_sphere_shape() {
                            ds.field("shape", &x)
                        } else {
                            ds.field(
                                "shape",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    CollisionShape::CylinderShape => {
                        if let Some(x) = self.shape_as_cylinder_shape() {
                            ds.field("shape", &x)
                        } else {
                            ds.field(
                                "shape",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("shape", &x)
                    }
                };
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BallInfoObject {
            pub physics: Option<Box<PhysicsObject>>,
            pub latestTouch: Option<Box<TouchObject>>,
            pub dropShotInfo: Option<Box<DropShotBallInfoObject>>,
            pub shape: CollisionShapeObject,
        }
        impl Default for BallInfoObject {
            fn default() -> Self {
                Self {
                    physics: None,
                    latestTouch: None,
                    dropShotInfo: None,
                    shape: CollisionShapeObject::NONE,
                }
            }
        }
        impl BallInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BallInfo<'b>> {
                let physics = self.physics.as_ref().map(|x| x.pack(_fbb));
                let latestTouch = self.latestTouch.as_ref().map(|x| x.pack(_fbb));
                let dropShotInfo = self.dropShotInfo.as_ref().map(|x| x.pack(_fbb));
                let shape_type = self.shape.collision_shape_type();
                let shape = self.shape.pack(_fbb);
                BallInfo::create(
                    _fbb,
                    &BallInfoArgs {
                        physics,
                        latestTouch,
                        dropShotInfo,
                        shape_type,
                        shape,
                    },
                )
            }
        }
        pub enum BoostPadStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BoostPadState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPadState<'a> {
            type Inner = BoostPadState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BoostPadState<'a> {
            pub const VT_ISACTIVE: flatbuffers::VOffsetT = 4;
            pub const VT_TIMER: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPadState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadStateArgs,
            ) -> flatbuffers::WIPOffset<BoostPadState<'bldr>> {
                let mut builder = BoostPadStateBuilder::new(_fbb);
                builder.add_timer(args.timer);
                builder.add_isActive(args.isActive);
                builder.finish()
            }

            pub fn unpack(&self) -> BoostPadStateObject {
                let isActive = self.isActive();
                let timer = self.timer();
                BoostPadStateObject { isActive, timer }
            }

            /// True if the boost can be picked up
            #[inline]
            pub fn isActive(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BoostPadState::VT_ISACTIVE, Some(false))
                        .unwrap()
                }
            }
            /// The number of seconds since the boost has been picked up, or 0.0 if the boost is active.
            #[inline]
            pub fn timer(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(BoostPadState::VT_TIMER, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for BoostPadState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<bool>("isActive", Self::VT_ISACTIVE, false)?
                    .visit_field::<f32>("timer", Self::VT_TIMER, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BoostPadStateArgs {
            pub isActive: bool,
            pub timer: f32,
        }
        impl<'a> Default for BoostPadStateArgs {
            #[inline]
            fn default() -> Self {
                BoostPadStateArgs {
                    isActive: false,
                    timer: 0.0,
                }
            }
        }

        pub struct BoostPadStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_isActive(&mut self, isActive: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPadState::VT_ISACTIVE, isActive, false);
            }
            #[inline]
            pub fn add_timer(&mut self, timer: f32) {
                self.fbb_
                    .push_slot::<f32>(BoostPadState::VT_TIMER, timer, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPadState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BoostPadState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BoostPadState");
                ds.field("isActive", &self.isActive());
                ds.field("timer", &self.timer());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BoostPadStateObject {
            pub isActive: bool,
            pub timer: f32,
        }
        impl Default for BoostPadStateObject {
            fn default() -> Self {
                Self {
                    isActive: false,
                    timer: 0.0,
                }
            }
        }
        impl BoostPadStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BoostPadState<'b>> {
                let isActive = self.isActive;
                let timer = self.timer;
                BoostPadState::create(_fbb, &BoostPadStateArgs { isActive, timer })
            }
        }
        pub enum DropshotTileOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DropshotTile<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DropshotTile<'a> {
            type Inner = DropshotTile<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DropshotTile<'a> {
            pub const VT_TILESTATE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DropshotTile { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DropshotTileArgs,
            ) -> flatbuffers::WIPOffset<DropshotTile<'bldr>> {
                let mut builder = DropshotTileBuilder::new(_fbb);
                builder.add_tileState(args.tileState);
                builder.finish()
            }

            pub fn unpack(&self) -> DropshotTileObject {
                let tileState = self.tileState();
                DropshotTileObject { tileState }
            }

            /// The amount of damage the tile has sustained.
            #[inline]
            pub fn tileState(&self) -> TileState {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<TileState>(DropshotTile::VT_TILESTATE, Some(TileState::Unknown))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for DropshotTile<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<TileState>("tileState", Self::VT_TILESTATE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DropshotTileArgs {
            pub tileState: TileState,
        }
        impl<'a> Default for DropshotTileArgs {
            #[inline]
            fn default() -> Self {
                DropshotTileArgs {
                    tileState: TileState::Unknown,
                }
            }
        }

        pub struct DropshotTileBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DropshotTileBuilder<'a, 'b> {
            #[inline]
            pub fn add_tileState(&mut self, tileState: TileState) {
                self.fbb_.push_slot::<TileState>(
                    DropshotTile::VT_TILESTATE,
                    tileState,
                    TileState::Unknown,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DropshotTileBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DropshotTileBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DropshotTile<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DropshotTile<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DropshotTile");
                ds.field("tileState", &self.tileState());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DropshotTileObject {
            pub tileState: TileState,
        }
        impl Default for DropshotTileObject {
            fn default() -> Self {
                Self {
                    tileState: TileState::Unknown,
                }
            }
        }
        impl DropshotTileObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DropshotTile<'b>> {
                let tileState = self.tileState;
                DropshotTile::create(_fbb, &DropshotTileArgs { tileState })
            }
        }
        pub enum GameInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GameInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameInfo<'a> {
            type Inner = GameInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GameInfo<'a> {
            pub const VT_SECONDSELAPSED: flatbuffers::VOffsetT = 4;
            pub const VT_GAMETIMEREMAINING: flatbuffers::VOffsetT = 6;
            pub const VT_ISOVERTIME: flatbuffers::VOffsetT = 8;
            pub const VT_ISUNLIMITEDTIME: flatbuffers::VOffsetT = 10;
            pub const VT_ISROUNDACTIVE: flatbuffers::VOffsetT = 12;
            pub const VT_ISKICKOFFPAUSE: flatbuffers::VOffsetT = 14;
            pub const VT_ISMATCHENDED: flatbuffers::VOffsetT = 16;
            pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 18;
            pub const VT_GAMESPEED: flatbuffers::VOffsetT = 20;
            pub const VT_FRAMENUM: flatbuffers::VOffsetT = 22;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameInfoArgs,
            ) -> flatbuffers::WIPOffset<GameInfo<'bldr>> {
                let mut builder = GameInfoBuilder::new(_fbb);
                builder.add_frameNum(args.frameNum);
                builder.add_gameSpeed(args.gameSpeed);
                builder.add_worldGravityZ(args.worldGravityZ);
                builder.add_gameTimeRemaining(args.gameTimeRemaining);
                builder.add_secondsElapsed(args.secondsElapsed);
                builder.add_isMatchEnded(args.isMatchEnded);
                builder.add_isKickoffPause(args.isKickoffPause);
                builder.add_isRoundActive(args.isRoundActive);
                builder.add_isUnlimitedTime(args.isUnlimitedTime);
                builder.add_isOvertime(args.isOvertime);
                builder.finish()
            }

            pub fn unpack(&self) -> GameInfoObject {
                let secondsElapsed = self.secondsElapsed();
                let gameTimeRemaining = self.gameTimeRemaining();
                let isOvertime = self.isOvertime();
                let isUnlimitedTime = self.isUnlimitedTime();
                let isRoundActive = self.isRoundActive();
                let isKickoffPause = self.isKickoffPause();
                let isMatchEnded = self.isMatchEnded();
                let worldGravityZ = self.worldGravityZ();
                let gameSpeed = self.gameSpeed();
                let frameNum = self.frameNum();
                GameInfoObject {
                    secondsElapsed,
                    gameTimeRemaining,
                    isOvertime,
                    isUnlimitedTime,
                    isRoundActive,
                    isKickoffPause,
                    isMatchEnded,
                    worldGravityZ,
                    gameSpeed,
                    frameNum,
                }
            }

            #[inline]
            pub fn secondsElapsed(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameInfo::VT_SECONDSELAPSED, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn gameTimeRemaining(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameInfo::VT_GAMETIMEREMAINING, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn isOvertime(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(GameInfo::VT_ISOVERTIME, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn isUnlimitedTime(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(GameInfo::VT_ISUNLIMITEDTIME, Some(false))
                        .unwrap()
                }
            }
            /// True when cars are allowed to move, and during the pause menu. False during replays.
            #[inline]
            pub fn isRoundActive(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(GameInfo::VT_ISROUNDACTIVE, Some(false))
                        .unwrap()
                }
            }
            /// True when the clock is paused due to kickoff, but false during kickoff countdown. In other words, it is true
            /// while cars can move during kickoff. Note that if both players sit still, game clock start and this will become false.
            #[inline]
            pub fn isKickoffPause(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(GameInfo::VT_ISKICKOFFPAUSE, Some(false))
                        .unwrap()
                }
            }
            /// Turns true after final replay, the moment the 'winner' screen appears. Remains true during next match
            /// countdown. Turns false again the moment the 'choose team' screen appears.
            #[inline]
            pub fn isMatchEnded(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(GameInfo::VT_ISMATCHENDED, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn worldGravityZ(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameInfo::VT_WORLDGRAVITYZ, Some(0.0))
                        .unwrap()
                }
            }
            /// Game speed multiplier, 1.0 is regular game speed.
            #[inline]
            pub fn gameSpeed(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GameInfo::VT_GAMESPEED, Some(0.0))
                        .unwrap()
                }
            }
            /// Tracks the number of physics frames the game has computed.
            /// May increase by more than one across consecutive packets.
            /// Data type will roll over after 207 days at 120Hz.
            #[inline]
            pub fn frameNum(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(GameInfo::VT_FRAMENUM, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for GameInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("secondsElapsed", Self::VT_SECONDSELAPSED, false)?
                    .visit_field::<f32>("gameTimeRemaining", Self::VT_GAMETIMEREMAINING, false)?
                    .visit_field::<bool>("isOvertime", Self::VT_ISOVERTIME, false)?
                    .visit_field::<bool>("isUnlimitedTime", Self::VT_ISUNLIMITEDTIME, false)?
                    .visit_field::<bool>("isRoundActive", Self::VT_ISROUNDACTIVE, false)?
                    .visit_field::<bool>("isKickoffPause", Self::VT_ISKICKOFFPAUSE, false)?
                    .visit_field::<bool>("isMatchEnded", Self::VT_ISMATCHENDED, false)?
                    .visit_field::<f32>("worldGravityZ", Self::VT_WORLDGRAVITYZ, false)?
                    .visit_field::<f32>("gameSpeed", Self::VT_GAMESPEED, false)?
                    .visit_field::<i32>("frameNum", Self::VT_FRAMENUM, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct GameInfoArgs {
            pub secondsElapsed: f32,
            pub gameTimeRemaining: f32,
            pub isOvertime: bool,
            pub isUnlimitedTime: bool,
            pub isRoundActive: bool,
            pub isKickoffPause: bool,
            pub isMatchEnded: bool,
            pub worldGravityZ: f32,
            pub gameSpeed: f32,
            pub frameNum: i32,
        }
        impl<'a> Default for GameInfoArgs {
            #[inline]
            fn default() -> Self {
                GameInfoArgs {
                    secondsElapsed: 0.0,
                    gameTimeRemaining: 0.0,
                    isOvertime: false,
                    isUnlimitedTime: false,
                    isRoundActive: false,
                    isKickoffPause: false,
                    isMatchEnded: false,
                    worldGravityZ: 0.0,
                    gameSpeed: 0.0,
                    frameNum: 0,
                }
            }
        }

        pub struct GameInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_secondsElapsed(&mut self, secondsElapsed: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_SECONDSELAPSED, secondsElapsed, 0.0);
            }
            #[inline]
            pub fn add_gameTimeRemaining(&mut self, gameTimeRemaining: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_GAMETIMEREMAINING, gameTimeRemaining, 0.0);
            }
            #[inline]
            pub fn add_isOvertime(&mut self, isOvertime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISOVERTIME, isOvertime, false);
            }
            #[inline]
            pub fn add_isUnlimitedTime(&mut self, isUnlimitedTime: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISUNLIMITEDTIME, isUnlimitedTime, false);
            }
            #[inline]
            pub fn add_isRoundActive(&mut self, isRoundActive: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISROUNDACTIVE, isRoundActive, false);
            }
            #[inline]
            pub fn add_isKickoffPause(&mut self, isKickoffPause: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISKICKOFFPAUSE, isKickoffPause, false);
            }
            #[inline]
            pub fn add_isMatchEnded(&mut self, isMatchEnded: bool) {
                self.fbb_
                    .push_slot::<bool>(GameInfo::VT_ISMATCHENDED, isMatchEnded, false);
            }
            #[inline]
            pub fn add_worldGravityZ(&mut self, worldGravityZ: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_WORLDGRAVITYZ, worldGravityZ, 0.0);
            }
            #[inline]
            pub fn add_gameSpeed(&mut self, gameSpeed: f32) {
                self.fbb_
                    .push_slot::<f32>(GameInfo::VT_GAMESPEED, gameSpeed, 0.0);
            }
            #[inline]
            pub fn add_frameNum(&mut self, frameNum: i32) {
                self.fbb_
                    .push_slot::<i32>(GameInfo::VT_FRAMENUM, frameNum, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GameInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GameInfo");
                ds.field("secondsElapsed", &self.secondsElapsed());
                ds.field("gameTimeRemaining", &self.gameTimeRemaining());
                ds.field("isOvertime", &self.isOvertime());
                ds.field("isUnlimitedTime", &self.isUnlimitedTime());
                ds.field("isRoundActive", &self.isRoundActive());
                ds.field("isKickoffPause", &self.isKickoffPause());
                ds.field("isMatchEnded", &self.isMatchEnded());
                ds.field("worldGravityZ", &self.worldGravityZ());
                ds.field("gameSpeed", &self.gameSpeed());
                ds.field("frameNum", &self.frameNum());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct GameInfoObject {
            pub secondsElapsed: f32,
            pub gameTimeRemaining: f32,
            pub isOvertime: bool,
            pub isUnlimitedTime: bool,
            pub isRoundActive: bool,
            pub isKickoffPause: bool,
            pub isMatchEnded: bool,
            pub worldGravityZ: f32,
            pub gameSpeed: f32,
            pub frameNum: i32,
        }
        impl Default for GameInfoObject {
            fn default() -> Self {
                Self {
                    secondsElapsed: 0.0,
                    gameTimeRemaining: 0.0,
                    isOvertime: false,
                    isUnlimitedTime: false,
                    isRoundActive: false,
                    isKickoffPause: false,
                    isMatchEnded: false,
                    worldGravityZ: 0.0,
                    gameSpeed: 0.0,
                    frameNum: 0,
                }
            }
        }
        impl GameInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<GameInfo<'b>> {
                let secondsElapsed = self.secondsElapsed;
                let gameTimeRemaining = self.gameTimeRemaining;
                let isOvertime = self.isOvertime;
                let isUnlimitedTime = self.isUnlimitedTime;
                let isRoundActive = self.isRoundActive;
                let isKickoffPause = self.isKickoffPause;
                let isMatchEnded = self.isMatchEnded;
                let worldGravityZ = self.worldGravityZ;
                let gameSpeed = self.gameSpeed;
                let frameNum = self.frameNum;
                GameInfo::create(
                    _fbb,
                    &GameInfoArgs {
                        secondsElapsed,
                        gameTimeRemaining,
                        isOvertime,
                        isUnlimitedTime,
                        isRoundActive,
                        isKickoffPause,
                        isMatchEnded,
                        worldGravityZ,
                        gameSpeed,
                        frameNum,
                    },
                )
            }
        }
        pub enum TeamInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct TeamInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TeamInfo<'a> {
            type Inner = TeamInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TeamInfo<'a> {
            pub const VT_TEAMINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_SCORE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TeamInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TeamInfoArgs,
            ) -> flatbuffers::WIPOffset<TeamInfo<'bldr>> {
                let mut builder = TeamInfoBuilder::new(_fbb);
                builder.add_score(args.score);
                builder.add_teamIndex(args.teamIndex);
                builder.finish()
            }

            pub fn unpack(&self) -> TeamInfoObject {
                let teamIndex = self.teamIndex();
                let score = self.score();
                TeamInfoObject { teamIndex, score }
            }

            #[inline]
            pub fn teamIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(TeamInfo::VT_TEAMINDEX, Some(0))
                        .unwrap()
                }
            }
            /// number of goals scored.
            #[inline]
            pub fn score(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(TeamInfo::VT_SCORE, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for TeamInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("teamIndex", Self::VT_TEAMINDEX, false)?
                    .visit_field::<i32>("score", Self::VT_SCORE, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TeamInfoArgs {
            pub teamIndex: i32,
            pub score: i32,
        }
        impl<'a> Default for TeamInfoArgs {
            #[inline]
            fn default() -> Self {
                TeamInfoArgs {
                    teamIndex: 0,
                    score: 0,
                }
            }
        }

        pub struct TeamInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TeamInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamIndex(&mut self, teamIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(TeamInfo::VT_TEAMINDEX, teamIndex, 0);
            }
            #[inline]
            pub fn add_score(&mut self, score: i32) {
                self.fbb_.push_slot::<i32>(TeamInfo::VT_SCORE, score, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TeamInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TeamInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TeamInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TeamInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TeamInfo");
                ds.field("teamIndex", &self.teamIndex());
                ds.field("score", &self.score());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct TeamInfoObject {
            pub teamIndex: i32,
            pub score: i32,
        }
        impl Default for TeamInfoObject {
            fn default() -> Self {
                Self {
                    teamIndex: 0,
                    score: 0,
                }
            }
        }
        impl TeamInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TeamInfo<'b>> {
                let teamIndex = self.teamIndex;
                let score = self.score;
                TeamInfo::create(_fbb, &TeamInfoArgs { teamIndex, score })
            }
        }
        pub enum GameTickPacketOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GameTickPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameTickPacket<'a> {
            type Inner = GameTickPacket<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GameTickPacket<'a> {
            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTPADSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BALL: flatbuffers::VOffsetT = 8;
            pub const VT_GAMEINFO: flatbuffers::VOffsetT = 10;
            pub const VT_TILEINFORMATION: flatbuffers::VOffsetT = 12;
            pub const VT_TEAMS: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameTickPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameTickPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<GameTickPacket<'bldr>> {
                let mut builder = GameTickPacketBuilder::new(_fbb);
                if let Some(x) = args.teams {
                    builder.add_teams(x);
                }
                if let Some(x) = args.tileInformation {
                    builder.add_tileInformation(x);
                }
                if let Some(x) = args.gameInfo {
                    builder.add_gameInfo(x);
                }
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.boostPadStates {
                    builder.add_boostPadStates(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> GameTickPacketObject {
                let players = self
                    .players()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let boostPadStates = self
                    .boostPadStates()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let ball = self.ball().map(|x| Box::new(x.unpack()));
                let gameInfo = self.gameInfo().map(|x| Box::new(x.unpack()));
                let tileInformation = self
                    .tileInformation()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let teams = self.teams().map(|x| x.iter().map(|t| t.unpack()).collect());
                GameTickPacketObject {
                    players,
                    boostPadStates,
                    ball,
                    gameInfo,
                    tileInformation,
                    teams,
                }
            }

            #[inline]
            pub fn players(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo>>,
                    >>(GameTickPacket::VT_PLAYERS, None)
                }
            }
            #[inline]
            pub fn boostPadStates(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState>>,
                    >>(GameTickPacket::VT_BOOSTPADSTATES, None)
                }
            }
            #[inline]
            pub fn ball(&self) -> Option<BallInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<BallInfo>>(
                        GameTickPacket::VT_BALL,
                        None,
                    )
                }
            }
            #[inline]
            pub fn gameInfo(&self) -> Option<GameInfo<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<GameInfo>>(
                        GameTickPacket::VT_GAMEINFO,
                        None,
                    )
                }
            }
            #[inline]
            pub fn tileInformation(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile>>,
                    >>(GameTickPacket::VT_TILEINFORMATION, None)
                }
            }
            #[inline]
            pub fn teams(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo>>,
                    >>(GameTickPacket::VT_TEAMS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for GameTickPacket<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerInfo>>,
                    >>("players", Self::VT_PLAYERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPadState>>,
                    >>("boostPadStates", Self::VT_BOOSTPADSTATES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<BallInfo>>(
                        "ball",
                        Self::VT_BALL,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<GameInfo>>(
                        "gameInfo",
                        Self::VT_GAMEINFO,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DropshotTile>>,
                    >>("tileInformation", Self::VT_TILEINFORMATION, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TeamInfo>>,
                    >>("teams", Self::VT_TEAMS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct GameTickPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerInfo<'a>>>,
                >,
            >,
            pub boostPadStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPadState<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<BallInfo<'a>>>,
            pub gameInfo: Option<flatbuffers::WIPOffset<GameInfo<'a>>>,
            pub tileInformation: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DropshotTile<'a>>>,
                >,
            >,
            pub teams: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TeamInfo<'a>>>,
                >,
            >,
        }
        impl<'a> Default for GameTickPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                GameTickPacketArgs {
                    players: None,
                    boostPadStates: None,
                    ball: None,
                    gameInfo: None,
                    tileInformation: None,
                    teams: None,
                }
            }
        }

        pub struct GameTickPacketBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameTickPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerInfo<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_PLAYERS,
                    players,
                );
            }
            #[inline]
            pub fn add_boostPadStates(
                &mut self,
                boostPadStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPadState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_BOOSTPADSTATES,
                    boostPadStates,
                );
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BallInfo>>(
                        GameTickPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn add_gameInfo(&mut self, gameInfo: flatbuffers::WIPOffset<GameInfo<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<GameInfo>>(
                        GameTickPacket::VT_GAMEINFO,
                        gameInfo,
                    );
            }
            #[inline]
            pub fn add_tileInformation(
                &mut self,
                tileInformation: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DropshotTile<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameTickPacket::VT_TILEINFORMATION,
                    tileInformation,
                );
            }
            #[inline]
            pub fn add_teams(
                &mut self,
                teams: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TeamInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(GameTickPacket::VT_TEAMS, teams);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameTickPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameTickPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameTickPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GameTickPacket<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GameTickPacket");
                ds.field("players", &self.players());
                ds.field("boostPadStates", &self.boostPadStates());
                ds.field("ball", &self.ball());
                ds.field("gameInfo", &self.gameInfo());
                ds.field("tileInformation", &self.tileInformation());
                ds.field("teams", &self.teams());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct GameTickPacketObject {
            pub players: Option<Vec<PlayerInfoObject>>,
            pub boostPadStates: Option<Vec<BoostPadStateObject>>,
            pub ball: Option<Box<BallInfoObject>>,
            pub gameInfo: Option<Box<GameInfoObject>>,
            pub tileInformation: Option<Vec<DropshotTileObject>>,
            pub teams: Option<Vec<TeamInfoObject>>,
        }
        impl Default for GameTickPacketObject {
            fn default() -> Self {
                Self {
                    players: None,
                    boostPadStates: None,
                    ball: None,
                    gameInfo: None,
                    tileInformation: None,
                    teams: None,
                }
            }
        }
        impl GameTickPacketObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<GameTickPacket<'b>> {
                let players = self.players.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let boostPadStates = self.boostPadStates.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let ball = self.ball.as_ref().map(|x| x.pack(_fbb));
                let gameInfo = self.gameInfo.as_ref().map(|x| x.pack(_fbb));
                let tileInformation = self.tileInformation.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let teams = self.teams.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                GameTickPacket::create(
                    _fbb,
                    &GameTickPacketArgs {
                        players,
                        boostPadStates,
                        ball,
                        gameInfo,
                        tileInformation,
                        teams,
                    },
                )
            }
        }
        pub enum RigidBodyStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// The state of a rigid body in Rocket League's physics engine.
        /// This gets updated in time with the physics tick, not the rendering framerate.
        /// The frame field will be incremented every time the physics engine ticks.
        pub struct RigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RigidBodyState<'a> {
            type Inner = RigidBodyState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RigidBodyState<'a> {
            pub const VT_FRAME: flatbuffers::VOffsetT = 4;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 8;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 10;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<RigidBodyState<'bldr>> {
                let mut builder = RigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_frame(args.frame);
                builder.finish()
            }

            pub fn unpack(&self) -> RigidBodyStateObject {
                let frame = self.frame();
                let location = self.location().map(|x| x.unpack());
                let rotation = self.rotation().map(|x| x.unpack());
                let velocity = self.velocity().map(|x| x.unpack());
                let angularVelocity = self.angularVelocity().map(|x| x.unpack());
                RigidBodyStateObject {
                    frame,
                    location,
                    rotation,
                    velocity,
                    angularVelocity,
                }
            }

            #[inline]
            pub fn frame(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(RigidBodyState::VT_FRAME, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(RigidBodyState::VT_LOCATION, None) }
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Quaternion> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Quaternion>(RigidBodyState::VT_ROTATION, None)
                }
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(RigidBodyState::VT_VELOCITY, None) }
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Vector3>(RigidBodyState::VT_ANGULARVELOCITY, None)
                }
            }
        }

        impl flatbuffers::Verifiable for RigidBodyState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("frame", Self::VT_FRAME, false)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Quaternion>("rotation", Self::VT_ROTATION, false)?
                    .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
                    .visit_field::<Vector3>("angularVelocity", Self::VT_ANGULARVELOCITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RigidBodyStateArgs<'a> {
            pub frame: i32,
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Quaternion>,
            pub velocity: Option<&'a Vector3>,
            pub angularVelocity: Option<&'a Vector3>,
        }
        impl<'a> Default for RigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                RigidBodyStateArgs {
                    frame: 0,
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }

        pub struct RigidBodyStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_frame(&mut self, frame: i32) {
                self.fbb_
                    .push_slot::<i32>(RigidBodyState::VT_FRAME, frame, 0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RigidBodyState::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &Quaternion) {
                self.fbb_
                    .push_slot_always::<&Quaternion>(RigidBodyState::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RigidBodyState::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_angularVelocity(&mut self, angularVelocity: &Vector3) {
                self.fbb_.push_slot_always::<&Vector3>(
                    RigidBodyState::VT_ANGULARVELOCITY,
                    angularVelocity,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RigidBodyState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RigidBodyState");
                ds.field("frame", &self.frame());
                ds.field("location", &self.location());
                ds.field("rotation", &self.rotation());
                ds.field("velocity", &self.velocity());
                ds.field("angularVelocity", &self.angularVelocity());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RigidBodyStateObject {
            pub frame: i32,
            pub location: Option<Vector3Object>,
            pub rotation: Option<QuaternionObject>,
            pub velocity: Option<Vector3Object>,
            pub angularVelocity: Option<Vector3Object>,
        }
        impl Default for RigidBodyStateObject {
            fn default() -> Self {
                Self {
                    frame: 0,
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        impl RigidBodyStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RigidBodyState<'b>> {
                let frame = self.frame;
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let rotation_tmp = self.rotation.as_ref().map(|x| x.pack());
                let rotation = rotation_tmp.as_ref();
                let velocity_tmp = self.velocity.as_ref().map(|x| x.pack());
                let velocity = velocity_tmp.as_ref();
                let angularVelocity_tmp = self.angularVelocity.as_ref().map(|x| x.pack());
                let angularVelocity = angularVelocity_tmp.as_ref();
                RigidBodyState::create(
                    _fbb,
                    &RigidBodyStateArgs {
                        frame,
                        location,
                        rotation,
                        velocity,
                        angularVelocity,
                    },
                )
            }
        }
        pub enum PlayerRigidBodyStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Rigid body state for a player / car in the game. Includes the latest
        /// controller input, which is otherwise difficult to correlate with consequences.
        pub struct PlayerRigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerRigidBodyState<'a> {
            type Inner = PlayerRigidBodyState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerRigidBodyState<'a> {
            pub const VT_STATE: flatbuffers::VOffsetT = 4;
            pub const VT_INPUT: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerRigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerRigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'bldr>> {
                let mut builder = PlayerRigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.input {
                    builder.add_input(x);
                }
                if let Some(x) = args.state {
                    builder.add_state(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerRigidBodyStateObject {
                let state = self.state().map(|x| Box::new(x.unpack()));
                let input = self.input().map(|x| Box::new(x.unpack()));
                PlayerRigidBodyStateObject { state, input }
            }

            #[inline]
            pub fn state(&self) -> Option<RigidBodyState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<RigidBodyState>>(
                            PlayerRigidBodyState::VT_STATE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn input(&self) -> Option<ControllerState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<ControllerState>>(
                            PlayerRigidBodyState::VT_INPUT,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerRigidBodyState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<RigidBodyState>>(
                        "state",
                        Self::VT_STATE,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>(
                        "input",
                        Self::VT_INPUT,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerRigidBodyStateArgs<'a> {
            pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
            pub input: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
        }
        impl<'a> Default for PlayerRigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerRigidBodyStateArgs {
                    state: None,
                    input: None,
                }
            }
        }

        pub struct PlayerRigidBodyStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerRigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RigidBodyState>>(
                        PlayerRigidBodyState::VT_STATE,
                        state,
                    );
            }
            #[inline]
            pub fn add_input(&mut self, input: flatbuffers::WIPOffset<ControllerState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(
                        PlayerRigidBodyState::VT_INPUT,
                        input,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerRigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerRigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerRigidBodyState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerRigidBodyState");
                ds.field("state", &self.state());
                ds.field("input", &self.input());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerRigidBodyStateObject {
            pub state: Option<Box<RigidBodyStateObject>>,
            pub input: Option<Box<ControllerStateObject>>,
        }
        impl Default for PlayerRigidBodyStateObject {
            fn default() -> Self {
                Self {
                    state: None,
                    input: None,
                }
            }
        }
        impl PlayerRigidBodyStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerRigidBodyState<'b>> {
                let state = self.state.as_ref().map(|x| x.pack(_fbb));
                let input = self.input.as_ref().map(|x| x.pack(_fbb));
                PlayerRigidBodyState::create(_fbb, &PlayerRigidBodyStateArgs { state, input })
            }
        }
        pub enum BallRigidBodyStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Rigid body state for the ball.
        pub struct BallRigidBodyState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallRigidBodyState<'a> {
            type Inner = BallRigidBodyState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BallRigidBodyState<'a> {
            pub const VT_STATE: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallRigidBodyState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallRigidBodyStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallRigidBodyState<'bldr>> {
                let mut builder = BallRigidBodyStateBuilder::new(_fbb);
                if let Some(x) = args.state {
                    builder.add_state(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> BallRigidBodyStateObject {
                let state = self.state().map(|x| Box::new(x.unpack()));
                BallRigidBodyStateObject { state }
            }

            #[inline]
            pub fn state(&self) -> Option<RigidBodyState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<RigidBodyState>>(
                            BallRigidBodyState::VT_STATE,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for BallRigidBodyState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<RigidBodyState>>(
                        "state",
                        Self::VT_STATE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct BallRigidBodyStateArgs<'a> {
            pub state: Option<flatbuffers::WIPOffset<RigidBodyState<'a>>>,
        }
        impl<'a> Default for BallRigidBodyStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallRigidBodyStateArgs { state: None }
            }
        }

        pub struct BallRigidBodyStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallRigidBodyStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_state(&mut self, state: flatbuffers::WIPOffset<RigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RigidBodyState>>(
                        BallRigidBodyState::VT_STATE,
                        state,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallRigidBodyStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallRigidBodyStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallRigidBodyState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BallRigidBodyState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BallRigidBodyState");
                ds.field("state", &self.state());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BallRigidBodyStateObject {
            pub state: Option<Box<RigidBodyStateObject>>,
        }
        impl Default for BallRigidBodyStateObject {
            fn default() -> Self {
                Self { state: None }
            }
        }
        impl BallRigidBodyStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BallRigidBodyState<'b>> {
                let state = self.state.as_ref().map(|x| x.pack(_fbb));
                BallRigidBodyState::create(_fbb, &BallRigidBodyStateArgs { state })
            }
        }
        pub enum RigidBodyTickOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Contains all rigid body state information.
        pub struct RigidBodyTick<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RigidBodyTick<'a> {
            type Inner = RigidBodyTick<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RigidBodyTick<'a> {
            pub const VT_BALL: flatbuffers::VOffsetT = 4;
            pub const VT_PLAYERS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RigidBodyTick { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RigidBodyTickArgs<'args>,
            ) -> flatbuffers::WIPOffset<RigidBodyTick<'bldr>> {
                let mut builder = RigidBodyTickBuilder::new(_fbb);
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> RigidBodyTickObject {
                let ball = self.ball().map(|x| Box::new(x.unpack()));
                let players = self
                    .players()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                RigidBodyTickObject { ball, players }
            }

            #[inline]
            pub fn ball(&self) -> Option<BallRigidBodyState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<BallRigidBodyState>>(
                            RigidBodyTick::VT_BALL,
                            None,
                        )
                }
            }
            #[inline]
            pub fn players(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState>>,
                    >>(RigidBodyTick::VT_PLAYERS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for RigidBodyTick<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<BallRigidBodyState>>(
                        "ball",
                        Self::VT_BALL,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerRigidBodyState>>,
                    >>("players", Self::VT_PLAYERS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RigidBodyTickArgs<'a> {
            pub ball: Option<flatbuffers::WIPOffset<BallRigidBodyState<'a>>>,
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'a>>>,
                >,
            >,
        }
        impl<'a> Default for RigidBodyTickArgs<'a> {
            #[inline]
            fn default() -> Self {
                RigidBodyTickArgs {
                    ball: None,
                    players: None,
                }
            }
        }

        pub struct RigidBodyTickBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RigidBodyTickBuilder<'a, 'b> {
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<BallRigidBodyState<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<BallRigidBodyState>>(
                        RigidBodyTick::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerRigidBodyState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    RigidBodyTick::VT_PLAYERS,
                    players,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RigidBodyTickBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RigidBodyTickBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RigidBodyTick<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RigidBodyTick<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RigidBodyTick");
                ds.field("ball", &self.ball());
                ds.field("players", &self.players());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RigidBodyTickObject {
            pub ball: Option<Box<BallRigidBodyStateObject>>,
            pub players: Option<Vec<PlayerRigidBodyStateObject>>,
        }
        impl Default for RigidBodyTickObject {
            fn default() -> Self {
                Self {
                    ball: None,
                    players: None,
                }
            }
        }
        impl RigidBodyTickObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RigidBodyTick<'b>> {
                let ball = self.ball.as_ref().map(|x| x.pack(_fbb));
                let players = self.players.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                RigidBodyTick::create(_fbb, &RigidBodyTickArgs { ball, players })
            }
        }
        pub enum GoalInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GoalInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GoalInfo<'a> {
            type Inner = GoalInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GoalInfo<'a> {
            pub const VT_TEAMNUM: flatbuffers::VOffsetT = 4;
            pub const VT_LOCATION: flatbuffers::VOffsetT = 6;
            pub const VT_DIRECTION: flatbuffers::VOffsetT = 8;
            pub const VT_WIDTH: flatbuffers::VOffsetT = 10;
            pub const VT_HEIGHT: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GoalInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GoalInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<GoalInfo<'bldr>> {
                let mut builder = GoalInfoBuilder::new(_fbb);
                builder.add_height(args.height);
                builder.add_width(args.width);
                if let Some(x) = args.direction {
                    builder.add_direction(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_teamNum(args.teamNum);
                builder.finish()
            }

            pub fn unpack(&self) -> GoalInfoObject {
                let teamNum = self.teamNum();
                let location = self.location().map(|x| x.unpack());
                let direction = self.direction().map(|x| x.unpack());
                let width = self.width();
                let height = self.height();
                GoalInfoObject {
                    teamNum,
                    location,
                    direction,
                    width,
                    height,
                }
            }

            #[inline]
            pub fn teamNum(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(GoalInfo::VT_TEAMNUM, Some(0)).unwrap() }
            }
            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(GoalInfo::VT_LOCATION, None) }
            }
            #[inline]
            pub fn direction(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(GoalInfo::VT_DIRECTION, None) }
            }
            #[inline]
            pub fn width(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<f32>(GoalInfo::VT_WIDTH, Some(0.0)).unwrap() }
            }
            #[inline]
            pub fn height(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(GoalInfo::VT_HEIGHT, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for GoalInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("teamNum", Self::VT_TEAMNUM, false)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Vector3>("direction", Self::VT_DIRECTION, false)?
                    .visit_field::<f32>("width", Self::VT_WIDTH, false)?
                    .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct GoalInfoArgs<'a> {
            pub teamNum: i32,
            pub location: Option<&'a Vector3>,
            pub direction: Option<&'a Vector3>,
            pub width: f32,
            pub height: f32,
        }
        impl<'a> Default for GoalInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                GoalInfoArgs {
                    teamNum: 0,
                    location: None,
                    direction: None,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }

        pub struct GoalInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GoalInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamNum(&mut self, teamNum: i32) {
                self.fbb_.push_slot::<i32>(GoalInfo::VT_TEAMNUM, teamNum, 0);
            }
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_direction(&mut self, direction: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(GoalInfo::VT_DIRECTION, direction);
            }
            #[inline]
            pub fn add_width(&mut self, width: f32) {
                self.fbb_.push_slot::<f32>(GoalInfo::VT_WIDTH, width, 0.0);
            }
            #[inline]
            pub fn add_height(&mut self, height: f32) {
                self.fbb_.push_slot::<f32>(GoalInfo::VT_HEIGHT, height, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GoalInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GoalInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GoalInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GoalInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GoalInfo");
                ds.field("teamNum", &self.teamNum());
                ds.field("location", &self.location());
                ds.field("direction", &self.direction());
                ds.field("width", &self.width());
                ds.field("height", &self.height());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct GoalInfoObject {
            pub teamNum: i32,
            pub location: Option<Vector3Object>,
            pub direction: Option<Vector3Object>,
            pub width: f32,
            pub height: f32,
        }
        impl Default for GoalInfoObject {
            fn default() -> Self {
                Self {
                    teamNum: 0,
                    location: None,
                    direction: None,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }
        impl GoalInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<GoalInfo<'b>> {
                let teamNum = self.teamNum;
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let direction_tmp = self.direction.as_ref().map(|x| x.pack());
                let direction = direction_tmp.as_ref();
                let width = self.width;
                let height = self.height;
                GoalInfo::create(
                    _fbb,
                    &GoalInfoArgs {
                        teamNum,
                        location,
                        direction,
                        width,
                        height,
                    },
                )
            }
        }
        pub enum BoostPadOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BoostPad<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BoostPad<'a> {
            type Inner = BoostPad<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BoostPad<'a> {
            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ISFULLBOOST: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BoostPad { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BoostPadArgs<'args>,
            ) -> flatbuffers::WIPOffset<BoostPad<'bldr>> {
                let mut builder = BoostPadBuilder::new(_fbb);
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isFullBoost(args.isFullBoost);
                builder.finish()
            }

            pub fn unpack(&self) -> BoostPadObject {
                let location = self.location().map(|x| x.unpack());
                let isFullBoost = self.isFullBoost();
                BoostPadObject {
                    location,
                    isFullBoost,
                }
            }

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(BoostPad::VT_LOCATION, None) }
            }
            #[inline]
            pub fn isFullBoost(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(BoostPad::VT_ISFULLBOOST, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for BoostPad<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<bool>("isFullBoost", Self::VT_ISFULLBOOST, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BoostPadArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub isFullBoost: bool,
        }
        impl<'a> Default for BoostPadArgs<'a> {
            #[inline]
            fn default() -> Self {
                BoostPadArgs {
                    location: None,
                    isFullBoost: false,
                }
            }
        }

        pub struct BoostPadBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BoostPadBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(BoostPad::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_isFullBoost(&mut self, isFullBoost: bool) {
                self.fbb_
                    .push_slot::<bool>(BoostPad::VT_ISFULLBOOST, isFullBoost, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BoostPadBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BoostPadBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BoostPad<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BoostPad<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BoostPad");
                ds.field("location", &self.location());
                ds.field("isFullBoost", &self.isFullBoost());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BoostPadObject {
            pub location: Option<Vector3Object>,
            pub isFullBoost: bool,
        }
        impl Default for BoostPadObject {
            fn default() -> Self {
                Self {
                    location: None,
                    isFullBoost: false,
                }
            }
        }
        impl BoostPadObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BoostPad<'b>> {
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let isFullBoost = self.isFullBoost;
                BoostPad::create(
                    _fbb,
                    &BoostPadArgs {
                        location,
                        isFullBoost,
                    },
                )
            }
        }
        pub enum FieldInfoOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct FieldInfo<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for FieldInfo<'a> {
            type Inner = FieldInfo<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> FieldInfo<'a> {
            pub const VT_BOOSTPADS: flatbuffers::VOffsetT = 4;
            pub const VT_GOALS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                FieldInfo { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args FieldInfoArgs<'args>,
            ) -> flatbuffers::WIPOffset<FieldInfo<'bldr>> {
                let mut builder = FieldInfoBuilder::new(_fbb);
                if let Some(x) = args.goals {
                    builder.add_goals(x);
                }
                if let Some(x) = args.boostPads {
                    builder.add_boostPads(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> FieldInfoObject {
                let boostPads = self
                    .boostPads()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let goals = self.goals().map(|x| x.iter().map(|t| t.unpack()).collect());
                FieldInfoObject { boostPads, goals }
            }

            #[inline]
            pub fn boostPads(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad>>,
                    >>(FieldInfo::VT_BOOSTPADS, None)
                }
            }
            #[inline]
            pub fn goals(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo>>,
                    >>(FieldInfo::VT_GOALS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for FieldInfo<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoostPad>>,
                    >>("boostPads", Self::VT_BOOSTPADS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GoalInfo>>,
                    >>("goals", Self::VT_GOALS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct FieldInfoArgs<'a> {
            pub boostPads: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoostPad<'a>>>,
                >,
            >,
            pub goals: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GoalInfo<'a>>>,
                >,
            >,
        }
        impl<'a> Default for FieldInfoArgs<'a> {
            #[inline]
            fn default() -> Self {
                FieldInfoArgs {
                    boostPads: None,
                    goals: None,
                }
            }
        }

        pub struct FieldInfoBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> FieldInfoBuilder<'a, 'b> {
            #[inline]
            pub fn add_boostPads(
                &mut self,
                boostPads: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<BoostPad<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    FieldInfo::VT_BOOSTPADS,
                    boostPads,
                );
            }
            #[inline]
            pub fn add_goals(
                &mut self,
                goals: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GoalInfo<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(FieldInfo::VT_GOALS, goals);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> FieldInfoBuilder<'a, 'b> {
                let start = _fbb.start_table();
                FieldInfoBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<FieldInfo<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for FieldInfo<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("FieldInfo");
                ds.field("boostPads", &self.boostPads());
                ds.field("goals", &self.goals());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct FieldInfoObject {
            pub boostPads: Option<Vec<BoostPadObject>>,
            pub goals: Option<Vec<GoalInfoObject>>,
        }
        impl Default for FieldInfoObject {
            fn default() -> Self {
                Self {
                    boostPads: None,
                    goals: None,
                }
            }
        }
        impl FieldInfoObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<FieldInfo<'b>> {
                let boostPads = self.boostPads.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let goals = self.goals.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                FieldInfo::create(_fbb, &FieldInfoArgs { boostPads, goals })
            }
        }
        pub enum Vector3PartialOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Vector3Partial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Vector3Partial<'a> {
            type Inner = Vector3Partial<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Vector3Partial<'a> {
            pub const VT_X: flatbuffers::VOffsetT = 4;
            pub const VT_Y: flatbuffers::VOffsetT = 6;
            pub const VT_Z: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Vector3Partial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args Vector3PartialArgs<'args>,
            ) -> flatbuffers::WIPOffset<Vector3Partial<'bldr>> {
                let mut builder = Vector3PartialBuilder::new(_fbb);
                if let Some(x) = args.z {
                    builder.add_z(x);
                }
                if let Some(x) = args.y {
                    builder.add_y(x);
                }
                if let Some(x) = args.x {
                    builder.add_x(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> Vector3PartialObject {
                let x = self.x().map(|x| x.unpack());
                let y = self.y().map(|x| x.unpack());
                let z = self.z().map(|x| x.unpack());
                Vector3PartialObject { x, y, z }
            }

            #[inline]
            pub fn x(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(Vector3Partial::VT_X, None) }
            }
            #[inline]
            pub fn y(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(Vector3Partial::VT_Y, None) }
            }
            #[inline]
            pub fn z(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(Vector3Partial::VT_Z, None) }
            }
        }

        impl flatbuffers::Verifiable for Vector3Partial<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Float>("x", Self::VT_X, false)?
                    .visit_field::<Float>("y", Self::VT_Y, false)?
                    .visit_field::<Float>("z", Self::VT_Z, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct Vector3PartialArgs<'a> {
            pub x: Option<&'a Float>,
            pub y: Option<&'a Float>,
            pub z: Option<&'a Float>,
        }
        impl<'a> Default for Vector3PartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                Vector3PartialArgs {
                    x: None,
                    y: None,
                    z: None,
                }
            }
        }

        pub struct Vector3PartialBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> Vector3PartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_x(&mut self, x: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_X, x);
            }
            #[inline]
            pub fn add_y(&mut self, y: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Y, y);
            }
            #[inline]
            pub fn add_z(&mut self, z: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(Vector3Partial::VT_Z, z);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> Vector3PartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                Vector3PartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Vector3Partial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Vector3Partial<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Vector3Partial");
                ds.field("x", &self.x());
                ds.field("y", &self.y());
                ds.field("z", &self.z());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct Vector3PartialObject {
            pub x: Option<FloatObject>,
            pub y: Option<FloatObject>,
            pub z: Option<FloatObject>,
        }
        impl Default for Vector3PartialObject {
            fn default() -> Self {
                Self {
                    x: None,
                    y: None,
                    z: None,
                }
            }
        }
        impl Vector3PartialObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Vector3Partial<'b>> {
                let x_tmp = self.x.as_ref().map(|x| x.pack());
                let x = x_tmp.as_ref();
                let y_tmp = self.y.as_ref().map(|x| x.pack());
                let y = y_tmp.as_ref();
                let z_tmp = self.z.as_ref().map(|x| x.pack());
                let z = z_tmp.as_ref();
                Vector3Partial::create(_fbb, &Vector3PartialArgs { x, y, z })
            }
        }
        pub enum RotatorPartialOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct RotatorPartial<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RotatorPartial<'a> {
            type Inner = RotatorPartial<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RotatorPartial<'a> {
            pub const VT_PITCH: flatbuffers::VOffsetT = 4;
            pub const VT_YAW: flatbuffers::VOffsetT = 6;
            pub const VT_ROLL: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RotatorPartial { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RotatorPartialArgs<'args>,
            ) -> flatbuffers::WIPOffset<RotatorPartial<'bldr>> {
                let mut builder = RotatorPartialBuilder::new(_fbb);
                if let Some(x) = args.roll {
                    builder.add_roll(x);
                }
                if let Some(x) = args.yaw {
                    builder.add_yaw(x);
                }
                if let Some(x) = args.pitch {
                    builder.add_pitch(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> RotatorPartialObject {
                let pitch = self.pitch().map(|x| x.unpack());
                let yaw = self.yaw().map(|x| x.unpack());
                let roll = self.roll().map(|x| x.unpack());
                RotatorPartialObject { pitch, yaw, roll }
            }

            #[inline]
            pub fn pitch(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(RotatorPartial::VT_PITCH, None) }
            }
            #[inline]
            pub fn yaw(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(RotatorPartial::VT_YAW, None) }
            }
            #[inline]
            pub fn roll(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Float>(RotatorPartial::VT_ROLL, None) }
            }
        }

        impl flatbuffers::Verifiable for RotatorPartial<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Float>("pitch", Self::VT_PITCH, false)?
                    .visit_field::<Float>("yaw", Self::VT_YAW, false)?
                    .visit_field::<Float>("roll", Self::VT_ROLL, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RotatorPartialArgs<'a> {
            pub pitch: Option<&'a Float>,
            pub yaw: Option<&'a Float>,
            pub roll: Option<&'a Float>,
        }
        impl<'a> Default for RotatorPartialArgs<'a> {
            #[inline]
            fn default() -> Self {
                RotatorPartialArgs {
                    pitch: None,
                    yaw: None,
                    roll: None,
                }
            }
        }

        pub struct RotatorPartialBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RotatorPartialBuilder<'a, 'b> {
            #[inline]
            pub fn add_pitch(&mut self, pitch: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_PITCH, pitch);
            }
            #[inline]
            pub fn add_yaw(&mut self, yaw: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_YAW, yaw);
            }
            #[inline]
            pub fn add_roll(&mut self, roll: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(RotatorPartial::VT_ROLL, roll);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RotatorPartialBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RotatorPartialBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RotatorPartial<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RotatorPartial<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RotatorPartial");
                ds.field("pitch", &self.pitch());
                ds.field("yaw", &self.yaw());
                ds.field("roll", &self.roll());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RotatorPartialObject {
            pub pitch: Option<FloatObject>,
            pub yaw: Option<FloatObject>,
            pub roll: Option<FloatObject>,
        }
        impl Default for RotatorPartialObject {
            fn default() -> Self {
                Self {
                    pitch: None,
                    yaw: None,
                    roll: None,
                }
            }
        }
        impl RotatorPartialObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RotatorPartial<'b>> {
                let pitch_tmp = self.pitch.as_ref().map(|x| x.pack());
                let pitch = pitch_tmp.as_ref();
                let yaw_tmp = self.yaw.as_ref().map(|x| x.pack());
                let yaw = yaw_tmp.as_ref();
                let roll_tmp = self.roll.as_ref().map(|x| x.pack());
                let roll = roll_tmp.as_ref();
                RotatorPartial::create(_fbb, &RotatorPartialArgs { pitch, yaw, roll })
            }
        }
        pub enum DesiredPhysicsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredPhysics<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredPhysics<'a> {
            type Inner = DesiredPhysics<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredPhysics<'a> {
            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_ANGULARVELOCITY: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredPhysics { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredPhysicsArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredPhysics<'bldr>> {
                let mut builder = DesiredPhysicsBuilder::new(_fbb);
                if let Some(x) = args.angularVelocity {
                    builder.add_angularVelocity(x);
                }
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredPhysicsObject {
                let location = self.location().map(|x| Box::new(x.unpack()));
                let rotation = self.rotation().map(|x| Box::new(x.unpack()));
                let velocity = self.velocity().map(|x| Box::new(x.unpack()));
                let angularVelocity = self.angularVelocity().map(|x| Box::new(x.unpack()));
                DesiredPhysicsObject {
                    location,
                    rotation,
                    velocity,
                    angularVelocity,
                }
            }

            #[inline]
            pub fn location(&self) -> Option<Vector3Partial<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                            DesiredPhysics::VT_LOCATION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn rotation(&self) -> Option<RotatorPartial<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<RotatorPartial>>(
                            DesiredPhysics::VT_ROTATION,
                            None,
                        )
                }
            }
            #[inline]
            pub fn velocity(&self) -> Option<Vector3Partial<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                            DesiredPhysics::VT_VELOCITY,
                            None,
                        )
                }
            }
            #[inline]
            pub fn angularVelocity(&self) -> Option<Vector3Partial<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                            DesiredPhysics::VT_ANGULARVELOCITY,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredPhysics<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                        "location",
                        Self::VT_LOCATION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<RotatorPartial>>(
                        "rotation",
                        Self::VT_ROTATION,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                        "velocity",
                        Self::VT_VELOCITY,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<Vector3Partial>>(
                        "angularVelocity",
                        Self::VT_ANGULARVELOCITY,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredPhysicsArgs<'a> {
            pub location: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub rotation: Option<flatbuffers::WIPOffset<RotatorPartial<'a>>>,
            pub velocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
            pub angularVelocity: Option<flatbuffers::WIPOffset<Vector3Partial<'a>>>,
        }
        impl<'a> Default for DesiredPhysicsArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredPhysicsArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }

        pub struct DesiredPhysicsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredPhysicsBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_LOCATION,
                        location,
                    );
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: flatbuffers::WIPOffset<RotatorPartial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<RotatorPartial>>(
                        DesiredPhysics::VT_ROTATION,
                        rotation,
                    );
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: flatbuffers::WIPOffset<Vector3Partial<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_VELOCITY,
                        velocity,
                    );
            }
            #[inline]
            pub fn add_angularVelocity(
                &mut self,
                angularVelocity: flatbuffers::WIPOffset<Vector3Partial<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Vector3Partial>>(
                        DesiredPhysics::VT_ANGULARVELOCITY,
                        angularVelocity,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredPhysicsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredPhysicsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredPhysics<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredPhysics<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredPhysics");
                ds.field("location", &self.location());
                ds.field("rotation", &self.rotation());
                ds.field("velocity", &self.velocity());
                ds.field("angularVelocity", &self.angularVelocity());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredPhysicsObject {
            pub location: Option<Box<Vector3PartialObject>>,
            pub rotation: Option<Box<RotatorPartialObject>>,
            pub velocity: Option<Box<Vector3PartialObject>>,
            pub angularVelocity: Option<Box<Vector3PartialObject>>,
        }
        impl Default for DesiredPhysicsObject {
            fn default() -> Self {
                Self {
                    location: None,
                    rotation: None,
                    velocity: None,
                    angularVelocity: None,
                }
            }
        }
        impl DesiredPhysicsObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredPhysics<'b>> {
                let location = self.location.as_ref().map(|x| x.pack(_fbb));
                let rotation = self.rotation.as_ref().map(|x| x.pack(_fbb));
                let velocity = self.velocity.as_ref().map(|x| x.pack(_fbb));
                let angularVelocity = self.angularVelocity.as_ref().map(|x| x.pack(_fbb));
                DesiredPhysics::create(
                    _fbb,
                    &DesiredPhysicsArgs {
                        location,
                        rotation,
                        velocity,
                        angularVelocity,
                    },
                )
            }
        }
        pub enum DesiredBallStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredBallState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBallState<'a> {
            type Inner = DesiredBallState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredBallState<'a> {
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBallState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBallStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredBallState<'bldr>> {
                let mut builder = DesiredBallStateBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredBallStateObject {
                let physics = self.physics().map(|x| Box::new(x.unpack()));
                DesiredBallStateObject { physics }
            }

            #[inline]
            pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(
                            DesiredBallState::VT_PHYSICS,
                            None,
                        )
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredBallState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(
                        "physics",
                        Self::VT_PHYSICS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredBallStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
        }
        impl<'a> Default for DesiredBallStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBallStateArgs { physics: None }
            }
        }

        pub struct DesiredBallStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBallStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(
                        DesiredBallState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBallStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBallStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBallState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredBallState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredBallState");
                ds.field("physics", &self.physics());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredBallStateObject {
            pub physics: Option<Box<DesiredPhysicsObject>>,
        }
        impl Default for DesiredBallStateObject {
            fn default() -> Self {
                Self { physics: None }
            }
        }
        impl DesiredBallStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredBallState<'b>> {
                let physics = self.physics.as_ref().map(|x| x.pack(_fbb));
                DesiredBallState::create(_fbb, &DesiredBallStateArgs { physics })
            }
        }
        pub enum DesiredCarStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredCarState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredCarState<'a> {
            type Inner = DesiredCarState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredCarState<'a> {
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 4;
            pub const VT_BOOSTAMOUNT: flatbuffers::VOffsetT = 6;
            pub const VT_JUMPED: flatbuffers::VOffsetT = 8;
            pub const VT_DOUBLEJUMPED: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredCarState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredCarStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredCarState<'bldr>> {
                let mut builder = DesiredCarStateBuilder::new(_fbb);
                if let Some(x) = args.doubleJumped {
                    builder.add_doubleJumped(x);
                }
                if let Some(x) = args.jumped {
                    builder.add_jumped(x);
                }
                if let Some(x) = args.boostAmount {
                    builder.add_boostAmount(x);
                }
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredCarStateObject {
                let physics = self.physics().map(|x| Box::new(x.unpack()));
                let boostAmount = self.boostAmount().map(|x| x.unpack());
                let jumped = self.jumped().map(|x| x.unpack());
                let doubleJumped = self.doubleJumped().map(|x| x.unpack());
                DesiredCarStateObject {
                    physics,
                    boostAmount,
                    jumped,
                    doubleJumped,
                }
            }

            #[inline]
            pub fn physics(&self) -> Option<DesiredPhysics<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(
                            DesiredCarState::VT_PHYSICS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn boostAmount(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Float>(DesiredCarState::VT_BOOSTAMOUNT, None)
                }
            }
            #[inline]
            pub fn jumped(&self) -> Option<&'a Bool> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Bool>(DesiredCarState::VT_JUMPED, None) }
            }
            #[inline]
            pub fn doubleJumped(&self) -> Option<&'a Bool> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Bool>(DesiredCarState::VT_DOUBLEJUMPED, None)
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredCarState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<DesiredPhysics>>(
                        "physics",
                        Self::VT_PHYSICS,
                        false,
                    )?
                    .visit_field::<Float>("boostAmount", Self::VT_BOOSTAMOUNT, false)?
                    .visit_field::<Bool>("jumped", Self::VT_JUMPED, false)?
                    .visit_field::<Bool>("doubleJumped", Self::VT_DOUBLEJUMPED, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredCarStateArgs<'a> {
            pub physics: Option<flatbuffers::WIPOffset<DesiredPhysics<'a>>>,
            pub boostAmount: Option<&'a Float>,
            pub jumped: Option<&'a Bool>,
            pub doubleJumped: Option<&'a Bool>,
        }
        impl<'a> Default for DesiredCarStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredCarStateArgs {
                    physics: None,
                    boostAmount: None,
                    jumped: None,
                    doubleJumped: None,
                }
            }
        }

        pub struct DesiredCarStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredCarStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<DesiredPhysics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredPhysics>>(
                        DesiredCarState::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn add_boostAmount(&mut self, boostAmount: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredCarState::VT_BOOSTAMOUNT, boostAmount);
            }
            #[inline]
            pub fn add_jumped(&mut self, jumped: &Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_JUMPED, jumped);
            }
            #[inline]
            pub fn add_doubleJumped(&mut self, doubleJumped: &Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredCarState::VT_DOUBLEJUMPED, doubleJumped);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredCarStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredCarStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredCarState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredCarState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredCarState");
                ds.field("physics", &self.physics());
                ds.field("boostAmount", &self.boostAmount());
                ds.field("jumped", &self.jumped());
                ds.field("doubleJumped", &self.doubleJumped());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredCarStateObject {
            pub physics: Option<Box<DesiredPhysicsObject>>,
            pub boostAmount: Option<FloatObject>,
            pub jumped: Option<BoolObject>,
            pub doubleJumped: Option<BoolObject>,
        }
        impl Default for DesiredCarStateObject {
            fn default() -> Self {
                Self {
                    physics: None,
                    boostAmount: None,
                    jumped: None,
                    doubleJumped: None,
                }
            }
        }
        impl DesiredCarStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredCarState<'b>> {
                let physics = self.physics.as_ref().map(|x| x.pack(_fbb));
                let boostAmount_tmp = self.boostAmount.as_ref().map(|x| x.pack());
                let boostAmount = boostAmount_tmp.as_ref();
                let jumped_tmp = self.jumped.as_ref().map(|x| x.pack());
                let jumped = jumped_tmp.as_ref();
                let doubleJumped_tmp = self.doubleJumped.as_ref().map(|x| x.pack());
                let doubleJumped = doubleJumped_tmp.as_ref();
                DesiredCarState::create(
                    _fbb,
                    &DesiredCarStateArgs {
                        physics,
                        boostAmount,
                        jumped,
                        doubleJumped,
                    },
                )
            }
        }
        pub enum DesiredBoostStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredBoostState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredBoostState<'a> {
            type Inner = DesiredBoostState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredBoostState<'a> {
            pub const VT_RESPAWNTIME: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredBoostState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredBoostStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredBoostState<'bldr>> {
                let mut builder = DesiredBoostStateBuilder::new(_fbb);
                if let Some(x) = args.respawnTime {
                    builder.add_respawnTime(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredBoostStateObject {
                let respawnTime = self.respawnTime().map(|x| x.unpack());
                DesiredBoostStateObject { respawnTime }
            }

            #[inline]
            pub fn respawnTime(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Float>(DesiredBoostState::VT_RESPAWNTIME, None)
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredBoostState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Float>("respawnTime", Self::VT_RESPAWNTIME, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredBoostStateArgs<'a> {
            pub respawnTime: Option<&'a Float>,
        }
        impl<'a> Default for DesiredBoostStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredBoostStateArgs { respawnTime: None }
            }
        }

        pub struct DesiredBoostStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredBoostStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_respawnTime(&mut self, respawnTime: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredBoostState::VT_RESPAWNTIME, respawnTime);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredBoostStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredBoostStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredBoostState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredBoostState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredBoostState");
                ds.field("respawnTime", &self.respawnTime());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredBoostStateObject {
            pub respawnTime: Option<FloatObject>,
        }
        impl Default for DesiredBoostStateObject {
            fn default() -> Self {
                Self { respawnTime: None }
            }
        }
        impl DesiredBoostStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredBoostState<'b>> {
                let respawnTime_tmp = self.respawnTime.as_ref().map(|x| x.pack());
                let respawnTime = respawnTime_tmp.as_ref();
                DesiredBoostState::create(_fbb, &DesiredBoostStateArgs { respawnTime })
            }
        }
        pub enum DesiredGameInfoStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredGameInfoState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredGameInfoState<'a> {
            type Inner = DesiredGameInfoState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredGameInfoState<'a> {
            pub const VT_WORLDGRAVITYZ: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESPEED: flatbuffers::VOffsetT = 6;
            pub const VT_PAUSED: flatbuffers::VOffsetT = 8;
            pub const VT_ENDMATCH: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredGameInfoState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredGameInfoStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredGameInfoState<'bldr>> {
                let mut builder = DesiredGameInfoStateBuilder::new(_fbb);
                if let Some(x) = args.endMatch {
                    builder.add_endMatch(x);
                }
                if let Some(x) = args.paused {
                    builder.add_paused(x);
                }
                if let Some(x) = args.gameSpeed {
                    builder.add_gameSpeed(x);
                }
                if let Some(x) = args.worldGravityZ {
                    builder.add_worldGravityZ(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredGameInfoStateObject {
                let worldGravityZ = self.worldGravityZ().map(|x| x.unpack());
                let gameSpeed = self.gameSpeed().map(|x| x.unpack());
                let paused = self.paused().map(|x| x.unpack());
                let endMatch = self.endMatch().map(|x| x.unpack());
                DesiredGameInfoStateObject {
                    worldGravityZ,
                    gameSpeed,
                    paused,
                    endMatch,
                }
            }

            #[inline]
            pub fn worldGravityZ(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Float>(DesiredGameInfoState::VT_WORLDGRAVITYZ, None)
                }
            }
            #[inline]
            pub fn gameSpeed(&self) -> Option<&'a Float> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Float>(DesiredGameInfoState::VT_GAMESPEED, None)
                }
            }
            #[inline]
            pub fn paused(&self) -> Option<&'a Bool> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Bool>(DesiredGameInfoState::VT_PAUSED, None) }
            }
            #[inline]
            pub fn endMatch(&self) -> Option<&'a Bool> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<Bool>(DesiredGameInfoState::VT_ENDMATCH, None)
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredGameInfoState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Float>("worldGravityZ", Self::VT_WORLDGRAVITYZ, false)?
                    .visit_field::<Float>("gameSpeed", Self::VT_GAMESPEED, false)?
                    .visit_field::<Bool>("paused", Self::VT_PAUSED, false)?
                    .visit_field::<Bool>("endMatch", Self::VT_ENDMATCH, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredGameInfoStateArgs<'a> {
            pub worldGravityZ: Option<&'a Float>,
            pub gameSpeed: Option<&'a Float>,
            pub paused: Option<&'a Bool>,
            pub endMatch: Option<&'a Bool>,
        }
        impl<'a> Default for DesiredGameInfoStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredGameInfoStateArgs {
                    worldGravityZ: None,
                    gameSpeed: None,
                    paused: None,
                    endMatch: None,
                }
            }
        }

        pub struct DesiredGameInfoStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredGameInfoStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_worldGravityZ(&mut self, worldGravityZ: &Float) {
                self.fbb_.push_slot_always::<&Float>(
                    DesiredGameInfoState::VT_WORLDGRAVITYZ,
                    worldGravityZ,
                );
            }
            #[inline]
            pub fn add_gameSpeed(&mut self, gameSpeed: &Float) {
                self.fbb_
                    .push_slot_always::<&Float>(DesiredGameInfoState::VT_GAMESPEED, gameSpeed);
            }
            #[inline]
            pub fn add_paused(&mut self, paused: &Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredGameInfoState::VT_PAUSED, paused);
            }
            #[inline]
            pub fn add_endMatch(&mut self, endMatch: &Bool) {
                self.fbb_
                    .push_slot_always::<&Bool>(DesiredGameInfoState::VT_ENDMATCH, endMatch);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredGameInfoStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredGameInfoStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameInfoState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredGameInfoState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredGameInfoState");
                ds.field("worldGravityZ", &self.worldGravityZ());
                ds.field("gameSpeed", &self.gameSpeed());
                ds.field("paused", &self.paused());
                ds.field("endMatch", &self.endMatch());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredGameInfoStateObject {
            pub worldGravityZ: Option<FloatObject>,
            pub gameSpeed: Option<FloatObject>,
            pub paused: Option<BoolObject>,
            pub endMatch: Option<BoolObject>,
        }
        impl Default for DesiredGameInfoStateObject {
            fn default() -> Self {
                Self {
                    worldGravityZ: None,
                    gameSpeed: None,
                    paused: None,
                    endMatch: None,
                }
            }
        }
        impl DesiredGameInfoStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredGameInfoState<'b>> {
                let worldGravityZ_tmp = self.worldGravityZ.as_ref().map(|x| x.pack());
                let worldGravityZ = worldGravityZ_tmp.as_ref();
                let gameSpeed_tmp = self.gameSpeed.as_ref().map(|x| x.pack());
                let gameSpeed = gameSpeed_tmp.as_ref();
                let paused_tmp = self.paused.as_ref().map(|x| x.pack());
                let paused = paused_tmp.as_ref();
                let endMatch_tmp = self.endMatch.as_ref().map(|x| x.pack());
                let endMatch = endMatch_tmp.as_ref();
                DesiredGameInfoState::create(
                    _fbb,
                    &DesiredGameInfoStateArgs {
                        worldGravityZ,
                        gameSpeed,
                        paused,
                        endMatch,
                    },
                )
            }
        }
        pub enum ConsoleCommandOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A console command which we will try to execute inside Rocket League.
        /// See https://github.com/RLBot/RLBot/wiki/Console-Commands for a list of known commands.
        pub struct ConsoleCommand<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ConsoleCommand<'a> {
            type Inner = ConsoleCommand<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ConsoleCommand<'a> {
            pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ConsoleCommand { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ConsoleCommandArgs<'args>,
            ) -> flatbuffers::WIPOffset<ConsoleCommand<'bldr>> {
                let mut builder = ConsoleCommandBuilder::new(_fbb);
                if let Some(x) = args.command {
                    builder.add_command(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> ConsoleCommandObject {
                let command = self.command().map(|x| x.to_string());
                ConsoleCommandObject { command }
            }

            #[inline]
            pub fn command(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(ConsoleCommand::VT_COMMAND, None)
                }
            }
        }

        impl flatbuffers::Verifiable for ConsoleCommand<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "command",
                        Self::VT_COMMAND,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct ConsoleCommandArgs<'a> {
            pub command: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for ConsoleCommandArgs<'a> {
            #[inline]
            fn default() -> Self {
                ConsoleCommandArgs { command: None }
            }
        }

        pub struct ConsoleCommandBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ConsoleCommandBuilder<'a, 'b> {
            #[inline]
            pub fn add_command(&mut self, command: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    ConsoleCommand::VT_COMMAND,
                    command,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ConsoleCommandBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ConsoleCommandBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ConsoleCommand<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ConsoleCommand<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ConsoleCommand");
                ds.field("command", &self.command());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct ConsoleCommandObject {
            pub command: Option<String>,
        }
        impl Default for ConsoleCommandObject {
            fn default() -> Self {
                Self { command: None }
            }
        }
        impl ConsoleCommandObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<ConsoleCommand<'b>> {
                let command = self.command.as_ref().map(|x| _fbb.create_string(x));
                ConsoleCommand::create(_fbb, &ConsoleCommandArgs { command })
            }
        }
        pub enum DesiredGameStateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct DesiredGameState<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for DesiredGameState<'a> {
            type Inner = DesiredGameState<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> DesiredGameState<'a> {
            pub const VT_BALLSTATE: flatbuffers::VOffsetT = 4;
            pub const VT_CARSTATES: flatbuffers::VOffsetT = 6;
            pub const VT_BOOSTSTATES: flatbuffers::VOffsetT = 8;
            pub const VT_GAMEINFOSTATE: flatbuffers::VOffsetT = 10;
            pub const VT_CONSOLECOMMANDS: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                DesiredGameState { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args DesiredGameStateArgs<'args>,
            ) -> flatbuffers::WIPOffset<DesiredGameState<'bldr>> {
                let mut builder = DesiredGameStateBuilder::new(_fbb);
                if let Some(x) = args.consoleCommands {
                    builder.add_consoleCommands(x);
                }
                if let Some(x) = args.gameInfoState {
                    builder.add_gameInfoState(x);
                }
                if let Some(x) = args.boostStates {
                    builder.add_boostStates(x);
                }
                if let Some(x) = args.carStates {
                    builder.add_carStates(x);
                }
                if let Some(x) = args.ballState {
                    builder.add_ballState(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> DesiredGameStateObject {
                let ballState = self.ballState().map(|x| Box::new(x.unpack()));
                let carStates = self
                    .carStates()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let boostStates = self
                    .boostStates()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let gameInfoState = self.gameInfoState().map(|x| Box::new(x.unpack()));
                let consoleCommands = self
                    .consoleCommands()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                DesiredGameStateObject {
                    ballState,
                    carStates,
                    boostStates,
                    gameInfoState,
                    consoleCommands,
                }
            }

            #[inline]
            pub fn ballState(&self) -> Option<DesiredBallState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<DesiredBallState>>(
                            DesiredGameState::VT_BALLSTATE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn carStates(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState>>,
                    >>(DesiredGameState::VT_CARSTATES, None)
                }
            }
            #[inline]
            pub fn boostStates(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState>>,
                    >>(DesiredGameState::VT_BOOSTSTATES, None)
                }
            }
            #[inline]
            pub fn gameInfoState(&self) -> Option<DesiredGameInfoState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<DesiredGameInfoState>>(
                            DesiredGameState::VT_GAMEINFOSTATE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn consoleCommands(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand>>,
                    >>(DesiredGameState::VT_CONSOLECOMMANDS, None)
                }
            }
        }

        impl flatbuffers::Verifiable for DesiredGameState<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<DesiredBallState>>(
                        "ballState",
                        Self::VT_BALLSTATE,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredCarState>>,
                    >>("carStates", Self::VT_CARSTATES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DesiredBoostState>>,
                    >>("boostStates", Self::VT_BOOSTSTATES, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<DesiredGameInfoState>>(
                        "gameInfoState",
                        Self::VT_GAMEINFOSTATE,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ConsoleCommand>>,
                    >>("consoleCommands", Self::VT_CONSOLECOMMANDS, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct DesiredGameStateArgs<'a> {
            pub ballState: Option<flatbuffers::WIPOffset<DesiredBallState<'a>>>,
            pub carStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredCarState<'a>>>,
                >,
            >,
            pub boostStates: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DesiredBoostState<'a>>>,
                >,
            >,
            pub gameInfoState: Option<flatbuffers::WIPOffset<DesiredGameInfoState<'a>>>,
            pub consoleCommands: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ConsoleCommand<'a>>>,
                >,
            >,
        }
        impl<'a> Default for DesiredGameStateArgs<'a> {
            #[inline]
            fn default() -> Self {
                DesiredGameStateArgs {
                    ballState: None,
                    carStates: None,
                    boostStates: None,
                    gameInfoState: None,
                    consoleCommands: None,
                }
            }
        }

        pub struct DesiredGameStateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> DesiredGameStateBuilder<'a, 'b> {
            #[inline]
            pub fn add_ballState(
                &mut self,
                ballState: flatbuffers::WIPOffset<DesiredBallState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredBallState>>(
                        DesiredGameState::VT_BALLSTATE,
                        ballState,
                    );
            }
            #[inline]
            pub fn add_carStates(
                &mut self,
                carStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredCarState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_CARSTATES,
                    carStates,
                );
            }
            #[inline]
            pub fn add_boostStates(
                &mut self,
                boostStates: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<DesiredBoostState<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_BOOSTSTATES,
                    boostStates,
                );
            }
            #[inline]
            pub fn add_gameInfoState(
                &mut self,
                gameInfoState: flatbuffers::WIPOffset<DesiredGameInfoState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<DesiredGameInfoState>>(
                        DesiredGameState::VT_GAMEINFOSTATE,
                        gameInfoState,
                    );
            }
            #[inline]
            pub fn add_consoleCommands(
                &mut self,
                consoleCommands: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ConsoleCommand<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    DesiredGameState::VT_CONSOLECOMMANDS,
                    consoleCommands,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> DesiredGameStateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                DesiredGameStateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<DesiredGameState<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for DesiredGameState<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("DesiredGameState");
                ds.field("ballState", &self.ballState());
                ds.field("carStates", &self.carStates());
                ds.field("boostStates", &self.boostStates());
                ds.field("gameInfoState", &self.gameInfoState());
                ds.field("consoleCommands", &self.consoleCommands());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct DesiredGameStateObject {
            pub ballState: Option<Box<DesiredBallStateObject>>,
            pub carStates: Option<Vec<DesiredCarStateObject>>,
            pub boostStates: Option<Vec<DesiredBoostStateObject>>,
            pub gameInfoState: Option<Box<DesiredGameInfoStateObject>>,
            pub consoleCommands: Option<Vec<ConsoleCommandObject>>,
        }
        impl Default for DesiredGameStateObject {
            fn default() -> Self {
                Self {
                    ballState: None,
                    carStates: None,
                    boostStates: None,
                    gameInfoState: None,
                    consoleCommands: None,
                }
            }
        }
        impl DesiredGameStateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<DesiredGameState<'b>> {
                let ballState = self.ballState.as_ref().map(|x| x.pack(_fbb));
                let carStates = self.carStates.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let boostStates = self.boostStates.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let gameInfoState = self.gameInfoState.as_ref().map(|x| x.pack(_fbb));
                let consoleCommands = self.consoleCommands.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                DesiredGameState::create(
                    _fbb,
                    &DesiredGameStateArgs {
                        ballState,
                        carStates,
                        boostStates,
                        gameInfoState,
                        consoleCommands,
                    },
                )
            }
        }
        pub enum ColorOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct Color<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for Color<'a> {
            type Inner = Color<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> Color<'a> {
            pub const VT_A: flatbuffers::VOffsetT = 4;
            pub const VT_R: flatbuffers::VOffsetT = 6;
            pub const VT_G: flatbuffers::VOffsetT = 8;
            pub const VT_B: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                Color { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ColorArgs,
            ) -> flatbuffers::WIPOffset<Color<'bldr>> {
                let mut builder = ColorBuilder::new(_fbb);
                builder.add_b(args.b);
                builder.add_g(args.g);
                builder.add_r(args.r);
                builder.add_a(args.a);
                builder.finish()
            }

            pub fn unpack(&self) -> ColorObject {
                let a = self.a();
                let r = self.r();
                let g = self.g();
                let b = self.b();
                ColorObject { a, r, g, b }
            }

            #[inline]
            pub fn a(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(Color::VT_A, Some(0)).unwrap() }
            }
            #[inline]
            pub fn r(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(Color::VT_R, Some(0)).unwrap() }
            }
            #[inline]
            pub fn g(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(Color::VT_G, Some(0)).unwrap() }
            }
            #[inline]
            pub fn b(&self) -> u8 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<u8>(Color::VT_B, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for Color<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<u8>("a", Self::VT_A, false)?
                    .visit_field::<u8>("r", Self::VT_R, false)?
                    .visit_field::<u8>("g", Self::VT_G, false)?
                    .visit_field::<u8>("b", Self::VT_B, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ColorArgs {
            pub a: u8,
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }
        impl<'a> Default for ColorArgs {
            #[inline]
            fn default() -> Self {
                ColorArgs {
                    a: 0,
                    r: 0,
                    g: 0,
                    b: 0,
                }
            }
        }

        pub struct ColorBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ColorBuilder<'a, 'b> {
            #[inline]
            pub fn add_a(&mut self, a: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_A, a, 0);
            }
            #[inline]
            pub fn add_r(&mut self, r: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_R, r, 0);
            }
            #[inline]
            pub fn add_g(&mut self, g: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_G, g, 0);
            }
            #[inline]
            pub fn add_b(&mut self, b: u8) {
                self.fbb_.push_slot::<u8>(Color::VT_B, b, 0);
            }
            #[inline]
            pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ColorBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ColorBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<Color<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for Color<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("Color");
                ds.field("a", &self.a());
                ds.field("r", &self.r());
                ds.field("g", &self.g());
                ds.field("b", &self.b());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct ColorObject {
            pub a: u8,
            pub r: u8,
            pub g: u8,
            pub b: u8,
        }
        impl Default for ColorObject {
            fn default() -> Self {
                Self {
                    a: 0,
                    r: 0,
                    g: 0,
                    b: 0,
                }
            }
        }
        impl ColorObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<Color<'b>> {
                let a = self.a;
                let r = self.r;
                let g = self.g;
                let b = self.b;
                Color::create(_fbb, &ColorArgs { a, r, g, b })
            }
        }
        pub enum RenderMessageOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct RenderMessage<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderMessage<'a> {
            type Inner = RenderMessage<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RenderMessage<'a> {
            pub const VT_RENDERTYPE: flatbuffers::VOffsetT = 4;
            pub const VT_COLOR: flatbuffers::VOffsetT = 6;
            pub const VT_START: flatbuffers::VOffsetT = 8;
            pub const VT_END: flatbuffers::VOffsetT = 10;
            pub const VT_SCALEX: flatbuffers::VOffsetT = 12;
            pub const VT_SCALEY: flatbuffers::VOffsetT = 14;
            pub const VT_TEXT: flatbuffers::VOffsetT = 16;
            pub const VT_ISFILLED: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderMessage { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderMessageArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderMessage<'bldr>> {
                let mut builder = RenderMessageBuilder::new(_fbb);
                if let Some(x) = args.text {
                    builder.add_text(x);
                }
                builder.add_scaleY(args.scaleY);
                builder.add_scaleX(args.scaleX);
                if let Some(x) = args.end {
                    builder.add_end(x);
                }
                if let Some(x) = args.start {
                    builder.add_start(x);
                }
                if let Some(x) = args.color {
                    builder.add_color(x);
                }
                builder.add_isFilled(args.isFilled);
                builder.add_renderType(args.renderType);
                builder.finish()
            }

            pub fn unpack(&self) -> RenderMessageObject {
                let renderType = self.renderType();
                let color = self.color().map(|x| Box::new(x.unpack()));
                let start = self.start().map(|x| x.unpack());
                let end = self.end().map(|x| x.unpack());
                let scaleX = self.scaleX();
                let scaleY = self.scaleY();
                let text = self.text().map(|x| x.to_string());
                let isFilled = self.isFilled();
                RenderMessageObject {
                    renderType,
                    color,
                    start,
                    end,
                    scaleX,
                    scaleY,
                    text,
                    isFilled,
                }
            }

            #[inline]
            pub fn renderType(&self) -> RenderType {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<RenderType>(
                            RenderMessage::VT_RENDERTYPE,
                            Some(RenderType::DrawLine2D),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn color(&self) -> Option<Color<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<Color>>(RenderMessage::VT_COLOR, None)
                }
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn start(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(RenderMessage::VT_START, None) }
            }
            /// For 2d renders this only grabs x and y
            #[inline]
            pub fn end(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(RenderMessage::VT_END, None) }
            }
            /// Scales the x size of the text/rectangle, is used for rectangles assuming an initial value of 1
            #[inline]
            pub fn scaleX(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(RenderMessage::VT_SCALEX, Some(1))
                        .unwrap()
                }
            }
            /// Scales the y size of the text/rectangle, is used for rectangles assuming an initial value of 1
            #[inline]
            pub fn scaleY(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(RenderMessage::VT_SCALEY, Some(1))
                        .unwrap()
                }
            }
            #[inline]
            pub fn text(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<&str>>(RenderMessage::VT_TEXT, None)
                }
            }
            /// Rectangles can be filled or just outlines.
            #[inline]
            pub fn isFilled(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(RenderMessage::VT_ISFILLED, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for RenderMessage<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<RenderType>("renderType", Self::VT_RENDERTYPE, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<Color>>(
                        "color",
                        Self::VT_COLOR,
                        false,
                    )?
                    .visit_field::<Vector3>("start", Self::VT_START, false)?
                    .visit_field::<Vector3>("end", Self::VT_END, false)?
                    .visit_field::<i32>("scaleX", Self::VT_SCALEX, false)?
                    .visit_field::<i32>("scaleY", Self::VT_SCALEY, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "text",
                        Self::VT_TEXT,
                        false,
                    )?
                    .visit_field::<bool>("isFilled", Self::VT_ISFILLED, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RenderMessageArgs<'a> {
            pub renderType: RenderType,
            pub color: Option<flatbuffers::WIPOffset<Color<'a>>>,
            pub start: Option<&'a Vector3>,
            pub end: Option<&'a Vector3>,
            pub scaleX: i32,
            pub scaleY: i32,
            pub text: Option<flatbuffers::WIPOffset<&'a str>>,
            pub isFilled: bool,
        }
        impl<'a> Default for RenderMessageArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderMessageArgs {
                    renderType: RenderType::DrawLine2D,
                    color: None,
                    start: None,
                    end: None,
                    scaleX: 1,
                    scaleY: 1,
                    text: None,
                    isFilled: false,
                }
            }
        }

        pub struct RenderMessageBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderMessageBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderType(&mut self, renderType: RenderType) {
                self.fbb_.push_slot::<RenderType>(
                    RenderMessage::VT_RENDERTYPE,
                    renderType,
                    RenderType::DrawLine2D,
                );
            }
            #[inline]
            pub fn add_color(&mut self, color: flatbuffers::WIPOffset<Color<'b>>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(
                    RenderMessage::VT_COLOR,
                    color,
                );
            }
            #[inline]
            pub fn add_start(&mut self, start: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_START, start);
            }
            #[inline]
            pub fn add_end(&mut self, end: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(RenderMessage::VT_END, end);
            }
            #[inline]
            pub fn add_scaleX(&mut self, scaleX: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEX, scaleX, 1);
            }
            #[inline]
            pub fn add_scaleY(&mut self, scaleY: i32) {
                self.fbb_
                    .push_slot::<i32>(RenderMessage::VT_SCALEY, scaleY, 1);
            }
            #[inline]
            pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(RenderMessage::VT_TEXT, text);
            }
            #[inline]
            pub fn add_isFilled(&mut self, isFilled: bool) {
                self.fbb_
                    .push_slot::<bool>(RenderMessage::VT_ISFILLED, isFilled, false);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderMessageBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderMessageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderMessage<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RenderMessage<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RenderMessage");
                ds.field("renderType", &self.renderType());
                ds.field("color", &self.color());
                ds.field("start", &self.start());
                ds.field("end", &self.end());
                ds.field("scaleX", &self.scaleX());
                ds.field("scaleY", &self.scaleY());
                ds.field("text", &self.text());
                ds.field("isFilled", &self.isFilled());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RenderMessageObject {
            pub renderType: RenderType,
            pub color: Option<Box<ColorObject>>,
            pub start: Option<Vector3Object>,
            pub end: Option<Vector3Object>,
            pub scaleX: i32,
            pub scaleY: i32,
            pub text: Option<String>,
            pub isFilled: bool,
        }
        impl Default for RenderMessageObject {
            fn default() -> Self {
                Self {
                    renderType: RenderType::DrawLine2D,
                    color: None,
                    start: None,
                    end: None,
                    scaleX: 1,
                    scaleY: 1,
                    text: None,
                    isFilled: false,
                }
            }
        }
        impl RenderMessageObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RenderMessage<'b>> {
                let renderType = self.renderType;
                let color = self.color.as_ref().map(|x| x.pack(_fbb));
                let start_tmp = self.start.as_ref().map(|x| x.pack());
                let start = start_tmp.as_ref();
                let end_tmp = self.end.as_ref().map(|x| x.pack());
                let end = end_tmp.as_ref();
                let scaleX = self.scaleX;
                let scaleY = self.scaleY;
                let text = self.text.as_ref().map(|x| _fbb.create_string(x));
                let isFilled = self.isFilled;
                RenderMessage::create(
                    _fbb,
                    &RenderMessageArgs {
                        renderType,
                        color,
                        start,
                        end,
                        scaleX,
                        scaleY,
                        text,
                        isFilled,
                    },
                )
            }
        }
        pub enum RenderGroupOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct RenderGroup<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RenderGroup<'a> {
            type Inner = RenderGroup<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RenderGroup<'a> {
            pub const VT_RENDERMESSAGES: flatbuffers::VOffsetT = 4;
            pub const VT_ID: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RenderGroup { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args RenderGroupArgs<'args>,
            ) -> flatbuffers::WIPOffset<RenderGroup<'bldr>> {
                let mut builder = RenderGroupBuilder::new(_fbb);
                builder.add_id(args.id);
                if let Some(x) = args.renderMessages {
                    builder.add_renderMessages(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> RenderGroupObject {
                let renderMessages = self
                    .renderMessages()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let id = self.id();
                RenderGroupObject { renderMessages, id }
            }

            #[inline]
            pub fn renderMessages(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage>>,
                    >>(RenderGroup::VT_RENDERMESSAGES, None)
                }
            }
            /// The id of the render group
            #[inline]
            pub fn id(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(RenderGroup::VT_ID, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for RenderGroup<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RenderMessage>>,
                    >>("renderMessages", Self::VT_RENDERMESSAGES, false)?
                    .visit_field::<i32>("id", Self::VT_ID, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct RenderGroupArgs<'a> {
            pub renderMessages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RenderMessage<'a>>>,
                >,
            >,
            pub id: i32,
        }
        impl<'a> Default for RenderGroupArgs<'a> {
            #[inline]
            fn default() -> Self {
                RenderGroupArgs {
                    renderMessages: None,
                    id: 0,
                }
            }
        }

        pub struct RenderGroupBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RenderGroupBuilder<'a, 'b> {
            #[inline]
            pub fn add_renderMessages(
                &mut self,
                renderMessages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RenderMessage<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    RenderGroup::VT_RENDERMESSAGES,
                    renderMessages,
                );
            }
            #[inline]
            pub fn add_id(&mut self, id: i32) {
                self.fbb_.push_slot::<i32>(RenderGroup::VT_ID, id, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RenderGroupBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RenderGroupBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RenderGroup<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RenderGroup<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RenderGroup");
                ds.field("renderMessages", &self.renderMessages());
                ds.field("id", &self.id());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RenderGroupObject {
            pub renderMessages: Option<Vec<RenderMessageObject>>,
            pub id: i32,
        }
        impl Default for RenderGroupObject {
            fn default() -> Self {
                Self {
                    renderMessages: None,
                    id: 0,
                }
            }
        }
        impl RenderGroupObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RenderGroup<'b>> {
                let renderMessages = self.renderMessages.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let id = self.id;
                RenderGroup::create(_fbb, &RenderGroupArgs { renderMessages, id })
            }
        }
        pub enum QuickChatOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct QuickChat<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for QuickChat<'a> {
            type Inner = QuickChat<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> QuickChat<'a> {
            pub const VT_QUICKCHATSELECTION: flatbuffers::VOffsetT = 4;
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 6;
            pub const VT_TEAMONLY: flatbuffers::VOffsetT = 8;
            pub const VT_MESSAGEINDEX: flatbuffers::VOffsetT = 10;
            pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                QuickChat { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args QuickChatArgs,
            ) -> flatbuffers::WIPOffset<QuickChat<'bldr>> {
                let mut builder = QuickChatBuilder::new(_fbb);
                builder.add_timeStamp(args.timeStamp);
                builder.add_messageIndex(args.messageIndex);
                builder.add_playerIndex(args.playerIndex);
                builder.add_teamOnly(args.teamOnly);
                builder.add_quickChatSelection(args.quickChatSelection);
                builder.finish()
            }

            pub fn unpack(&self) -> QuickChatObject {
                let quickChatSelection = self.quickChatSelection();
                let playerIndex = self.playerIndex();
                let teamOnly = self.teamOnly();
                let messageIndex = self.messageIndex();
                let timeStamp = self.timeStamp();
                QuickChatObject {
                    quickChatSelection,
                    playerIndex,
                    teamOnly,
                    messageIndex,
                    timeStamp,
                }
            }

            #[inline]
            pub fn quickChatSelection(&self) -> QuickChatSelection {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<QuickChatSelection>(
                            QuickChat::VT_QUICKCHATSELECTION,
                            Some(QuickChatSelection::Information_IGotIt),
                        )
                        .unwrap()
                }
            }
            /// The index of the player that sent the quick chat
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(QuickChat::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
            /// True if the chat is team only false if everyone can see it.
            #[inline]
            pub fn teamOnly(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(QuickChat::VT_TEAMONLY, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn messageIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(QuickChat::VT_MESSAGEINDEX, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn timeStamp(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(QuickChat::VT_TIMESTAMP, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for QuickChat<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<QuickChatSelection>(
                        "quickChatSelection",
                        Self::VT_QUICKCHATSELECTION,
                        false,
                    )?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .visit_field::<bool>("teamOnly", Self::VT_TEAMONLY, false)?
                    .visit_field::<i32>("messageIndex", Self::VT_MESSAGEINDEX, false)?
                    .visit_field::<f32>("timeStamp", Self::VT_TIMESTAMP, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct QuickChatArgs {
            pub quickChatSelection: QuickChatSelection,
            pub playerIndex: i32,
            pub teamOnly: bool,
            pub messageIndex: i32,
            pub timeStamp: f32,
        }
        impl<'a> Default for QuickChatArgs {
            #[inline]
            fn default() -> Self {
                QuickChatArgs {
                    quickChatSelection: QuickChatSelection::Information_IGotIt,
                    playerIndex: 0,
                    teamOnly: false,
                    messageIndex: 0,
                    timeStamp: 0.0,
                }
            }
        }

        pub struct QuickChatBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> QuickChatBuilder<'a, 'b> {
            #[inline]
            pub fn add_quickChatSelection(&mut self, quickChatSelection: QuickChatSelection) {
                self.fbb_.push_slot::<QuickChatSelection>(
                    QuickChat::VT_QUICKCHATSELECTION,
                    quickChatSelection,
                    QuickChatSelection::Information_IGotIt,
                );
            }
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(QuickChat::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_teamOnly(&mut self, teamOnly: bool) {
                self.fbb_
                    .push_slot::<bool>(QuickChat::VT_TEAMONLY, teamOnly, false);
            }
            #[inline]
            pub fn add_messageIndex(&mut self, messageIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(QuickChat::VT_MESSAGEINDEX, messageIndex, 0);
            }
            #[inline]
            pub fn add_timeStamp(&mut self, timeStamp: f32) {
                self.fbb_
                    .push_slot::<f32>(QuickChat::VT_TIMESTAMP, timeStamp, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> QuickChatBuilder<'a, 'b> {
                let start = _fbb.start_table();
                QuickChatBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<QuickChat<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for QuickChat<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("QuickChat");
                ds.field("quickChatSelection", &self.quickChatSelection());
                ds.field("playerIndex", &self.playerIndex());
                ds.field("teamOnly", &self.teamOnly());
                ds.field("messageIndex", &self.messageIndex());
                ds.field("timeStamp", &self.timeStamp());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct QuickChatObject {
            pub quickChatSelection: QuickChatSelection,
            pub playerIndex: i32,
            pub teamOnly: bool,
            pub messageIndex: i32,
            pub timeStamp: f32,
        }
        impl Default for QuickChatObject {
            fn default() -> Self {
                Self {
                    quickChatSelection: QuickChatSelection::Information_IGotIt,
                    playerIndex: 0,
                    teamOnly: false,
                    messageIndex: 0,
                    timeStamp: 0.0,
                }
            }
        }
        impl QuickChatObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<QuickChat<'b>> {
                let quickChatSelection = self.quickChatSelection;
                let playerIndex = self.playerIndex;
                let teamOnly = self.teamOnly;
                let messageIndex = self.messageIndex;
                let timeStamp = self.timeStamp;
                QuickChat::create(
                    _fbb,
                    &QuickChatArgs {
                        quickChatSelection,
                        playerIndex,
                        teamOnly,
                        messageIndex,
                        timeStamp,
                    },
                )
            }
        }
        pub enum TinyPlayerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A minimal version of player data, useful when bandwidth needs to be conserved.
        pub struct TinyPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPlayer<'a> {
            type Inner = TinyPlayer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TinyPlayer<'a> {
            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_ROTATION: flatbuffers::VOffsetT = 6;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 8;
            pub const VT_HASWHEELCONTACT: flatbuffers::VOffsetT = 10;
            pub const VT_ISSUPERSONIC: flatbuffers::VOffsetT = 12;
            pub const VT_TEAM: flatbuffers::VOffsetT = 14;
            pub const VT_BOOST: flatbuffers::VOffsetT = 16;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPlayerArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyPlayer<'bldr>> {
                let mut builder = TinyPlayerBuilder::new(_fbb);
                builder.add_boost(args.boost);
                builder.add_team(args.team);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.rotation {
                    builder.add_rotation(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.add_isSupersonic(args.isSupersonic);
                builder.add_hasWheelContact(args.hasWheelContact);
                builder.finish()
            }

            pub fn unpack(&self) -> TinyPlayerObject {
                let location = self.location().map(|x| x.unpack());
                let rotation = self.rotation().map(|x| x.unpack());
                let velocity = self.velocity().map(|x| x.unpack());
                let hasWheelContact = self.hasWheelContact();
                let isSupersonic = self.isSupersonic();
                let team = self.team();
                let boost = self.boost();
                TinyPlayerObject {
                    location,
                    rotation,
                    velocity,
                    hasWheelContact,
                    isSupersonic,
                    team,
                    boost,
                }
            }

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(TinyPlayer::VT_LOCATION, None) }
            }
            #[inline]
            pub fn rotation(&self) -> Option<&'a Rotator> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Rotator>(TinyPlayer::VT_ROTATION, None) }
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(TinyPlayer::VT_VELOCITY, None) }
            }
            #[inline]
            pub fn hasWheelContact(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TinyPlayer::VT_HASWHEELCONTACT, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn isSupersonic(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(TinyPlayer::VT_ISSUPERSONIC, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn team(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(TinyPlayer::VT_TEAM, Some(0)).unwrap() }
            }
            #[inline]
            pub fn boost(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<i32>(TinyPlayer::VT_BOOST, Some(0)).unwrap() }
            }
        }

        impl flatbuffers::Verifiable for TinyPlayer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Rotator>("rotation", Self::VT_ROTATION, false)?
                    .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
                    .visit_field::<bool>("hasWheelContact", Self::VT_HASWHEELCONTACT, false)?
                    .visit_field::<bool>("isSupersonic", Self::VT_ISSUPERSONIC, false)?
                    .visit_field::<i32>("team", Self::VT_TEAM, false)?
                    .visit_field::<i32>("boost", Self::VT_BOOST, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TinyPlayerArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub rotation: Option<&'a Rotator>,
            pub velocity: Option<&'a Vector3>,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub team: i32,
            pub boost: i32,
        }
        impl<'a> Default for TinyPlayerArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPlayerArgs {
                    location: None,
                    rotation: None,
                    velocity: None,
                    hasWheelContact: false,
                    isSupersonic: false,
                    team: 0,
                    boost: 0,
                }
            }
        }

        pub struct TinyPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_rotation(&mut self, rotation: &Rotator) {
                self.fbb_
                    .push_slot_always::<&Rotator>(TinyPlayer::VT_ROTATION, rotation);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyPlayer::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn add_hasWheelContact(&mut self, hasWheelContact: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_HASWHEELCONTACT, hasWheelContact, false);
            }
            #[inline]
            pub fn add_isSupersonic(&mut self, isSupersonic: bool) {
                self.fbb_
                    .push_slot::<bool>(TinyPlayer::VT_ISSUPERSONIC, isSupersonic, false);
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_boost(&mut self, boost: i32) {
                self.fbb_.push_slot::<i32>(TinyPlayer::VT_BOOST, boost, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TinyPlayer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TinyPlayer");
                ds.field("location", &self.location());
                ds.field("rotation", &self.rotation());
                ds.field("velocity", &self.velocity());
                ds.field("hasWheelContact", &self.hasWheelContact());
                ds.field("isSupersonic", &self.isSupersonic());
                ds.field("team", &self.team());
                ds.field("boost", &self.boost());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct TinyPlayerObject {
            pub location: Option<Vector3Object>,
            pub rotation: Option<RotatorObject>,
            pub velocity: Option<Vector3Object>,
            pub hasWheelContact: bool,
            pub isSupersonic: bool,
            pub team: i32,
            pub boost: i32,
        }
        impl Default for TinyPlayerObject {
            fn default() -> Self {
                Self {
                    location: None,
                    rotation: None,
                    velocity: None,
                    hasWheelContact: false,
                    isSupersonic: false,
                    team: 0,
                    boost: 0,
                }
            }
        }
        impl TinyPlayerObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TinyPlayer<'b>> {
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let rotation_tmp = self.rotation.as_ref().map(|x| x.pack());
                let rotation = rotation_tmp.as_ref();
                let velocity_tmp = self.velocity.as_ref().map(|x| x.pack());
                let velocity = velocity_tmp.as_ref();
                let hasWheelContact = self.hasWheelContact;
                let isSupersonic = self.isSupersonic;
                let team = self.team;
                let boost = self.boost;
                TinyPlayer::create(
                    _fbb,
                    &TinyPlayerArgs {
                        location,
                        rotation,
                        velocity,
                        hasWheelContact,
                        isSupersonic,
                        team,
                        boost,
                    },
                )
            }
        }
        pub enum TinyBallOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A minimal version of the ball, useful when bandwidth needs to be conserved.
        pub struct TinyBall<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyBall<'a> {
            type Inner = TinyBall<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TinyBall<'a> {
            pub const VT_LOCATION: flatbuffers::VOffsetT = 4;
            pub const VT_VELOCITY: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyBall { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyBallArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyBall<'bldr>> {
                let mut builder = TinyBallBuilder::new(_fbb);
                if let Some(x) = args.velocity {
                    builder.add_velocity(x);
                }
                if let Some(x) = args.location {
                    builder.add_location(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> TinyBallObject {
                let location = self.location().map(|x| x.unpack());
                let velocity = self.velocity().map(|x| x.unpack());
                TinyBallObject { location, velocity }
            }

            #[inline]
            pub fn location(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(TinyBall::VT_LOCATION, None) }
            }
            #[inline]
            pub fn velocity(&self) -> Option<&'a Vector3> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe { self._tab.get::<Vector3>(TinyBall::VT_VELOCITY, None) }
            }
        }

        impl flatbuffers::Verifiable for TinyBall<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<Vector3>("location", Self::VT_LOCATION, false)?
                    .visit_field::<Vector3>("velocity", Self::VT_VELOCITY, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct TinyBallArgs<'a> {
            pub location: Option<&'a Vector3>,
            pub velocity: Option<&'a Vector3>,
        }
        impl<'a> Default for TinyBallArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyBallArgs {
                    location: None,
                    velocity: None,
                }
            }
        }

        pub struct TinyBallBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyBallBuilder<'a, 'b> {
            #[inline]
            pub fn add_location(&mut self, location: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_LOCATION, location);
            }
            #[inline]
            pub fn add_velocity(&mut self, velocity: &Vector3) {
                self.fbb_
                    .push_slot_always::<&Vector3>(TinyBall::VT_VELOCITY, velocity);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyBallBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyBallBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyBall<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TinyBall<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TinyBall");
                ds.field("location", &self.location());
                ds.field("velocity", &self.velocity());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct TinyBallObject {
            pub location: Option<Vector3Object>,
            pub velocity: Option<Vector3Object>,
        }
        impl Default for TinyBallObject {
            fn default() -> Self {
                Self {
                    location: None,
                    velocity: None,
                }
            }
        }
        impl TinyBallObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TinyBall<'b>> {
                let location_tmp = self.location.as_ref().map(|x| x.pack());
                let location = location_tmp.as_ref();
                let velocity_tmp = self.velocity.as_ref().map(|x| x.pack());
                let velocity = velocity_tmp.as_ref();
                TinyBall::create(_fbb, &TinyBallArgs { location, velocity })
            }
        }
        pub enum TinyPacketOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A minimal version of the game tick packet, useful when bandwidth needs to be conserved.
        pub struct TinyPacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for TinyPacket<'a> {
            type Inner = TinyPacket<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> TinyPacket<'a> {
            pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;
            pub const VT_BALL: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                TinyPacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args TinyPacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<TinyPacket<'bldr>> {
                let mut builder = TinyPacketBuilder::new(_fbb);
                if let Some(x) = args.ball {
                    builder.add_ball(x);
                }
                if let Some(x) = args.players {
                    builder.add_players(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> TinyPacketObject {
                let players = self
                    .players()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let ball = self.ball().map(|x| Box::new(x.unpack()));
                TinyPacketObject { players, ball }
            }

            #[inline]
            pub fn players(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer>>,
                    >>(TinyPacket::VT_PLAYERS, None)
                }
            }
            #[inline]
            pub fn ball(&self) -> Option<TinyBall<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<TinyBall>>(TinyPacket::VT_BALL, None)
                }
            }
        }

        impl flatbuffers::Verifiable for TinyPacket<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TinyPlayer>>,
                    >>("players", Self::VT_PLAYERS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<TinyBall>>(
                        "ball",
                        Self::VT_BALL,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct TinyPacketArgs<'a> {
            pub players: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TinyPlayer<'a>>>,
                >,
            >,
            pub ball: Option<flatbuffers::WIPOffset<TinyBall<'a>>>,
        }
        impl<'a> Default for TinyPacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                TinyPacketArgs {
                    players: None,
                    ball: None,
                }
            }
        }

        pub struct TinyPacketBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> TinyPacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_players(
                &mut self,
                players: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TinyPlayer<'b>>>,
                >,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<_>>(TinyPacket::VT_PLAYERS, players);
            }
            #[inline]
            pub fn add_ball(&mut self, ball: flatbuffers::WIPOffset<TinyBall<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<TinyBall>>(
                        TinyPacket::VT_BALL,
                        ball,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> TinyPacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                TinyPacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<TinyPacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for TinyPacket<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("TinyPacket");
                ds.field("players", &self.players());
                ds.field("ball", &self.ball());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct TinyPacketObject {
            pub players: Option<Vec<TinyPlayerObject>>,
            pub ball: Option<Box<TinyBallObject>>,
        }
        impl Default for TinyPacketObject {
            fn default() -> Self {
                Self {
                    players: None,
                    ball: None,
                }
            }
        }
        impl TinyPacketObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<TinyPacket<'b>> {
                let players = self.players.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let ball = self.ball.as_ref().map(|x| x.pack(_fbb));
                TinyPacket::create(_fbb, &TinyPacketArgs { players, ball })
            }
        }
        pub enum PredictionSliceOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PredictionSlice<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PredictionSlice<'a> {
            type Inner = PredictionSlice<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PredictionSlice<'a> {
            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 4;
            pub const VT_PHYSICS: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PredictionSlice { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PredictionSliceArgs<'args>,
            ) -> flatbuffers::WIPOffset<PredictionSlice<'bldr>> {
                let mut builder = PredictionSliceBuilder::new(_fbb);
                if let Some(x) = args.physics {
                    builder.add_physics(x);
                }
                builder.add_gameSeconds(args.gameSeconds);
                builder.finish()
            }

            pub fn unpack(&self) -> PredictionSliceObject {
                let gameSeconds = self.gameSeconds();
                let physics = self.physics().map(|x| Box::new(x.unpack()));
                PredictionSliceObject {
                    gameSeconds,
                    physics,
                }
            }

            /// The moment in game time that this prediction corresponds to.
            /// This corresponds to 'secondsElapsed' in the GameInfo table.
            #[inline]
            pub fn gameSeconds(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(PredictionSlice::VT_GAMESECONDS, Some(0.0))
                        .unwrap()
                }
            }
            /// The predicted location and motion of the object.
            #[inline]
            pub fn physics(&self) -> Option<Physics<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<Physics>>(
                        PredictionSlice::VT_PHYSICS,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for PredictionSlice<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<Physics>>(
                        "physics",
                        Self::VT_PHYSICS,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PredictionSliceArgs<'a> {
            pub gameSeconds: f32,
            pub physics: Option<flatbuffers::WIPOffset<Physics<'a>>>,
        }
        impl<'a> Default for PredictionSliceArgs<'a> {
            #[inline]
            fn default() -> Self {
                PredictionSliceArgs {
                    gameSeconds: 0.0,
                    physics: None,
                }
            }
        }

        pub struct PredictionSliceBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PredictionSliceBuilder<'a, 'b> {
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(PredictionSlice::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_physics(&mut self, physics: flatbuffers::WIPOffset<Physics<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<Physics>>(
                        PredictionSlice::VT_PHYSICS,
                        physics,
                    );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PredictionSliceBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PredictionSliceBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PredictionSlice<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PredictionSlice<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PredictionSlice");
                ds.field("gameSeconds", &self.gameSeconds());
                ds.field("physics", &self.physics());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PredictionSliceObject {
            pub gameSeconds: f32,
            pub physics: Option<Box<PhysicsObject>>,
        }
        impl Default for PredictionSliceObject {
            fn default() -> Self {
                Self {
                    gameSeconds: 0.0,
                    physics: None,
                }
            }
        }
        impl PredictionSliceObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PredictionSlice<'b>> {
                let gameSeconds = self.gameSeconds;
                let physics = self.physics.as_ref().map(|x| x.pack(_fbb));
                PredictionSlice::create(
                    _fbb,
                    &PredictionSliceArgs {
                        gameSeconds,
                        physics,
                    },
                )
            }
        }
        pub enum BallPredictionOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct BallPrediction<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for BallPrediction<'a> {
            type Inner = BallPrediction<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> BallPrediction<'a> {
            pub const VT_SLICES: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                BallPrediction { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args BallPredictionArgs<'args>,
            ) -> flatbuffers::WIPOffset<BallPrediction<'bldr>> {
                let mut builder = BallPredictionBuilder::new(_fbb);
                if let Some(x) = args.slices {
                    builder.add_slices(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> BallPredictionObject {
                let slices = self
                    .slices()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                BallPredictionObject { slices }
            }

            /// A list of places the ball will be at specific times in the future.
            /// It is guaranteed to sorted so that time increases with each slice.
            /// It is NOT guaranteed to have a consistent amount of time between slices.
            #[inline]
            pub fn slices(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice>>,
                    >>(BallPrediction::VT_SLICES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for BallPrediction<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PredictionSlice>>,
                    >>("slices", Self::VT_SLICES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct BallPredictionArgs<'a> {
            pub slices: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PredictionSlice<'a>>>,
                >,
            >,
        }
        impl<'a> Default for BallPredictionArgs<'a> {
            #[inline]
            fn default() -> Self {
                BallPredictionArgs { slices: None }
            }
        }

        pub struct BallPredictionBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> BallPredictionBuilder<'a, 'b> {
            #[inline]
            pub fn add_slices(
                &mut self,
                slices: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PredictionSlice<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    BallPrediction::VT_SLICES,
                    slices,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> BallPredictionBuilder<'a, 'b> {
                let start = _fbb.start_table();
                BallPredictionBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<BallPrediction<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for BallPrediction<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("BallPrediction");
                ds.field("slices", &self.slices());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct BallPredictionObject {
            pub slices: Option<Vec<PredictionSliceObject>>,
        }
        impl Default for BallPredictionObject {
            fn default() -> Self {
                Self { slices: None }
            }
        }
        impl BallPredictionObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<BallPrediction<'b>> {
                let slices = self.slices.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                BallPrediction::create(_fbb, &BallPredictionArgs { slices })
            }
        }
        pub enum RLBotPlayerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A bot controlled by the RLBot framework
        pub struct RLBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for RLBotPlayer<'a> {
            type Inner = RLBotPlayer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> RLBotPlayer<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                RLBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args RLBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<RLBotPlayer<'bldr>> {
                let mut builder = RLBotPlayerBuilder::new(_fbb);
                builder.finish()
            }

            pub fn unpack(&self) -> RLBotPlayerObject {
                RLBotPlayerObject {}
            }
        }

        impl flatbuffers::Verifiable for RLBotPlayer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct RLBotPlayerArgs {}
        impl<'a> Default for RLBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                RLBotPlayerArgs {}
            }
        }

        pub struct RLBotPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> RLBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> RLBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                RLBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<RLBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for RLBotPlayer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("RLBotPlayer");
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct RLBotPlayerObject {}
        impl Default for RLBotPlayerObject {
            fn default() -> Self {
                Self {}
            }
        }
        impl RLBotPlayerObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<RLBotPlayer<'b>> {
                RLBotPlayer::create(_fbb, &RLBotPlayerArgs {})
            }
        }
        pub enum HumanPlayerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A normal human player
        pub struct HumanPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for HumanPlayer<'a> {
            type Inner = HumanPlayer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> HumanPlayer<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                HumanPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args HumanPlayerArgs,
            ) -> flatbuffers::WIPOffset<HumanPlayer<'bldr>> {
                let mut builder = HumanPlayerBuilder::new(_fbb);
                builder.finish()
            }

            pub fn unpack(&self) -> HumanPlayerObject {
                HumanPlayerObject {}
            }
        }

        impl flatbuffers::Verifiable for HumanPlayer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct HumanPlayerArgs {}
        impl<'a> Default for HumanPlayerArgs {
            #[inline]
            fn default() -> Self {
                HumanPlayerArgs {}
            }
        }

        pub struct HumanPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> HumanPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> HumanPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                HumanPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<HumanPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for HumanPlayer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("HumanPlayer");
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct HumanPlayerObject {}
        impl Default for HumanPlayerObject {
            fn default() -> Self {
                Self {}
            }
        }
        impl HumanPlayerObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<HumanPlayer<'b>> {
                HumanPlayer::create(_fbb, &HumanPlayerArgs {})
            }
        }
        pub enum PsyonixBotPlayerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A psyonix bot, e.g. All Star bot
        pub struct PsyonixBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PsyonixBotPlayer<'a> {
            type Inner = PsyonixBotPlayer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PsyonixBotPlayer<'a> {
            pub const VT_BOTSKILL: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PsyonixBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PsyonixBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'bldr>> {
                let mut builder = PsyonixBotPlayerBuilder::new(_fbb);
                builder.add_botSkill(args.botSkill);
                builder.finish()
            }

            pub fn unpack(&self) -> PsyonixBotPlayerObject {
                let botSkill = self.botSkill();
                PsyonixBotPlayerObject { botSkill }
            }

            #[inline]
            pub fn botSkill(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(PsyonixBotPlayer::VT_BOTSKILL, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for PsyonixBotPlayer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<f32>("botSkill", Self::VT_BOTSKILL, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PsyonixBotPlayerArgs {
            pub botSkill: f32,
        }
        impl<'a> Default for PsyonixBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                PsyonixBotPlayerArgs { botSkill: 0.0 }
            }
        }

        pub struct PsyonixBotPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PsyonixBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn add_botSkill(&mut self, botSkill: f32) {
                self.fbb_
                    .push_slot::<f32>(PsyonixBotPlayer::VT_BOTSKILL, botSkill, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PsyonixBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PsyonixBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PsyonixBotPlayer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PsyonixBotPlayer");
                ds.field("botSkill", &self.botSkill());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PsyonixBotPlayerObject {
            pub botSkill: f32,
        }
        impl Default for PsyonixBotPlayerObject {
            fn default() -> Self {
                Self { botSkill: 0.0 }
            }
        }
        impl PsyonixBotPlayerObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PsyonixBotPlayer<'b>> {
                let botSkill = self.botSkill;
                PsyonixBotPlayer::create(_fbb, &PsyonixBotPlayerArgs { botSkill })
            }
        }
        pub enum PartyMemberBotPlayerOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// A player that Rocket League treats as human, e.g. has a dedicated camera and can do training mode,
        /// but is actually controlled by a bot.
        pub struct PartyMemberBotPlayer<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PartyMemberBotPlayer<'a> {
            type Inner = PartyMemberBotPlayer<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PartyMemberBotPlayer<'a> {
            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PartyMemberBotPlayer { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                _args: &'args PartyMemberBotPlayerArgs,
            ) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'bldr>> {
                let mut builder = PartyMemberBotPlayerBuilder::new(_fbb);
                builder.finish()
            }

            pub fn unpack(&self) -> PartyMemberBotPlayerObject {
                PartyMemberBotPlayerObject {}
            }
        }

        impl flatbuffers::Verifiable for PartyMemberBotPlayer<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?.finish();
                Ok(())
            }
        }
        pub struct PartyMemberBotPlayerArgs {}
        impl<'a> Default for PartyMemberBotPlayerArgs {
            #[inline]
            fn default() -> Self {
                PartyMemberBotPlayerArgs {}
            }
        }

        pub struct PartyMemberBotPlayerBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PartyMemberBotPlayerBuilder<'a, 'b> {
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PartyMemberBotPlayerBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PartyMemberBotPlayerBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PartyMemberBotPlayer<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PartyMemberBotPlayer");
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PartyMemberBotPlayerObject {}
        impl Default for PartyMemberBotPlayerObject {
            fn default() -> Self {
                Self {}
            }
        }
        impl PartyMemberBotPlayerObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PartyMemberBotPlayer<'b>> {
                PartyMemberBotPlayer::create(_fbb, &PartyMemberBotPlayerArgs {})
            }
        }
        pub enum PlayerLoadoutOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// The car type, color, and other aspects of the player's appearance.
        /// See https://github.com/RLBot/RLBot/wiki/Bot-Customization
        pub struct PlayerLoadout<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerLoadout<'a> {
            type Inner = PlayerLoadout<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerLoadout<'a> {
            pub const VT_TEAMCOLORID: flatbuffers::VOffsetT = 4;
            pub const VT_CUSTOMCOLORID: flatbuffers::VOffsetT = 6;
            pub const VT_CARID: flatbuffers::VOffsetT = 8;
            pub const VT_DECALID: flatbuffers::VOffsetT = 10;
            pub const VT_WHEELSID: flatbuffers::VOffsetT = 12;
            pub const VT_BOOSTID: flatbuffers::VOffsetT = 14;
            pub const VT_ANTENNAID: flatbuffers::VOffsetT = 16;
            pub const VT_HATID: flatbuffers::VOffsetT = 18;
            pub const VT_PAINTFINISHID: flatbuffers::VOffsetT = 20;
            pub const VT_CUSTOMFINISHID: flatbuffers::VOffsetT = 22;
            pub const VT_ENGINEAUDIOID: flatbuffers::VOffsetT = 24;
            pub const VT_TRAILSID: flatbuffers::VOffsetT = 26;
            pub const VT_GOALEXPLOSIONID: flatbuffers::VOffsetT = 28;
            pub const VT_LOADOUTPAINT: flatbuffers::VOffsetT = 30;
            pub const VT_PRIMARYCOLORLOOKUP: flatbuffers::VOffsetT = 32;
            pub const VT_SECONDARYCOLORLOOKUP: flatbuffers::VOffsetT = 34;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerLoadout { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerLoadoutArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerLoadout<'bldr>> {
                let mut builder = PlayerLoadoutBuilder::new(_fbb);
                if let Some(x) = args.secondaryColorLookup {
                    builder.add_secondaryColorLookup(x);
                }
                if let Some(x) = args.primaryColorLookup {
                    builder.add_primaryColorLookup(x);
                }
                if let Some(x) = args.loadoutPaint {
                    builder.add_loadoutPaint(x);
                }
                builder.add_goalExplosionId(args.goalExplosionId);
                builder.add_trailsId(args.trailsId);
                builder.add_engineAudioId(args.engineAudioId);
                builder.add_customFinishId(args.customFinishId);
                builder.add_paintFinishId(args.paintFinishId);
                builder.add_hatId(args.hatId);
                builder.add_antennaId(args.antennaId);
                builder.add_boostId(args.boostId);
                builder.add_wheelsId(args.wheelsId);
                builder.add_decalId(args.decalId);
                builder.add_carId(args.carId);
                builder.add_customColorId(args.customColorId);
                builder.add_teamColorId(args.teamColorId);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerLoadoutObject {
                let teamColorId = self.teamColorId();
                let customColorId = self.customColorId();
                let carId = self.carId();
                let decalId = self.decalId();
                let wheelsId = self.wheelsId();
                let boostId = self.boostId();
                let antennaId = self.antennaId();
                let hatId = self.hatId();
                let paintFinishId = self.paintFinishId();
                let customFinishId = self.customFinishId();
                let engineAudioId = self.engineAudioId();
                let trailsId = self.trailsId();
                let goalExplosionId = self.goalExplosionId();
                let loadoutPaint = self.loadoutPaint().map(|x| Box::new(x.unpack()));
                let primaryColorLookup = self.primaryColorLookup().map(|x| Box::new(x.unpack()));
                let secondaryColorLookup =
                    self.secondaryColorLookup().map(|x| Box::new(x.unpack()));
                PlayerLoadoutObject {
                    teamColorId,
                    customColorId,
                    carId,
                    decalId,
                    wheelsId,
                    boostId,
                    antennaId,
                    hatId,
                    paintFinishId,
                    customFinishId,
                    engineAudioId,
                    trailsId,
                    goalExplosionId,
                    loadoutPaint,
                    primaryColorLookup,
                    secondaryColorLookup,
                }
            }

            #[inline]
            pub fn teamColorId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_TEAMCOLORID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn customColorId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn carId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_CARID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn decalId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_DECALID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn wheelsId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_WHEELSID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn boostId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_BOOSTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn antennaId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_ANTENNAID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn hatId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_HATID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn paintFinishId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_PAINTFINISHID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn customFinishId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn engineAudioId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn trailsId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_TRAILSID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn goalExplosionId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn loadoutPaint(&self) -> Option<LoadoutPaint<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<LoadoutPaint>>(
                        PlayerLoadout::VT_LOADOUTPAINT,
                        None,
                    )
                }
            }
            /// Sets the primary color of the car to the swatch that most closely matches the provided
            /// RGB color value. If set, this overrides teamColorId.
            #[inline]
            pub fn primaryColorLookup(&self) -> Option<Color<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(
                        PlayerLoadout::VT_PRIMARYCOLORLOOKUP,
                        None,
                    )
                }
            }
            /// Sets the secondary color of the car to the swatch that most closely matches the provided
            /// RGB color value. If set, this overrides customColorId.
            #[inline]
            pub fn secondaryColorLookup(&self) -> Option<Color<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<Color>>(
                        PlayerLoadout::VT_SECONDARYCOLORLOOKUP,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerLoadout<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("teamColorId", Self::VT_TEAMCOLORID, false)?
                    .visit_field::<i32>("customColorId", Self::VT_CUSTOMCOLORID, false)?
                    .visit_field::<i32>("carId", Self::VT_CARID, false)?
                    .visit_field::<i32>("decalId", Self::VT_DECALID, false)?
                    .visit_field::<i32>("wheelsId", Self::VT_WHEELSID, false)?
                    .visit_field::<i32>("boostId", Self::VT_BOOSTID, false)?
                    .visit_field::<i32>("antennaId", Self::VT_ANTENNAID, false)?
                    .visit_field::<i32>("hatId", Self::VT_HATID, false)?
                    .visit_field::<i32>("paintFinishId", Self::VT_PAINTFINISHID, false)?
                    .visit_field::<i32>("customFinishId", Self::VT_CUSTOMFINISHID, false)?
                    .visit_field::<i32>("engineAudioId", Self::VT_ENGINEAUDIOID, false)?
                    .visit_field::<i32>("trailsId", Self::VT_TRAILSID, false)?
                    .visit_field::<i32>("goalExplosionId", Self::VT_GOALEXPLOSIONID, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<LoadoutPaint>>(
                        "loadoutPaint",
                        Self::VT_LOADOUTPAINT,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<Color>>(
                        "primaryColorLookup",
                        Self::VT_PRIMARYCOLORLOOKUP,
                        false,
                    )?
                    .visit_field::<flatbuffers::ForwardsUOffset<Color>>(
                        "secondaryColorLookup",
                        Self::VT_SECONDARYCOLORLOOKUP,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerLoadoutArgs<'a> {
            pub teamColorId: i32,
            pub customColorId: i32,
            pub carId: i32,
            pub decalId: i32,
            pub wheelsId: i32,
            pub boostId: i32,
            pub antennaId: i32,
            pub hatId: i32,
            pub paintFinishId: i32,
            pub customFinishId: i32,
            pub engineAudioId: i32,
            pub trailsId: i32,
            pub goalExplosionId: i32,
            pub loadoutPaint: Option<flatbuffers::WIPOffset<LoadoutPaint<'a>>>,
            pub primaryColorLookup: Option<flatbuffers::WIPOffset<Color<'a>>>,
            pub secondaryColorLookup: Option<flatbuffers::WIPOffset<Color<'a>>>,
        }
        impl<'a> Default for PlayerLoadoutArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerLoadoutArgs {
                    teamColorId: 0,
                    customColorId: 0,
                    carId: 0,
                    decalId: 0,
                    wheelsId: 0,
                    boostId: 0,
                    antennaId: 0,
                    hatId: 0,
                    paintFinishId: 0,
                    customFinishId: 0,
                    engineAudioId: 0,
                    trailsId: 0,
                    goalExplosionId: 0,
                    loadoutPaint: None,
                    primaryColorLookup: None,
                    secondaryColorLookup: None,
                }
            }
        }

        pub struct PlayerLoadoutBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerLoadoutBuilder<'a, 'b> {
            #[inline]
            pub fn add_teamColorId(&mut self, teamColorId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_TEAMCOLORID, teamColorId, 0);
            }
            #[inline]
            pub fn add_customColorId(&mut self, customColorId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CUSTOMCOLORID, customColorId, 0);
            }
            #[inline]
            pub fn add_carId(&mut self, carId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CARID, carId, 0);
            }
            #[inline]
            pub fn add_decalId(&mut self, decalId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_DECALID, decalId, 0);
            }
            #[inline]
            pub fn add_wheelsId(&mut self, wheelsId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_WHEELSID, wheelsId, 0);
            }
            #[inline]
            pub fn add_boostId(&mut self, boostId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_BOOSTID, boostId, 0);
            }
            #[inline]
            pub fn add_antennaId(&mut self, antennaId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_ANTENNAID, antennaId, 0);
            }
            #[inline]
            pub fn add_hatId(&mut self, hatId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_HATID, hatId, 0);
            }
            #[inline]
            pub fn add_paintFinishId(&mut self, paintFinishId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_PAINTFINISHID, paintFinishId, 0);
            }
            #[inline]
            pub fn add_customFinishId(&mut self, customFinishId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_CUSTOMFINISHID, customFinishId, 0);
            }
            #[inline]
            pub fn add_engineAudioId(&mut self, engineAudioId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_ENGINEAUDIOID, engineAudioId, 0);
            }
            #[inline]
            pub fn add_trailsId(&mut self, trailsId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_TRAILSID, trailsId, 0);
            }
            #[inline]
            pub fn add_goalExplosionId(&mut self, goalExplosionId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerLoadout::VT_GOALEXPLOSIONID, goalExplosionId, 0);
            }
            #[inline]
            pub fn add_loadoutPaint(
                &mut self,
                loadoutPaint: flatbuffers::WIPOffset<LoadoutPaint<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<LoadoutPaint>>(
                        PlayerLoadout::VT_LOADOUTPAINT,
                        loadoutPaint,
                    );
            }
            #[inline]
            pub fn add_primaryColorLookup(
                &mut self,
                primaryColorLookup: flatbuffers::WIPOffset<Color<'b>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(
                    PlayerLoadout::VT_PRIMARYCOLORLOOKUP,
                    primaryColorLookup,
                );
            }
            #[inline]
            pub fn add_secondaryColorLookup(
                &mut self,
                secondaryColorLookup: flatbuffers::WIPOffset<Color<'b>>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Color>>(
                    PlayerLoadout::VT_SECONDARYCOLORLOOKUP,
                    secondaryColorLookup,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerLoadoutBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerLoadoutBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerLoadout<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerLoadout<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerLoadout");
                ds.field("teamColorId", &self.teamColorId());
                ds.field("customColorId", &self.customColorId());
                ds.field("carId", &self.carId());
                ds.field("decalId", &self.decalId());
                ds.field("wheelsId", &self.wheelsId());
                ds.field("boostId", &self.boostId());
                ds.field("antennaId", &self.antennaId());
                ds.field("hatId", &self.hatId());
                ds.field("paintFinishId", &self.paintFinishId());
                ds.field("customFinishId", &self.customFinishId());
                ds.field("engineAudioId", &self.engineAudioId());
                ds.field("trailsId", &self.trailsId());
                ds.field("goalExplosionId", &self.goalExplosionId());
                ds.field("loadoutPaint", &self.loadoutPaint());
                ds.field("primaryColorLookup", &self.primaryColorLookup());
                ds.field("secondaryColorLookup", &self.secondaryColorLookup());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerLoadoutObject {
            pub teamColorId: i32,
            pub customColorId: i32,
            pub carId: i32,
            pub decalId: i32,
            pub wheelsId: i32,
            pub boostId: i32,
            pub antennaId: i32,
            pub hatId: i32,
            pub paintFinishId: i32,
            pub customFinishId: i32,
            pub engineAudioId: i32,
            pub trailsId: i32,
            pub goalExplosionId: i32,
            pub loadoutPaint: Option<Box<LoadoutPaintObject>>,
            pub primaryColorLookup: Option<Box<ColorObject>>,
            pub secondaryColorLookup: Option<Box<ColorObject>>,
        }
        impl Default for PlayerLoadoutObject {
            fn default() -> Self {
                Self {
                    teamColorId: 0,
                    customColorId: 0,
                    carId: 0,
                    decalId: 0,
                    wheelsId: 0,
                    boostId: 0,
                    antennaId: 0,
                    hatId: 0,
                    paintFinishId: 0,
                    customFinishId: 0,
                    engineAudioId: 0,
                    trailsId: 0,
                    goalExplosionId: 0,
                    loadoutPaint: None,
                    primaryColorLookup: None,
                    secondaryColorLookup: None,
                }
            }
        }
        impl PlayerLoadoutObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerLoadout<'b>> {
                let teamColorId = self.teamColorId;
                let customColorId = self.customColorId;
                let carId = self.carId;
                let decalId = self.decalId;
                let wheelsId = self.wheelsId;
                let boostId = self.boostId;
                let antennaId = self.antennaId;
                let hatId = self.hatId;
                let paintFinishId = self.paintFinishId;
                let customFinishId = self.customFinishId;
                let engineAudioId = self.engineAudioId;
                let trailsId = self.trailsId;
                let goalExplosionId = self.goalExplosionId;
                let loadoutPaint = self.loadoutPaint.as_ref().map(|x| x.pack(_fbb));
                let primaryColorLookup = self.primaryColorLookup.as_ref().map(|x| x.pack(_fbb));
                let secondaryColorLookup = self.secondaryColorLookup.as_ref().map(|x| x.pack(_fbb));
                PlayerLoadout::create(
                    _fbb,
                    &PlayerLoadoutArgs {
                        teamColorId,
                        customColorId,
                        carId,
                        decalId,
                        wheelsId,
                        boostId,
                        antennaId,
                        hatId,
                        paintFinishId,
                        customFinishId,
                        engineAudioId,
                        trailsId,
                        goalExplosionId,
                        loadoutPaint,
                        primaryColorLookup,
                        secondaryColorLookup,
                    },
                )
            }
        }
        pub enum LoadoutPaintOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Specification for 'painted' items. See https://github.com/RLBot/RLBot/wiki/Bot-Customization
        pub struct LoadoutPaint<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for LoadoutPaint<'a> {
            type Inner = LoadoutPaint<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> LoadoutPaint<'a> {
            pub const VT_CARPAINTID: flatbuffers::VOffsetT = 4;
            pub const VT_DECALPAINTID: flatbuffers::VOffsetT = 6;
            pub const VT_WHEELSPAINTID: flatbuffers::VOffsetT = 8;
            pub const VT_BOOSTPAINTID: flatbuffers::VOffsetT = 10;
            pub const VT_ANTENNAPAINTID: flatbuffers::VOffsetT = 12;
            pub const VT_HATPAINTID: flatbuffers::VOffsetT = 14;
            pub const VT_TRAILSPAINTID: flatbuffers::VOffsetT = 16;
            pub const VT_GOALEXPLOSIONPAINTID: flatbuffers::VOffsetT = 18;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                LoadoutPaint { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args LoadoutPaintArgs,
            ) -> flatbuffers::WIPOffset<LoadoutPaint<'bldr>> {
                let mut builder = LoadoutPaintBuilder::new(_fbb);
                builder.add_goalExplosionPaintId(args.goalExplosionPaintId);
                builder.add_trailsPaintId(args.trailsPaintId);
                builder.add_hatPaintId(args.hatPaintId);
                builder.add_antennaPaintId(args.antennaPaintId);
                builder.add_boostPaintId(args.boostPaintId);
                builder.add_wheelsPaintId(args.wheelsPaintId);
                builder.add_decalPaintId(args.decalPaintId);
                builder.add_carPaintId(args.carPaintId);
                builder.finish()
            }

            pub fn unpack(&self) -> LoadoutPaintObject {
                let carPaintId = self.carPaintId();
                let decalPaintId = self.decalPaintId();
                let wheelsPaintId = self.wheelsPaintId();
                let boostPaintId = self.boostPaintId();
                let antennaPaintId = self.antennaPaintId();
                let hatPaintId = self.hatPaintId();
                let trailsPaintId = self.trailsPaintId();
                let goalExplosionPaintId = self.goalExplosionPaintId();
                LoadoutPaintObject {
                    carPaintId,
                    decalPaintId,
                    wheelsPaintId,
                    boostPaintId,
                    antennaPaintId,
                    hatPaintId,
                    trailsPaintId,
                    goalExplosionPaintId,
                }
            }

            #[inline]
            pub fn carPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_CARPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn decalPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_DECALPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn wheelsPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_WHEELSPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn boostPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_BOOSTPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn antennaPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn hatPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_HATPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn trailsPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_TRAILSPAINTID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn goalExplosionPaintId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(LoadoutPaint::VT_GOALEXPLOSIONPAINTID, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for LoadoutPaint<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("carPaintId", Self::VT_CARPAINTID, false)?
                    .visit_field::<i32>("decalPaintId", Self::VT_DECALPAINTID, false)?
                    .visit_field::<i32>("wheelsPaintId", Self::VT_WHEELSPAINTID, false)?
                    .visit_field::<i32>("boostPaintId", Self::VT_BOOSTPAINTID, false)?
                    .visit_field::<i32>("antennaPaintId", Self::VT_ANTENNAPAINTID, false)?
                    .visit_field::<i32>("hatPaintId", Self::VT_HATPAINTID, false)?
                    .visit_field::<i32>("trailsPaintId", Self::VT_TRAILSPAINTID, false)?
                    .visit_field::<i32>(
                        "goalExplosionPaintId",
                        Self::VT_GOALEXPLOSIONPAINTID,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct LoadoutPaintArgs {
            pub carPaintId: i32,
            pub decalPaintId: i32,
            pub wheelsPaintId: i32,
            pub boostPaintId: i32,
            pub antennaPaintId: i32,
            pub hatPaintId: i32,
            pub trailsPaintId: i32,
            pub goalExplosionPaintId: i32,
        }
        impl<'a> Default for LoadoutPaintArgs {
            #[inline]
            fn default() -> Self {
                LoadoutPaintArgs {
                    carPaintId: 0,
                    decalPaintId: 0,
                    wheelsPaintId: 0,
                    boostPaintId: 0,
                    antennaPaintId: 0,
                    hatPaintId: 0,
                    trailsPaintId: 0,
                    goalExplosionPaintId: 0,
                }
            }
        }

        pub struct LoadoutPaintBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> LoadoutPaintBuilder<'a, 'b> {
            #[inline]
            pub fn add_carPaintId(&mut self, carPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_CARPAINTID, carPaintId, 0);
            }
            #[inline]
            pub fn add_decalPaintId(&mut self, decalPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_DECALPAINTID, decalPaintId, 0);
            }
            #[inline]
            pub fn add_wheelsPaintId(&mut self, wheelsPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_WHEELSPAINTID, wheelsPaintId, 0);
            }
            #[inline]
            pub fn add_boostPaintId(&mut self, boostPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_BOOSTPAINTID, boostPaintId, 0);
            }
            #[inline]
            pub fn add_antennaPaintId(&mut self, antennaPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_ANTENNAPAINTID, antennaPaintId, 0);
            }
            #[inline]
            pub fn add_hatPaintId(&mut self, hatPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_HATPAINTID, hatPaintId, 0);
            }
            #[inline]
            pub fn add_trailsPaintId(&mut self, trailsPaintId: i32) {
                self.fbb_
                    .push_slot::<i32>(LoadoutPaint::VT_TRAILSPAINTID, trailsPaintId, 0);
            }
            #[inline]
            pub fn add_goalExplosionPaintId(&mut self, goalExplosionPaintId: i32) {
                self.fbb_.push_slot::<i32>(
                    LoadoutPaint::VT_GOALEXPLOSIONPAINTID,
                    goalExplosionPaintId,
                    0,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> LoadoutPaintBuilder<'a, 'b> {
                let start = _fbb.start_table();
                LoadoutPaintBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<LoadoutPaint<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for LoadoutPaint<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("LoadoutPaint");
                ds.field("carPaintId", &self.carPaintId());
                ds.field("decalPaintId", &self.decalPaintId());
                ds.field("wheelsPaintId", &self.wheelsPaintId());
                ds.field("boostPaintId", &self.boostPaintId());
                ds.field("antennaPaintId", &self.antennaPaintId());
                ds.field("hatPaintId", &self.hatPaintId());
                ds.field("trailsPaintId", &self.trailsPaintId());
                ds.field("goalExplosionPaintId", &self.goalExplosionPaintId());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct LoadoutPaintObject {
            pub carPaintId: i32,
            pub decalPaintId: i32,
            pub wheelsPaintId: i32,
            pub boostPaintId: i32,
            pub antennaPaintId: i32,
            pub hatPaintId: i32,
            pub trailsPaintId: i32,
            pub goalExplosionPaintId: i32,
        }
        impl Default for LoadoutPaintObject {
            fn default() -> Self {
                Self {
                    carPaintId: 0,
                    decalPaintId: 0,
                    wheelsPaintId: 0,
                    boostPaintId: 0,
                    antennaPaintId: 0,
                    hatPaintId: 0,
                    trailsPaintId: 0,
                    goalExplosionPaintId: 0,
                }
            }
        }
        impl LoadoutPaintObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<LoadoutPaint<'b>> {
                let carPaintId = self.carPaintId;
                let decalPaintId = self.decalPaintId;
                let wheelsPaintId = self.wheelsPaintId;
                let boostPaintId = self.boostPaintId;
                let antennaPaintId = self.antennaPaintId;
                let hatPaintId = self.hatPaintId;
                let trailsPaintId = self.trailsPaintId;
                let goalExplosionPaintId = self.goalExplosionPaintId;
                LoadoutPaint::create(
                    _fbb,
                    &LoadoutPaintArgs {
                        carPaintId,
                        decalPaintId,
                        wheelsPaintId,
                        boostPaintId,
                        antennaPaintId,
                        hatPaintId,
                        trailsPaintId,
                        goalExplosionPaintId,
                    },
                )
            }
        }
        pub enum PlayerConfigurationOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct PlayerConfiguration<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerConfiguration<'a> {
            type Inner = PlayerConfiguration<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerConfiguration<'a> {
            pub const VT_VARIETY_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_VARIETY: flatbuffers::VOffsetT = 6;
            pub const VT_NAME: flatbuffers::VOffsetT = 8;
            pub const VT_TEAM: flatbuffers::VOffsetT = 10;
            pub const VT_LOADOUT: flatbuffers::VOffsetT = 12;
            pub const VT_SPAWNID: flatbuffers::VOffsetT = 14;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerConfiguration { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerConfigurationArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerConfiguration<'bldr>> {
                let mut builder = PlayerConfigurationBuilder::new(_fbb);
                builder.add_spawnId(args.spawnId);
                if let Some(x) = args.loadout {
                    builder.add_loadout(x);
                }
                builder.add_team(args.team);
                if let Some(x) = args.name {
                    builder.add_name(x);
                }
                if let Some(x) = args.variety {
                    builder.add_variety(x);
                }
                builder.add_variety_type(args.variety_type);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerConfigurationObject {
                let variety = match self.variety_type() {
      PlayerClass::NONE => PlayerClassObject::NONE,
      PlayerClass::RLBotPlayer => PlayerClassObject::RLBotPlayer(Box::new(
        self.variety_as_rlbot_player()
            .expect("Invalid union table, expected `PlayerClass::RLBotPlayer`.")
            .unpack()
      )),
      PlayerClass::HumanPlayer => PlayerClassObject::HumanPlayer(Box::new(
        self.variety_as_human_player()
            .expect("Invalid union table, expected `PlayerClass::HumanPlayer`.")
            .unpack()
      )),
      PlayerClass::PsyonixBotPlayer => PlayerClassObject::PsyonixBotPlayer(Box::new(
        self.variety_as_psyonix_bot_player()
            .expect("Invalid union table, expected `PlayerClass::PsyonixBotPlayer`.")
            .unpack()
      )),
      PlayerClass::PartyMemberBotPlayer => PlayerClassObject::PartyMemberBotPlayer(Box::new(
        self.variety_as_party_member_bot_player()
            .expect("Invalid union table, expected `PlayerClass::PartyMemberBotPlayer`.")
            .unpack()
      )),
      _ => PlayerClassObject::NONE,
    };
                let name = self.name().map(|x| x.to_string());
                let team = self.team();
                let loadout = self.loadout().map(|x| Box::new(x.unpack()));
                let spawnId = self.spawnId();
                PlayerConfigurationObject {
                    variety,
                    name,
                    team,
                    loadout,
                    spawnId,
                }
            }

            #[inline]
            pub fn variety_type(&self) -> PlayerClass {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<PlayerClass>(
                            PlayerConfiguration::VT_VARIETY_TYPE,
                            Some(PlayerClass::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn variety(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            PlayerConfiguration::VT_VARIETY,
                            None,
                        )
                }
            }
            #[inline]
            pub fn name(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        PlayerConfiguration::VT_NAME,
                        None,
                    )
                }
            }
            #[inline]
            pub fn team(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerConfiguration::VT_TEAM, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn loadout(&self) -> Option<PlayerLoadout<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<PlayerLoadout>>(
                            PlayerConfiguration::VT_LOADOUT,
                            None,
                        )
                }
            }
            /// In the case where the requested player index is not available, spawnId will help
            /// the framework figure out what index was actually assigned to this player instead.
            #[inline]
            pub fn spawnId(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerConfiguration::VT_SPAWNID, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_rlbot_player(&self) -> Option<RLBotPlayer<'a>> {
                if self.variety_type() == PlayerClass::RLBotPlayer {
                    self.variety().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { RLBotPlayer::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_human_player(&self) -> Option<HumanPlayer<'a>> {
                if self.variety_type() == PlayerClass::HumanPlayer {
                    self.variety().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { HumanPlayer::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_psyonix_bot_player(&self) -> Option<PsyonixBotPlayer<'a>> {
                if self.variety_type() == PlayerClass::PsyonixBotPlayer {
                    self.variety().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PsyonixBotPlayer::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn variety_as_party_member_bot_player(&self) -> Option<PartyMemberBotPlayer<'a>> {
                if self.variety_type() == PlayerClass::PartyMemberBotPlayer {
                    self.variety().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PartyMemberBotPlayer::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerConfiguration<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<PlayerClass, _>("variety_type", Self::VT_VARIETY_TYPE, "variety", Self::VT_VARIETY, false, |key, v, pos| {
        match key {
          PlayerClass::RLBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RLBotPlayer>>("PlayerClass::RLBotPlayer", pos),
          PlayerClass::HumanPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HumanPlayer>>("PlayerClass::HumanPlayer", pos),
          PlayerClass::PsyonixBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PsyonixBotPlayer>>("PlayerClass::PsyonixBotPlayer", pos),
          PlayerClass::PartyMemberBotPlayer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PartyMemberBotPlayer>>("PlayerClass::PartyMemberBotPlayer", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<i32>("team", Self::VT_TEAM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PlayerLoadout>>("loadout", Self::VT_LOADOUT, false)?
     .visit_field::<i32>("spawnId", Self::VT_SPAWNID, false)?
     .finish();
                Ok(())
            }
        }
        pub struct PlayerConfigurationArgs<'a> {
            pub variety_type: PlayerClass,
            pub variety: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
            pub name: Option<flatbuffers::WIPOffset<&'a str>>,
            pub team: i32,
            pub loadout: Option<flatbuffers::WIPOffset<PlayerLoadout<'a>>>,
            pub spawnId: i32,
        }
        impl<'a> Default for PlayerConfigurationArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerConfigurationArgs {
                    variety_type: PlayerClass::NONE,
                    variety: None,
                    name: None,
                    team: 0,
                    loadout: None,
                    spawnId: 0,
                }
            }
        }

        pub struct PlayerConfigurationBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerConfigurationBuilder<'a, 'b> {
            #[inline]
            pub fn add_variety_type(&mut self, variety_type: PlayerClass) {
                self.fbb_.push_slot::<PlayerClass>(
                    PlayerConfiguration::VT_VARIETY_TYPE,
                    variety_type,
                    PlayerClass::NONE,
                );
            }
            #[inline]
            pub fn add_variety(
                &mut self,
                variety: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PlayerConfiguration::VT_VARIETY,
                    variety,
                );
            }
            #[inline]
            pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PlayerConfiguration::VT_NAME,
                    name,
                );
            }
            #[inline]
            pub fn add_team(&mut self, team: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerConfiguration::VT_TEAM, team, 0);
            }
            #[inline]
            pub fn add_loadout(&mut self, loadout: flatbuffers::WIPOffset<PlayerLoadout<'b>>) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<PlayerLoadout>>(
                        PlayerConfiguration::VT_LOADOUT,
                        loadout,
                    );
            }
            #[inline]
            pub fn add_spawnId(&mut self, spawnId: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerConfiguration::VT_SPAWNID, spawnId, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerConfigurationBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerConfigurationBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerConfiguration<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerConfiguration<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerConfiguration");
                ds.field("variety_type", &self.variety_type());
                match self.variety_type() {
                    PlayerClass::RLBotPlayer => {
                        if let Some(x) = self.variety_as_rlbot_player() {
                            ds.field("variety", &x)
                        } else {
                            ds.field(
                                "variety",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    PlayerClass::HumanPlayer => {
                        if let Some(x) = self.variety_as_human_player() {
                            ds.field("variety", &x)
                        } else {
                            ds.field(
                                "variety",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    PlayerClass::PsyonixBotPlayer => {
                        if let Some(x) = self.variety_as_psyonix_bot_player() {
                            ds.field("variety", &x)
                        } else {
                            ds.field(
                                "variety",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    PlayerClass::PartyMemberBotPlayer => {
                        if let Some(x) = self.variety_as_party_member_bot_player() {
                            ds.field("variety", &x)
                        } else {
                            ds.field(
                                "variety",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("variety", &x)
                    }
                };
                ds.field("name", &self.name());
                ds.field("team", &self.team());
                ds.field("loadout", &self.loadout());
                ds.field("spawnId", &self.spawnId());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerConfigurationObject {
            pub variety: PlayerClassObject,
            pub name: Option<String>,
            pub team: i32,
            pub loadout: Option<Box<PlayerLoadoutObject>>,
            pub spawnId: i32,
        }
        impl Default for PlayerConfigurationObject {
            fn default() -> Self {
                Self {
                    variety: PlayerClassObject::NONE,
                    name: None,
                    team: 0,
                    loadout: None,
                    spawnId: 0,
                }
            }
        }
        impl PlayerConfigurationObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerConfiguration<'b>> {
                let variety_type = self.variety.player_class_type();
                let variety = self.variety.pack(_fbb);
                let name = self.name.as_ref().map(|x| _fbb.create_string(x));
                let team = self.team;
                let loadout = self.loadout.as_ref().map(|x| x.pack(_fbb));
                let spawnId = self.spawnId;
                PlayerConfiguration::create(
                    _fbb,
                    &PlayerConfigurationArgs {
                        variety_type,
                        variety,
                        name,
                        team,
                        loadout,
                        spawnId,
                    },
                )
            }
        }
        pub enum MutatorSettingsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MutatorSettings<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MutatorSettings<'a> {
            type Inner = MutatorSettings<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MutatorSettings<'a> {
            pub const VT_MATCHLENGTH: flatbuffers::VOffsetT = 4;
            pub const VT_MAXSCORE: flatbuffers::VOffsetT = 6;
            pub const VT_OVERTIMEOPTION: flatbuffers::VOffsetT = 8;
            pub const VT_SERIESLENGTHOPTION: flatbuffers::VOffsetT = 10;
            pub const VT_GAMESPEEDOPTION: flatbuffers::VOffsetT = 12;
            pub const VT_BALLMAXSPEEDOPTION: flatbuffers::VOffsetT = 14;
            pub const VT_BALLTYPEOPTION: flatbuffers::VOffsetT = 16;
            pub const VT_BALLWEIGHTOPTION: flatbuffers::VOffsetT = 18;
            pub const VT_BALLSIZEOPTION: flatbuffers::VOffsetT = 20;
            pub const VT_BALLBOUNCINESSOPTION: flatbuffers::VOffsetT = 22;
            pub const VT_BOOSTOPTION: flatbuffers::VOffsetT = 24;
            pub const VT_RUMBLEOPTION: flatbuffers::VOffsetT = 26;
            pub const VT_BOOSTSTRENGTHOPTION: flatbuffers::VOffsetT = 28;
            pub const VT_GRAVITYOPTION: flatbuffers::VOffsetT = 30;
            pub const VT_DEMOLISHOPTION: flatbuffers::VOffsetT = 32;
            pub const VT_RESPAWNTIMEOPTION: flatbuffers::VOffsetT = 34;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MutatorSettings { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MutatorSettingsArgs,
            ) -> flatbuffers::WIPOffset<MutatorSettings<'bldr>> {
                let mut builder = MutatorSettingsBuilder::new(_fbb);
                builder.add_respawnTimeOption(args.respawnTimeOption);
                builder.add_demolishOption(args.demolishOption);
                builder.add_gravityOption(args.gravityOption);
                builder.add_boostStrengthOption(args.boostStrengthOption);
                builder.add_rumbleOption(args.rumbleOption);
                builder.add_boostOption(args.boostOption);
                builder.add_ballBouncinessOption(args.ballBouncinessOption);
                builder.add_ballSizeOption(args.ballSizeOption);
                builder.add_ballWeightOption(args.ballWeightOption);
                builder.add_ballTypeOption(args.ballTypeOption);
                builder.add_ballMaxSpeedOption(args.ballMaxSpeedOption);
                builder.add_gameSpeedOption(args.gameSpeedOption);
                builder.add_seriesLengthOption(args.seriesLengthOption);
                builder.add_overtimeOption(args.overtimeOption);
                builder.add_maxScore(args.maxScore);
                builder.add_matchLength(args.matchLength);
                builder.finish()
            }

            pub fn unpack(&self) -> MutatorSettingsObject {
                let matchLength = self.matchLength();
                let maxScore = self.maxScore();
                let overtimeOption = self.overtimeOption();
                let seriesLengthOption = self.seriesLengthOption();
                let gameSpeedOption = self.gameSpeedOption();
                let ballMaxSpeedOption = self.ballMaxSpeedOption();
                let ballTypeOption = self.ballTypeOption();
                let ballWeightOption = self.ballWeightOption();
                let ballSizeOption = self.ballSizeOption();
                let ballBouncinessOption = self.ballBouncinessOption();
                let boostOption = self.boostOption();
                let rumbleOption = self.rumbleOption();
                let boostStrengthOption = self.boostStrengthOption();
                let gravityOption = self.gravityOption();
                let demolishOption = self.demolishOption();
                let respawnTimeOption = self.respawnTimeOption();
                MutatorSettingsObject {
                    matchLength,
                    maxScore,
                    overtimeOption,
                    seriesLengthOption,
                    gameSpeedOption,
                    ballMaxSpeedOption,
                    ballTypeOption,
                    ballWeightOption,
                    ballSizeOption,
                    ballBouncinessOption,
                    boostOption,
                    rumbleOption,
                    boostStrengthOption,
                    gravityOption,
                    demolishOption,
                    respawnTimeOption,
                }
            }

            #[inline]
            pub fn matchLength(&self) -> MatchLength {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<MatchLength>(
                            MutatorSettings::VT_MATCHLENGTH,
                            Some(MatchLength::Five_Minutes),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn maxScore(&self) -> MaxScore {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<MaxScore>(MutatorSettings::VT_MAXSCORE, Some(MaxScore::Unlimited))
                        .unwrap()
                }
            }
            #[inline]
            pub fn overtimeOption(&self) -> OvertimeOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<OvertimeOption>(
                            MutatorSettings::VT_OVERTIMEOPTION,
                            Some(OvertimeOption::Unlimited),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn seriesLengthOption(&self) -> SeriesLengthOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<SeriesLengthOption>(
                            MutatorSettings::VT_SERIESLENGTHOPTION,
                            Some(SeriesLengthOption::Unlimited),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn gameSpeedOption(&self) -> GameSpeedOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GameSpeedOption>(
                            MutatorSettings::VT_GAMESPEEDOPTION,
                            Some(GameSpeedOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ballMaxSpeedOption(&self) -> BallMaxSpeedOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BallMaxSpeedOption>(
                            MutatorSettings::VT_BALLMAXSPEEDOPTION,
                            Some(BallMaxSpeedOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ballTypeOption(&self) -> BallTypeOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BallTypeOption>(
                            MutatorSettings::VT_BALLTYPEOPTION,
                            Some(BallTypeOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ballWeightOption(&self) -> BallWeightOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BallWeightOption>(
                            MutatorSettings::VT_BALLWEIGHTOPTION,
                            Some(BallWeightOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ballSizeOption(&self) -> BallSizeOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BallSizeOption>(
                            MutatorSettings::VT_BALLSIZEOPTION,
                            Some(BallSizeOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn ballBouncinessOption(&self) -> BallBouncinessOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BallBouncinessOption>(
                            MutatorSettings::VT_BALLBOUNCINESSOPTION,
                            Some(BallBouncinessOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn boostOption(&self) -> BoostOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BoostOption>(
                            MutatorSettings::VT_BOOSTOPTION,
                            Some(BoostOption::Normal_Boost),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn rumbleOption(&self) -> RumbleOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<RumbleOption>(
                            MutatorSettings::VT_RUMBLEOPTION,
                            Some(RumbleOption::No_Rumble),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn boostStrengthOption(&self) -> BoostStrengthOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<BoostStrengthOption>(
                            MutatorSettings::VT_BOOSTSTRENGTHOPTION,
                            Some(BoostStrengthOption::One),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn gravityOption(&self) -> GravityOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GravityOption>(
                            MutatorSettings::VT_GRAVITYOPTION,
                            Some(GravityOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn demolishOption(&self) -> DemolishOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<DemolishOption>(
                            MutatorSettings::VT_DEMOLISHOPTION,
                            Some(DemolishOption::Default),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn respawnTimeOption(&self) -> RespawnTimeOption {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<RespawnTimeOption>(
                            MutatorSettings::VT_RESPAWNTIMEOPTION,
                            Some(RespawnTimeOption::Three_Seconds),
                        )
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for MutatorSettings<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<MatchLength>("matchLength", Self::VT_MATCHLENGTH, false)?
                    .visit_field::<MaxScore>("maxScore", Self::VT_MAXSCORE, false)?
                    .visit_field::<OvertimeOption>(
                        "overtimeOption",
                        Self::VT_OVERTIMEOPTION,
                        false,
                    )?
                    .visit_field::<SeriesLengthOption>(
                        "seriesLengthOption",
                        Self::VT_SERIESLENGTHOPTION,
                        false,
                    )?
                    .visit_field::<GameSpeedOption>(
                        "gameSpeedOption",
                        Self::VT_GAMESPEEDOPTION,
                        false,
                    )?
                    .visit_field::<BallMaxSpeedOption>(
                        "ballMaxSpeedOption",
                        Self::VT_BALLMAXSPEEDOPTION,
                        false,
                    )?
                    .visit_field::<BallTypeOption>(
                        "ballTypeOption",
                        Self::VT_BALLTYPEOPTION,
                        false,
                    )?
                    .visit_field::<BallWeightOption>(
                        "ballWeightOption",
                        Self::VT_BALLWEIGHTOPTION,
                        false,
                    )?
                    .visit_field::<BallSizeOption>(
                        "ballSizeOption",
                        Self::VT_BALLSIZEOPTION,
                        false,
                    )?
                    .visit_field::<BallBouncinessOption>(
                        "ballBouncinessOption",
                        Self::VT_BALLBOUNCINESSOPTION,
                        false,
                    )?
                    .visit_field::<BoostOption>("boostOption", Self::VT_BOOSTOPTION, false)?
                    .visit_field::<RumbleOption>("rumbleOption", Self::VT_RUMBLEOPTION, false)?
                    .visit_field::<BoostStrengthOption>(
                        "boostStrengthOption",
                        Self::VT_BOOSTSTRENGTHOPTION,
                        false,
                    )?
                    .visit_field::<GravityOption>("gravityOption", Self::VT_GRAVITYOPTION, false)?
                    .visit_field::<DemolishOption>(
                        "demolishOption",
                        Self::VT_DEMOLISHOPTION,
                        false,
                    )?
                    .visit_field::<RespawnTimeOption>(
                        "respawnTimeOption",
                        Self::VT_RESPAWNTIMEOPTION,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MutatorSettingsArgs {
            pub matchLength: MatchLength,
            pub maxScore: MaxScore,
            pub overtimeOption: OvertimeOption,
            pub seriesLengthOption: SeriesLengthOption,
            pub gameSpeedOption: GameSpeedOption,
            pub ballMaxSpeedOption: BallMaxSpeedOption,
            pub ballTypeOption: BallTypeOption,
            pub ballWeightOption: BallWeightOption,
            pub ballSizeOption: BallSizeOption,
            pub ballBouncinessOption: BallBouncinessOption,
            pub boostOption: BoostOption,
            pub rumbleOption: RumbleOption,
            pub boostStrengthOption: BoostStrengthOption,
            pub gravityOption: GravityOption,
            pub demolishOption: DemolishOption,
            pub respawnTimeOption: RespawnTimeOption,
        }
        impl<'a> Default for MutatorSettingsArgs {
            #[inline]
            fn default() -> Self {
                MutatorSettingsArgs {
                    matchLength: MatchLength::Five_Minutes,
                    maxScore: MaxScore::Unlimited,
                    overtimeOption: OvertimeOption::Unlimited,
                    seriesLengthOption: SeriesLengthOption::Unlimited,
                    gameSpeedOption: GameSpeedOption::Default,
                    ballMaxSpeedOption: BallMaxSpeedOption::Default,
                    ballTypeOption: BallTypeOption::Default,
                    ballWeightOption: BallWeightOption::Default,
                    ballSizeOption: BallSizeOption::Default,
                    ballBouncinessOption: BallBouncinessOption::Default,
                    boostOption: BoostOption::Normal_Boost,
                    rumbleOption: RumbleOption::No_Rumble,
                    boostStrengthOption: BoostStrengthOption::One,
                    gravityOption: GravityOption::Default,
                    demolishOption: DemolishOption::Default,
                    respawnTimeOption: RespawnTimeOption::Three_Seconds,
                }
            }
        }

        pub struct MutatorSettingsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MutatorSettingsBuilder<'a, 'b> {
            #[inline]
            pub fn add_matchLength(&mut self, matchLength: MatchLength) {
                self.fbb_.push_slot::<MatchLength>(
                    MutatorSettings::VT_MATCHLENGTH,
                    matchLength,
                    MatchLength::Five_Minutes,
                );
            }
            #[inline]
            pub fn add_maxScore(&mut self, maxScore: MaxScore) {
                self.fbb_.push_slot::<MaxScore>(
                    MutatorSettings::VT_MAXSCORE,
                    maxScore,
                    MaxScore::Unlimited,
                );
            }
            #[inline]
            pub fn add_overtimeOption(&mut self, overtimeOption: OvertimeOption) {
                self.fbb_.push_slot::<OvertimeOption>(
                    MutatorSettings::VT_OVERTIMEOPTION,
                    overtimeOption,
                    OvertimeOption::Unlimited,
                );
            }
            #[inline]
            pub fn add_seriesLengthOption(&mut self, seriesLengthOption: SeriesLengthOption) {
                self.fbb_.push_slot::<SeriesLengthOption>(
                    MutatorSettings::VT_SERIESLENGTHOPTION,
                    seriesLengthOption,
                    SeriesLengthOption::Unlimited,
                );
            }
            #[inline]
            pub fn add_gameSpeedOption(&mut self, gameSpeedOption: GameSpeedOption) {
                self.fbb_.push_slot::<GameSpeedOption>(
                    MutatorSettings::VT_GAMESPEEDOPTION,
                    gameSpeedOption,
                    GameSpeedOption::Default,
                );
            }
            #[inline]
            pub fn add_ballMaxSpeedOption(&mut self, ballMaxSpeedOption: BallMaxSpeedOption) {
                self.fbb_.push_slot::<BallMaxSpeedOption>(
                    MutatorSettings::VT_BALLMAXSPEEDOPTION,
                    ballMaxSpeedOption,
                    BallMaxSpeedOption::Default,
                );
            }
            #[inline]
            pub fn add_ballTypeOption(&mut self, ballTypeOption: BallTypeOption) {
                self.fbb_.push_slot::<BallTypeOption>(
                    MutatorSettings::VT_BALLTYPEOPTION,
                    ballTypeOption,
                    BallTypeOption::Default,
                );
            }
            #[inline]
            pub fn add_ballWeightOption(&mut self, ballWeightOption: BallWeightOption) {
                self.fbb_.push_slot::<BallWeightOption>(
                    MutatorSettings::VT_BALLWEIGHTOPTION,
                    ballWeightOption,
                    BallWeightOption::Default,
                );
            }
            #[inline]
            pub fn add_ballSizeOption(&mut self, ballSizeOption: BallSizeOption) {
                self.fbb_.push_slot::<BallSizeOption>(
                    MutatorSettings::VT_BALLSIZEOPTION,
                    ballSizeOption,
                    BallSizeOption::Default,
                );
            }
            #[inline]
            pub fn add_ballBouncinessOption(&mut self, ballBouncinessOption: BallBouncinessOption) {
                self.fbb_.push_slot::<BallBouncinessOption>(
                    MutatorSettings::VT_BALLBOUNCINESSOPTION,
                    ballBouncinessOption,
                    BallBouncinessOption::Default,
                );
            }
            #[inline]
            pub fn add_boostOption(&mut self, boostOption: BoostOption) {
                self.fbb_.push_slot::<BoostOption>(
                    MutatorSettings::VT_BOOSTOPTION,
                    boostOption,
                    BoostOption::Normal_Boost,
                );
            }
            #[inline]
            pub fn add_rumbleOption(&mut self, rumbleOption: RumbleOption) {
                self.fbb_.push_slot::<RumbleOption>(
                    MutatorSettings::VT_RUMBLEOPTION,
                    rumbleOption,
                    RumbleOption::No_Rumble,
                );
            }
            #[inline]
            pub fn add_boostStrengthOption(&mut self, boostStrengthOption: BoostStrengthOption) {
                self.fbb_.push_slot::<BoostStrengthOption>(
                    MutatorSettings::VT_BOOSTSTRENGTHOPTION,
                    boostStrengthOption,
                    BoostStrengthOption::One,
                );
            }
            #[inline]
            pub fn add_gravityOption(&mut self, gravityOption: GravityOption) {
                self.fbb_.push_slot::<GravityOption>(
                    MutatorSettings::VT_GRAVITYOPTION,
                    gravityOption,
                    GravityOption::Default,
                );
            }
            #[inline]
            pub fn add_demolishOption(&mut self, demolishOption: DemolishOption) {
                self.fbb_.push_slot::<DemolishOption>(
                    MutatorSettings::VT_DEMOLISHOPTION,
                    demolishOption,
                    DemolishOption::Default,
                );
            }
            #[inline]
            pub fn add_respawnTimeOption(&mut self, respawnTimeOption: RespawnTimeOption) {
                self.fbb_.push_slot::<RespawnTimeOption>(
                    MutatorSettings::VT_RESPAWNTIMEOPTION,
                    respawnTimeOption,
                    RespawnTimeOption::Three_Seconds,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MutatorSettingsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MutatorSettingsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MutatorSettings<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MutatorSettings<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MutatorSettings");
                ds.field("matchLength", &self.matchLength());
                ds.field("maxScore", &self.maxScore());
                ds.field("overtimeOption", &self.overtimeOption());
                ds.field("seriesLengthOption", &self.seriesLengthOption());
                ds.field("gameSpeedOption", &self.gameSpeedOption());
                ds.field("ballMaxSpeedOption", &self.ballMaxSpeedOption());
                ds.field("ballTypeOption", &self.ballTypeOption());
                ds.field("ballWeightOption", &self.ballWeightOption());
                ds.field("ballSizeOption", &self.ballSizeOption());
                ds.field("ballBouncinessOption", &self.ballBouncinessOption());
                ds.field("boostOption", &self.boostOption());
                ds.field("rumbleOption", &self.rumbleOption());
                ds.field("boostStrengthOption", &self.boostStrengthOption());
                ds.field("gravityOption", &self.gravityOption());
                ds.field("demolishOption", &self.demolishOption());
                ds.field("respawnTimeOption", &self.respawnTimeOption());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct MutatorSettingsObject {
            pub matchLength: MatchLength,
            pub maxScore: MaxScore,
            pub overtimeOption: OvertimeOption,
            pub seriesLengthOption: SeriesLengthOption,
            pub gameSpeedOption: GameSpeedOption,
            pub ballMaxSpeedOption: BallMaxSpeedOption,
            pub ballTypeOption: BallTypeOption,
            pub ballWeightOption: BallWeightOption,
            pub ballSizeOption: BallSizeOption,
            pub ballBouncinessOption: BallBouncinessOption,
            pub boostOption: BoostOption,
            pub rumbleOption: RumbleOption,
            pub boostStrengthOption: BoostStrengthOption,
            pub gravityOption: GravityOption,
            pub demolishOption: DemolishOption,
            pub respawnTimeOption: RespawnTimeOption,
        }
        impl Default for MutatorSettingsObject {
            fn default() -> Self {
                Self {
                    matchLength: MatchLength::Five_Minutes,
                    maxScore: MaxScore::Unlimited,
                    overtimeOption: OvertimeOption::Unlimited,
                    seriesLengthOption: SeriesLengthOption::Unlimited,
                    gameSpeedOption: GameSpeedOption::Default,
                    ballMaxSpeedOption: BallMaxSpeedOption::Default,
                    ballTypeOption: BallTypeOption::Default,
                    ballWeightOption: BallWeightOption::Default,
                    ballSizeOption: BallSizeOption::Default,
                    ballBouncinessOption: BallBouncinessOption::Default,
                    boostOption: BoostOption::Normal_Boost,
                    rumbleOption: RumbleOption::No_Rumble,
                    boostStrengthOption: BoostStrengthOption::One,
                    gravityOption: GravityOption::Default,
                    demolishOption: DemolishOption::Default,
                    respawnTimeOption: RespawnTimeOption::Three_Seconds,
                }
            }
        }
        impl MutatorSettingsObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MutatorSettings<'b>> {
                let matchLength = self.matchLength;
                let maxScore = self.maxScore;
                let overtimeOption = self.overtimeOption;
                let seriesLengthOption = self.seriesLengthOption;
                let gameSpeedOption = self.gameSpeedOption;
                let ballMaxSpeedOption = self.ballMaxSpeedOption;
                let ballTypeOption = self.ballTypeOption;
                let ballWeightOption = self.ballWeightOption;
                let ballSizeOption = self.ballSizeOption;
                let ballBouncinessOption = self.ballBouncinessOption;
                let boostOption = self.boostOption;
                let rumbleOption = self.rumbleOption;
                let boostStrengthOption = self.boostStrengthOption;
                let gravityOption = self.gravityOption;
                let demolishOption = self.demolishOption;
                let respawnTimeOption = self.respawnTimeOption;
                MutatorSettings::create(
                    _fbb,
                    &MutatorSettingsArgs {
                        matchLength,
                        maxScore,
                        overtimeOption,
                        seriesLengthOption,
                        gameSpeedOption,
                        ballMaxSpeedOption,
                        ballTypeOption,
                        ballWeightOption,
                        ballSizeOption,
                        ballBouncinessOption,
                        boostOption,
                        rumbleOption,
                        boostStrengthOption,
                        gravityOption,
                        demolishOption,
                        respawnTimeOption,
                    },
                )
            }
        }
        pub enum MatchSettingsOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct MatchSettings<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MatchSettings<'a> {
            type Inner = MatchSettings<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MatchSettings<'a> {
            pub const VT_PLAYERCONFIGURATIONS: flatbuffers::VOffsetT = 4;
            pub const VT_GAMEMODE: flatbuffers::VOffsetT = 6;
            pub const VT_GAMEMAP: flatbuffers::VOffsetT = 8;
            pub const VT_SKIPREPLAYS: flatbuffers::VOffsetT = 10;
            pub const VT_INSTANTSTART: flatbuffers::VOffsetT = 12;
            pub const VT_MUTATORSETTINGS: flatbuffers::VOffsetT = 14;
            pub const VT_EXISTINGMATCHBEHAVIOR: flatbuffers::VOffsetT = 16;
            pub const VT_ENABLELOCKSTEP: flatbuffers::VOffsetT = 18;
            pub const VT_ENABLERENDERING: flatbuffers::VOffsetT = 20;
            pub const VT_ENABLESTATESETTING: flatbuffers::VOffsetT = 22;
            pub const VT_AUTOSAVEREPLAY: flatbuffers::VOffsetT = 24;
            pub const VT_GAMEMAPUPK: flatbuffers::VOffsetT = 26;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MatchSettings { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MatchSettingsArgs<'args>,
            ) -> flatbuffers::WIPOffset<MatchSettings<'bldr>> {
                let mut builder = MatchSettingsBuilder::new(_fbb);
                if let Some(x) = args.gameMapUpk {
                    builder.add_gameMapUpk(x);
                }
                if let Some(x) = args.mutatorSettings {
                    builder.add_mutatorSettings(x);
                }
                if let Some(x) = args.playerConfigurations {
                    builder.add_playerConfigurations(x);
                }
                builder.add_autoSaveReplay(args.autoSaveReplay);
                builder.add_enableStateSetting(args.enableStateSetting);
                builder.add_enableRendering(args.enableRendering);
                builder.add_enableLockstep(args.enableLockstep);
                builder.add_existingMatchBehavior(args.existingMatchBehavior);
                builder.add_instantStart(args.instantStart);
                builder.add_skipReplays(args.skipReplays);
                builder.add_gameMap(args.gameMap);
                builder.add_gameMode(args.gameMode);
                builder.finish()
            }

            pub fn unpack(&self) -> MatchSettingsObject {
                let playerConfigurations = self
                    .playerConfigurations()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let gameMode = self.gameMode();
                let gameMap = self.gameMap();
                let skipReplays = self.skipReplays();
                let instantStart = self.instantStart();
                let mutatorSettings = self.mutatorSettings().map(|x| Box::new(x.unpack()));
                let existingMatchBehavior = self.existingMatchBehavior();
                let enableLockstep = self.enableLockstep();
                let enableRendering = self.enableRendering();
                let enableStateSetting = self.enableStateSetting();
                let autoSaveReplay = self.autoSaveReplay();
                let gameMapUpk = self.gameMapUpk().map(|x| x.to_string());
                MatchSettingsObject {
                    playerConfigurations,
                    gameMode,
                    gameMap,
                    skipReplays,
                    instantStart,
                    mutatorSettings,
                    existingMatchBehavior,
                    enableLockstep,
                    enableRendering,
                    enableStateSetting,
                    autoSaveReplay,
                    gameMapUpk,
                }
            }

            #[inline]
            pub fn playerConfigurations(
                &self,
            ) -> Option<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>,
            > {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration>>,
                    >>(MatchSettings::VT_PLAYERCONFIGURATIONS, None)
                }
            }
            #[inline]
            pub fn gameMode(&self) -> GameMode {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GameMode>(MatchSettings::VT_GAMEMODE, Some(GameMode::Soccer))
                        .unwrap()
                }
            }
            #[inline]
            pub fn gameMap(&self) -> GameMap {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GameMap>(MatchSettings::VT_GAMEMAP, Some(GameMap::DFHStadium))
                        .unwrap()
                }
            }
            #[inline]
            pub fn skipReplays(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_SKIPREPLAYS, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn instantStart(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_INSTANTSTART, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn mutatorSettings(&self) -> Option<MutatorSettings<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<MutatorSettings>>(
                            MatchSettings::VT_MUTATORSETTINGS,
                            None,
                        )
                }
            }
            #[inline]
            pub fn existingMatchBehavior(&self) -> ExistingMatchBehavior {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<ExistingMatchBehavior>(
                            MatchSettings::VT_EXISTINGMATCHBEHAVIOR,
                            Some(ExistingMatchBehavior::Restart_If_Different),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn enableLockstep(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_ENABLELOCKSTEP, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn enableRendering(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_ENABLERENDERING, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn enableStateSetting(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_ENABLESTATESETTING, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn autoSaveReplay(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(MatchSettings::VT_AUTOSAVEREPLAY, Some(false))
                        .unwrap()
                }
            }
            /// The name of a upk file, like UtopiaStadium_P, which should be loaded.
            /// If specified, this overrides gameMap. On Steam version of Rocket League,
            /// this can be used to load custom map files, but on Epic version it only
            /// works on the Psyonix maps. Still useful because maintaining the gameMap
            /// enum as new Psyonix maps are added is annoying.
            #[inline]
            pub fn gameMapUpk(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        MatchSettings::VT_GAMEMAPUPK,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for MatchSettings<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerConfiguration>>,
                    >>(
                        "playerConfigurations", Self::VT_PLAYERCONFIGURATIONS, false
                    )?
                    .visit_field::<GameMode>("gameMode", Self::VT_GAMEMODE, false)?
                    .visit_field::<GameMap>("gameMap", Self::VT_GAMEMAP, false)?
                    .visit_field::<bool>("skipReplays", Self::VT_SKIPREPLAYS, false)?
                    .visit_field::<bool>("instantStart", Self::VT_INSTANTSTART, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<MutatorSettings>>(
                        "mutatorSettings",
                        Self::VT_MUTATORSETTINGS,
                        false,
                    )?
                    .visit_field::<ExistingMatchBehavior>(
                        "existingMatchBehavior",
                        Self::VT_EXISTINGMATCHBEHAVIOR,
                        false,
                    )?
                    .visit_field::<bool>("enableLockstep", Self::VT_ENABLELOCKSTEP, false)?
                    .visit_field::<bool>("enableRendering", Self::VT_ENABLERENDERING, false)?
                    .visit_field::<bool>("enableStateSetting", Self::VT_ENABLESTATESETTING, false)?
                    .visit_field::<bool>("autoSaveReplay", Self::VT_AUTOSAVEREPLAY, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "gameMapUpk",
                        Self::VT_GAMEMAPUPK,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct MatchSettingsArgs<'a> {
            pub playerConfigurations: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerConfiguration<'a>>>,
                >,
            >,
            pub gameMode: GameMode,
            pub gameMap: GameMap,
            pub skipReplays: bool,
            pub instantStart: bool,
            pub mutatorSettings: Option<flatbuffers::WIPOffset<MutatorSettings<'a>>>,
            pub existingMatchBehavior: ExistingMatchBehavior,
            pub enableLockstep: bool,
            pub enableRendering: bool,
            pub enableStateSetting: bool,
            pub autoSaveReplay: bool,
            pub gameMapUpk: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for MatchSettingsArgs<'a> {
            #[inline]
            fn default() -> Self {
                MatchSettingsArgs {
                    playerConfigurations: None,
                    gameMode: GameMode::Soccer,
                    gameMap: GameMap::DFHStadium,
                    skipReplays: false,
                    instantStart: false,
                    mutatorSettings: None,
                    existingMatchBehavior: ExistingMatchBehavior::Restart_If_Different,
                    enableLockstep: false,
                    enableRendering: false,
                    enableStateSetting: false,
                    autoSaveReplay: false,
                    gameMapUpk: None,
                }
            }
        }

        pub struct MatchSettingsBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MatchSettingsBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerConfigurations(
                &mut self,
                playerConfigurations: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PlayerConfiguration<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MatchSettings::VT_PLAYERCONFIGURATIONS,
                    playerConfigurations,
                );
            }
            #[inline]
            pub fn add_gameMode(&mut self, gameMode: GameMode) {
                self.fbb_.push_slot::<GameMode>(
                    MatchSettings::VT_GAMEMODE,
                    gameMode,
                    GameMode::Soccer,
                );
            }
            #[inline]
            pub fn add_gameMap(&mut self, gameMap: GameMap) {
                self.fbb_.push_slot::<GameMap>(
                    MatchSettings::VT_GAMEMAP,
                    gameMap,
                    GameMap::DFHStadium,
                );
            }
            #[inline]
            pub fn add_skipReplays(&mut self, skipReplays: bool) {
                self.fbb_
                    .push_slot::<bool>(MatchSettings::VT_SKIPREPLAYS, skipReplays, false);
            }
            #[inline]
            pub fn add_instantStart(&mut self, instantStart: bool) {
                self.fbb_
                    .push_slot::<bool>(MatchSettings::VT_INSTANTSTART, instantStart, false);
            }
            #[inline]
            pub fn add_mutatorSettings(
                &mut self,
                mutatorSettings: flatbuffers::WIPOffset<MutatorSettings<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<MutatorSettings>>(
                        MatchSettings::VT_MUTATORSETTINGS,
                        mutatorSettings,
                    );
            }
            #[inline]
            pub fn add_existingMatchBehavior(
                &mut self,
                existingMatchBehavior: ExistingMatchBehavior,
            ) {
                self.fbb_.push_slot::<ExistingMatchBehavior>(
                    MatchSettings::VT_EXISTINGMATCHBEHAVIOR,
                    existingMatchBehavior,
                    ExistingMatchBehavior::Restart_If_Different,
                );
            }
            #[inline]
            pub fn add_enableLockstep(&mut self, enableLockstep: bool) {
                self.fbb_.push_slot::<bool>(
                    MatchSettings::VT_ENABLELOCKSTEP,
                    enableLockstep,
                    false,
                );
            }
            #[inline]
            pub fn add_enableRendering(&mut self, enableRendering: bool) {
                self.fbb_.push_slot::<bool>(
                    MatchSettings::VT_ENABLERENDERING,
                    enableRendering,
                    false,
                );
            }
            #[inline]
            pub fn add_enableStateSetting(&mut self, enableStateSetting: bool) {
                self.fbb_.push_slot::<bool>(
                    MatchSettings::VT_ENABLESTATESETTING,
                    enableStateSetting,
                    false,
                );
            }
            #[inline]
            pub fn add_autoSaveReplay(&mut self, autoSaveReplay: bool) {
                self.fbb_.push_slot::<bool>(
                    MatchSettings::VT_AUTOSAVEREPLAY,
                    autoSaveReplay,
                    false,
                );
            }
            #[inline]
            pub fn add_gameMapUpk(&mut self, gameMapUpk: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MatchSettings::VT_GAMEMAPUPK,
                    gameMapUpk,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MatchSettingsBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MatchSettingsBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MatchSettings<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MatchSettings<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MatchSettings");
                ds.field("playerConfigurations", &self.playerConfigurations());
                ds.field("gameMode", &self.gameMode());
                ds.field("gameMap", &self.gameMap());
                ds.field("skipReplays", &self.skipReplays());
                ds.field("instantStart", &self.instantStart());
                ds.field("mutatorSettings", &self.mutatorSettings());
                ds.field("existingMatchBehavior", &self.existingMatchBehavior());
                ds.field("enableLockstep", &self.enableLockstep());
                ds.field("enableRendering", &self.enableRendering());
                ds.field("enableStateSetting", &self.enableStateSetting());
                ds.field("autoSaveReplay", &self.autoSaveReplay());
                ds.field("gameMapUpk", &self.gameMapUpk());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct MatchSettingsObject {
            pub playerConfigurations: Option<Vec<PlayerConfigurationObject>>,
            pub gameMode: GameMode,
            pub gameMap: GameMap,
            pub skipReplays: bool,
            pub instantStart: bool,
            pub mutatorSettings: Option<Box<MutatorSettingsObject>>,
            pub existingMatchBehavior: ExistingMatchBehavior,
            pub enableLockstep: bool,
            pub enableRendering: bool,
            pub enableStateSetting: bool,
            pub autoSaveReplay: bool,
            pub gameMapUpk: Option<String>,
        }
        impl Default for MatchSettingsObject {
            fn default() -> Self {
                Self {
                    playerConfigurations: None,
                    gameMode: GameMode::Soccer,
                    gameMap: GameMap::DFHStadium,
                    skipReplays: false,
                    instantStart: false,
                    mutatorSettings: None,
                    existingMatchBehavior: ExistingMatchBehavior::Restart_If_Different,
                    enableLockstep: false,
                    enableRendering: false,
                    enableStateSetting: false,
                    autoSaveReplay: false,
                    gameMapUpk: None,
                }
            }
        }
        impl MatchSettingsObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MatchSettings<'b>> {
                let playerConfigurations = self.playerConfigurations.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let gameMode = self.gameMode;
                let gameMap = self.gameMap;
                let skipReplays = self.skipReplays;
                let instantStart = self.instantStart;
                let mutatorSettings = self.mutatorSettings.as_ref().map(|x| x.pack(_fbb));
                let existingMatchBehavior = self.existingMatchBehavior;
                let enableLockstep = self.enableLockstep;
                let enableRendering = self.enableRendering;
                let enableStateSetting = self.enableStateSetting;
                let autoSaveReplay = self.autoSaveReplay;
                let gameMapUpk = self.gameMapUpk.as_ref().map(|x| _fbb.create_string(x));
                MatchSettings::create(
                    _fbb,
                    &MatchSettingsArgs {
                        playerConfigurations,
                        gameMode,
                        gameMap,
                        skipReplays,
                        instantStart,
                        mutatorSettings,
                        existingMatchBehavior,
                        enableLockstep,
                        enableRendering,
                        enableStateSetting,
                        autoSaveReplay,
                        gameMapUpk,
                    },
                )
            }
        }
        pub enum QuickChatMessagesOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct QuickChatMessages<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for QuickChatMessages<'a> {
            type Inner = QuickChatMessages<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> QuickChatMessages<'a> {
            pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                QuickChatMessages { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args QuickChatMessagesArgs<'args>,
            ) -> flatbuffers::WIPOffset<QuickChatMessages<'bldr>> {
                let mut builder = QuickChatMessagesBuilder::new(_fbb);
                if let Some(x) = args.messages {
                    builder.add_messages(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> QuickChatMessagesObject {
                let messages = self
                    .messages()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                QuickChatMessagesObject { messages }
            }

            #[inline]
            pub fn messages(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat>>,
                    >>(QuickChatMessages::VT_MESSAGES, None)
                }
            }
        }

        impl flatbuffers::Verifiable for QuickChatMessages<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<QuickChat>>,
                    >>("messages", Self::VT_MESSAGES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct QuickChatMessagesArgs<'a> {
            pub messages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QuickChat<'a>>>,
                >,
            >,
        }
        impl<'a> Default for QuickChatMessagesArgs<'a> {
            #[inline]
            fn default() -> Self {
                QuickChatMessagesArgs { messages: None }
            }
        }

        pub struct QuickChatMessagesBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> QuickChatMessagesBuilder<'a, 'b> {
            #[inline]
            pub fn add_messages(
                &mut self,
                messages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<QuickChat<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    QuickChatMessages::VT_MESSAGES,
                    messages,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> QuickChatMessagesBuilder<'a, 'b> {
                let start = _fbb.start_table();
                QuickChatMessagesBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<QuickChatMessages<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for QuickChatMessages<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("QuickChatMessages");
                ds.field("messages", &self.messages());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct QuickChatMessagesObject {
            pub messages: Option<Vec<QuickChatObject>>,
        }
        impl Default for QuickChatMessagesObject {
            fn default() -> Self {
                Self { messages: None }
            }
        }
        impl QuickChatMessagesObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<QuickChatMessages<'b>> {
                let messages = self.messages.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                QuickChatMessages::create(_fbb, &QuickChatMessagesArgs { messages })
            }
        }
        pub enum ReadyMessageOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Sent when connecting to RLBot to indicate what type of messages are desired.
        /// This could be sent by a bot, or a bot manager governing several bots, an
        /// overlay, or any other utility that connects to the RLBot process.
        pub struct ReadyMessage<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for ReadyMessage<'a> {
            type Inner = ReadyMessage<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> ReadyMessage<'a> {
            pub const VT_WANTSBALLPREDICTIONS: flatbuffers::VOffsetT = 4;
            pub const VT_WANTSQUICKCHAT: flatbuffers::VOffsetT = 6;
            pub const VT_WANTSGAMEMESSAGES: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                ReadyMessage { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args ReadyMessageArgs,
            ) -> flatbuffers::WIPOffset<ReadyMessage<'bldr>> {
                let mut builder = ReadyMessageBuilder::new(_fbb);
                builder.add_wantsGameMessages(args.wantsGameMessages);
                builder.add_wantsQuickChat(args.wantsQuickChat);
                builder.add_wantsBallPredictions(args.wantsBallPredictions);
                builder.finish()
            }

            pub fn unpack(&self) -> ReadyMessageObject {
                let wantsBallPredictions = self.wantsBallPredictions();
                let wantsQuickChat = self.wantsQuickChat();
                let wantsGameMessages = self.wantsGameMessages();
                ReadyMessageObject {
                    wantsBallPredictions,
                    wantsQuickChat,
                    wantsGameMessages,
                }
            }

            #[inline]
            pub fn wantsBallPredictions(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ReadyMessage::VT_WANTSBALLPREDICTIONS, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn wantsQuickChat(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ReadyMessage::VT_WANTSQUICKCHAT, Some(false))
                        .unwrap()
                }
            }
            #[inline]
            pub fn wantsGameMessages(&self) -> bool {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<bool>(ReadyMessage::VT_WANTSGAMEMESSAGES, Some(false))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for ReadyMessage<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<bool>(
                        "wantsBallPredictions",
                        Self::VT_WANTSBALLPREDICTIONS,
                        false,
                    )?
                    .visit_field::<bool>("wantsQuickChat", Self::VT_WANTSQUICKCHAT, false)?
                    .visit_field::<bool>("wantsGameMessages", Self::VT_WANTSGAMEMESSAGES, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct ReadyMessageArgs {
            pub wantsBallPredictions: bool,
            pub wantsQuickChat: bool,
            pub wantsGameMessages: bool,
        }
        impl<'a> Default for ReadyMessageArgs {
            #[inline]
            fn default() -> Self {
                ReadyMessageArgs {
                    wantsBallPredictions: false,
                    wantsQuickChat: false,
                    wantsGameMessages: false,
                }
            }
        }

        pub struct ReadyMessageBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> ReadyMessageBuilder<'a, 'b> {
            #[inline]
            pub fn add_wantsBallPredictions(&mut self, wantsBallPredictions: bool) {
                self.fbb_.push_slot::<bool>(
                    ReadyMessage::VT_WANTSBALLPREDICTIONS,
                    wantsBallPredictions,
                    false,
                );
            }
            #[inline]
            pub fn add_wantsQuickChat(&mut self, wantsQuickChat: bool) {
                self.fbb_
                    .push_slot::<bool>(ReadyMessage::VT_WANTSQUICKCHAT, wantsQuickChat, false);
            }
            #[inline]
            pub fn add_wantsGameMessages(&mut self, wantsGameMessages: bool) {
                self.fbb_.push_slot::<bool>(
                    ReadyMessage::VT_WANTSGAMEMESSAGES,
                    wantsGameMessages,
                    false,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> ReadyMessageBuilder<'a, 'b> {
                let start = _fbb.start_table();
                ReadyMessageBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<ReadyMessage<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for ReadyMessage<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("ReadyMessage");
                ds.field("wantsBallPredictions", &self.wantsBallPredictions());
                ds.field("wantsQuickChat", &self.wantsQuickChat());
                ds.field("wantsGameMessages", &self.wantsGameMessages());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct ReadyMessageObject {
            pub wantsBallPredictions: bool,
            pub wantsQuickChat: bool,
            pub wantsGameMessages: bool,
        }
        impl Default for ReadyMessageObject {
            fn default() -> Self {
                Self {
                    wantsBallPredictions: false,
                    wantsQuickChat: false,
                    wantsGameMessages: false,
                }
            }
        }
        impl ReadyMessageObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<ReadyMessage<'b>> {
                let wantsBallPredictions = self.wantsBallPredictions;
                let wantsQuickChat = self.wantsQuickChat;
                let wantsGameMessages = self.wantsGameMessages;
                ReadyMessage::create(
                    _fbb,
                    &ReadyMessageArgs {
                        wantsBallPredictions,
                        wantsQuickChat,
                        wantsGameMessages,
                    },
                )
            }
        }
        pub enum PlayerStatEventOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Notification that a player triggers some in-game event, such as:
        ///		Win, Loss, TimePlayed;
        ///		Shot, Assist, Center, Clear, PoolShot;
        ///		Goal, AerialGoal, BicycleGoal, BulletGoal, BackwardsGoal, LongGoal, OvertimeGoal, TurtleGoal;
        ///		AerialHit, BicycleHit, BulletHit, JuggleHit, FirstTouch, BallHit;
        ///		Save, EpicSave, FreezeSave;
        ///		HatTrick, Savior, Playmaker, MVP;
        ///		FastestGoal, SlowestGoal, FurthestGoal, OwnGoal;
        ///		MostBallTouches, FewestBallTouches, MostBoostPickups, FewestBoostPickups, BoostPickups;
        ///		CarTouches, Demolition, Demolish;
        ///		LowFive, HighFive;
        pub struct PlayerStatEvent<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerStatEvent<'a> {
            type Inner = PlayerStatEvent<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerStatEvent<'a> {
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_STATTYPE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerStatEvent { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerStatEventArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerStatEvent<'bldr>> {
                let mut builder = PlayerStatEventBuilder::new(_fbb);
                if let Some(x) = args.statType {
                    builder.add_statType(x);
                }
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerStatEventObject {
                let playerIndex = self.playerIndex();
                let statType = self.statType().map(|x| x.to_string());
                PlayerStatEventObject {
                    playerIndex,
                    statType,
                }
            }

            /// index of the player associated with the event
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerStatEvent::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
            /// Event type
            #[inline]
            pub fn statType(&self) -> Option<&'a str> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                        PlayerStatEvent::VT_STATTYPE,
                        None,
                    )
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerStatEvent<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                        "statType",
                        Self::VT_STATTYPE,
                        false,
                    )?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerStatEventArgs<'a> {
            pub playerIndex: i32,
            pub statType: Option<flatbuffers::WIPOffset<&'a str>>,
        }
        impl<'a> Default for PlayerStatEventArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerStatEventArgs {
                    playerIndex: 0,
                    statType: None,
                }
            }
        }

        pub struct PlayerStatEventBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerStatEventBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerStatEvent::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_statType(&mut self, statType: flatbuffers::WIPOffset<&'b str>) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    PlayerStatEvent::VT_STATTYPE,
                    statType,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerStatEventBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerStatEventBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerStatEvent<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerStatEvent<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerStatEvent");
                ds.field("playerIndex", &self.playerIndex());
                ds.field("statType", &self.statType());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerStatEventObject {
            pub playerIndex: i32,
            pub statType: Option<String>,
        }
        impl Default for PlayerStatEventObject {
            fn default() -> Self {
                Self {
                    playerIndex: 0,
                    statType: None,
                }
            }
        }
        impl PlayerStatEventObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerStatEvent<'b>> {
                let playerIndex = self.playerIndex;
                let statType = self.statType.as_ref().map(|x| _fbb.create_string(x));
                PlayerStatEvent::create(
                    _fbb,
                    &PlayerStatEventArgs {
                        playerIndex,
                        statType,
                    },
                )
            }
        }
        pub enum PlayerSpectateOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Notification when the local player is spectating another player.
        pub struct PlayerSpectate<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerSpectate<'a> {
            type Inner = PlayerSpectate<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerSpectate<'a> {
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerSpectate { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerSpectateArgs,
            ) -> flatbuffers::WIPOffset<PlayerSpectate<'bldr>> {
                let mut builder = PlayerSpectateBuilder::new(_fbb);
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerSpectateObject {
                let playerIndex = self.playerIndex();
                PlayerSpectateObject { playerIndex }
            }

            /// index of the player that is being spectated. Will be -1 if not spectating anyone.
            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerSpectate::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerSpectate<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerSpectateArgs {
            pub playerIndex: i32,
        }
        impl<'a> Default for PlayerSpectateArgs {
            #[inline]
            fn default() -> Self {
                PlayerSpectateArgs { playerIndex: 0 }
            }
        }

        pub struct PlayerSpectateBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerSpectateBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerSpectate::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerSpectateBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerSpectateBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerSpectate<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerSpectate<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerSpectate");
                ds.field("playerIndex", &self.playerIndex());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerSpectateObject {
            pub playerIndex: i32,
        }
        impl Default for PlayerSpectateObject {
            fn default() -> Self {
                Self { playerIndex: 0 }
            }
        }
        impl PlayerSpectateObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerSpectate<'b>> {
                let playerIndex = self.playerIndex;
                PlayerSpectate::create(_fbb, &PlayerSpectateArgs { playerIndex })
            }
        }
        pub enum PlayerInputChangeOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// Rocket League is notifying us that some player has moved their controller. This is an *output*
        pub struct PlayerInputChange<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for PlayerInputChange<'a> {
            type Inner = PlayerInputChange<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> PlayerInputChange<'a> {
            pub const VT_PLAYERINDEX: flatbuffers::VOffsetT = 4;
            pub const VT_CONTROLLERSTATE: flatbuffers::VOffsetT = 6;
            pub const VT_DODGEFORWARD: flatbuffers::VOffsetT = 8;
            pub const VT_DODGERIGHT: flatbuffers::VOffsetT = 10;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                PlayerInputChange { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args PlayerInputChangeArgs<'args>,
            ) -> flatbuffers::WIPOffset<PlayerInputChange<'bldr>> {
                let mut builder = PlayerInputChangeBuilder::new(_fbb);
                builder.add_dodgeRight(args.dodgeRight);
                builder.add_dodgeForward(args.dodgeForward);
                if let Some(x) = args.controllerState {
                    builder.add_controllerState(x);
                }
                builder.add_playerIndex(args.playerIndex);
                builder.finish()
            }

            pub fn unpack(&self) -> PlayerInputChangeObject {
                let playerIndex = self.playerIndex();
                let controllerState = self.controllerState().map(|x| Box::new(x.unpack()));
                let dodgeForward = self.dodgeForward();
                let dodgeRight = self.dodgeRight();
                PlayerInputChangeObject {
                    playerIndex,
                    controllerState,
                    dodgeForward,
                    dodgeRight,
                }
            }

            #[inline]
            pub fn playerIndex(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(PlayerInputChange::VT_PLAYERINDEX, Some(0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn controllerState(&self) -> Option<ControllerState<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<ControllerState>>(
                            PlayerInputChange::VT_CONTROLLERSTATE,
                            None,
                        )
                }
            }
            #[inline]
            pub fn dodgeForward(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(PlayerInputChange::VT_DODGEFORWARD, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn dodgeRight(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(PlayerInputChange::VT_DODGERIGHT, Some(0.0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for PlayerInputChange<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<i32>("playerIndex", Self::VT_PLAYERINDEX, false)?
                    .visit_field::<flatbuffers::ForwardsUOffset<ControllerState>>(
                        "controllerState",
                        Self::VT_CONTROLLERSTATE,
                        false,
                    )?
                    .visit_field::<f32>("dodgeForward", Self::VT_DODGEFORWARD, false)?
                    .visit_field::<f32>("dodgeRight", Self::VT_DODGERIGHT, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct PlayerInputChangeArgs<'a> {
            pub playerIndex: i32,
            pub controllerState: Option<flatbuffers::WIPOffset<ControllerState<'a>>>,
            pub dodgeForward: f32,
            pub dodgeRight: f32,
        }
        impl<'a> Default for PlayerInputChangeArgs<'a> {
            #[inline]
            fn default() -> Self {
                PlayerInputChangeArgs {
                    playerIndex: 0,
                    controllerState: None,
                    dodgeForward: 0.0,
                    dodgeRight: 0.0,
                }
            }
        }

        pub struct PlayerInputChangeBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> PlayerInputChangeBuilder<'a, 'b> {
            #[inline]
            pub fn add_playerIndex(&mut self, playerIndex: i32) {
                self.fbb_
                    .push_slot::<i32>(PlayerInputChange::VT_PLAYERINDEX, playerIndex, 0);
            }
            #[inline]
            pub fn add_controllerState(
                &mut self,
                controllerState: flatbuffers::WIPOffset<ControllerState<'b>>,
            ) {
                self.fbb_
                    .push_slot_always::<flatbuffers::WIPOffset<ControllerState>>(
                        PlayerInputChange::VT_CONTROLLERSTATE,
                        controllerState,
                    );
            }
            #[inline]
            pub fn add_dodgeForward(&mut self, dodgeForward: f32) {
                self.fbb_
                    .push_slot::<f32>(PlayerInputChange::VT_DODGEFORWARD, dodgeForward, 0.0);
            }
            #[inline]
            pub fn add_dodgeRight(&mut self, dodgeRight: f32) {
                self.fbb_
                    .push_slot::<f32>(PlayerInputChange::VT_DODGERIGHT, dodgeRight, 0.0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> PlayerInputChangeBuilder<'a, 'b> {
                let start = _fbb.start_table();
                PlayerInputChangeBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<PlayerInputChange<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for PlayerInputChange<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("PlayerInputChange");
                ds.field("playerIndex", &self.playerIndex());
                ds.field("controllerState", &self.controllerState());
                ds.field("dodgeForward", &self.dodgeForward());
                ds.field("dodgeRight", &self.dodgeRight());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct PlayerInputChangeObject {
            pub playerIndex: i32,
            pub controllerState: Option<Box<ControllerStateObject>>,
            pub dodgeForward: f32,
            pub dodgeRight: f32,
        }
        impl Default for PlayerInputChangeObject {
            fn default() -> Self {
                Self {
                    playerIndex: 0,
                    controllerState: None,
                    dodgeForward: 0.0,
                    dodgeRight: 0.0,
                }
            }
        }
        impl PlayerInputChangeObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<PlayerInputChange<'b>> {
                let playerIndex = self.playerIndex;
                let controllerState = self.controllerState.as_ref().map(|x| x.pack(_fbb));
                let dodgeForward = self.dodgeForward;
                let dodgeRight = self.dodgeRight;
                PlayerInputChange::create(
                    _fbb,
                    &PlayerInputChangeArgs {
                        playerIndex,
                        controllerState,
                        dodgeForward,
                        dodgeRight,
                    },
                )
            }
        }
        pub enum GameMessageWrapperOffset {}
        #[derive(Copy, Clone, PartialEq)]

        pub struct GameMessageWrapper<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for GameMessageWrapper<'a> {
            type Inner = GameMessageWrapper<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> GameMessageWrapper<'a> {
            pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
            pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                GameMessageWrapper { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args GameMessageWrapperArgs,
            ) -> flatbuffers::WIPOffset<GameMessageWrapper<'bldr>> {
                let mut builder = GameMessageWrapperBuilder::new(_fbb);
                if let Some(x) = args.Message {
                    builder.add_Message(x);
                }
                builder.add_Message_type(args.Message_type);
                builder.finish()
            }

            pub fn unpack(&self) -> GameMessageWrapperObject {
                let Message = match self.Message_type() {
      GameMessage::NONE => GameMessageObject::NONE,
      GameMessage::PlayerStatEvent => GameMessageObject::PlayerStatEvent(Box::new(
        self.Message_as_player_stat_event()
            .expect("Invalid union table, expected `GameMessage::PlayerStatEvent`.")
            .unpack()
      )),
      GameMessage::PlayerSpectate => GameMessageObject::PlayerSpectate(Box::new(
        self.Message_as_player_spectate()
            .expect("Invalid union table, expected `GameMessage::PlayerSpectate`.")
            .unpack()
      )),
      GameMessage::PlayerInputChange => GameMessageObject::PlayerInputChange(Box::new(
        self.Message_as_player_input_change()
            .expect("Invalid union table, expected `GameMessage::PlayerInputChange`.")
            .unpack()
      )),
      _ => GameMessageObject::NONE,
    };
                GameMessageWrapperObject { Message }
            }

            #[inline]
            pub fn Message_type(&self) -> GameMessage {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<GameMessage>(
                            GameMessageWrapper::VT_MESSAGE_TYPE,
                            Some(GameMessage::NONE),
                        )
                        .unwrap()
                }
            }
            #[inline]
            pub fn Message(&self) -> Option<flatbuffers::Table<'a>> {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                            GameMessageWrapper::VT_MESSAGE,
                            None,
                        )
                }
            }
            #[inline]
            #[allow(non_snake_case)]
            pub fn Message_as_player_stat_event(&self) -> Option<PlayerStatEvent<'a>> {
                if self.Message_type() == GameMessage::PlayerStatEvent {
                    self.Message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PlayerStatEvent::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn Message_as_player_spectate(&self) -> Option<PlayerSpectate<'a>> {
                if self.Message_type() == GameMessage::PlayerSpectate {
                    self.Message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PlayerSpectate::init_from_table(t) }
                    })
                } else {
                    None
                }
            }

            #[inline]
            #[allow(non_snake_case)]
            pub fn Message_as_player_input_change(&self) -> Option<PlayerInputChange<'a>> {
                if self.Message_type() == GameMessage::PlayerInputChange {
                    self.Message().map(|t| {
                        // Safety:
                        // Created from a valid Table for this object
                        // Which contains a valid union in this slot
                        unsafe { PlayerInputChange::init_from_table(t) }
                    })
                } else {
                    None
                }
            }
        }

        impl flatbuffers::Verifiable for GameMessageWrapper<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
     .visit_union::<GameMessage, _>("Message_type", Self::VT_MESSAGE_TYPE, "Message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          GameMessage::PlayerStatEvent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerStatEvent>>("GameMessage::PlayerStatEvent", pos),
          GameMessage::PlayerSpectate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerSpectate>>("GameMessage::PlayerSpectate", pos),
          GameMessage::PlayerInputChange => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PlayerInputChange>>("GameMessage::PlayerInputChange", pos),
          _ => Ok(()),
        }
     })?
     .finish();
                Ok(())
            }
        }
        pub struct GameMessageWrapperArgs {
            pub Message_type: GameMessage,
            pub Message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
        }
        impl<'a> Default for GameMessageWrapperArgs {
            #[inline]
            fn default() -> Self {
                GameMessageWrapperArgs {
                    Message_type: GameMessage::NONE,
                    Message: None,
                }
            }
        }

        pub struct GameMessageWrapperBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> GameMessageWrapperBuilder<'a, 'b> {
            #[inline]
            pub fn add_Message_type(&mut self, Message_type: GameMessage) {
                self.fbb_.push_slot::<GameMessage>(
                    GameMessageWrapper::VT_MESSAGE_TYPE,
                    Message_type,
                    GameMessage::NONE,
                );
            }
            #[inline]
            pub fn add_Message(
                &mut self,
                Message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    GameMessageWrapper::VT_MESSAGE,
                    Message,
                );
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> GameMessageWrapperBuilder<'a, 'b> {
                let start = _fbb.start_table();
                GameMessageWrapperBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<GameMessageWrapper<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for GameMessageWrapper<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("GameMessageWrapper");
                ds.field("Message_type", &self.Message_type());
                match self.Message_type() {
                    GameMessage::PlayerStatEvent => {
                        if let Some(x) = self.Message_as_player_stat_event() {
                            ds.field("Message", &x)
                        } else {
                            ds.field(
                                "Message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    GameMessage::PlayerSpectate => {
                        if let Some(x) = self.Message_as_player_spectate() {
                            ds.field("Message", &x)
                        } else {
                            ds.field(
                                "Message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    GameMessage::PlayerInputChange => {
                        if let Some(x) = self.Message_as_player_input_change() {
                            ds.field("Message", &x)
                        } else {
                            ds.field(
                                "Message",
                                &"InvalidFlatbuffer: Union discriminant does not match value.",
                            )
                        }
                    }
                    _ => {
                        let x: Option<()> = None;
                        ds.field("Message", &x)
                    }
                };
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct GameMessageWrapperObject {
            pub Message: GameMessageObject,
        }
        impl Default for GameMessageWrapperObject {
            fn default() -> Self {
                Self {
                    Message: GameMessageObject::NONE,
                }
            }
        }
        impl GameMessageWrapperObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<GameMessageWrapper<'b>> {
                let Message_type = self.Message.game_message_type();
                let Message = self.Message.pack(_fbb);
                GameMessageWrapper::create(
                    _fbb,
                    &GameMessageWrapperArgs {
                        Message_type,
                        Message,
                    },
                )
            }
        }
        pub enum MessagePacketOffset {}
        #[derive(Copy, Clone, PartialEq)]

        /// We have some very small messages that are only a few bytes but potentially sent at high frequency.
        /// Bundle them into a packet to reduce the overhead of sending data over TCP.
        pub struct MessagePacket<'a> {
            pub _tab: flatbuffers::Table<'a>,
        }

        impl<'a> flatbuffers::Follow<'a> for MessagePacket<'a> {
            type Inner = MessagePacket<'a>;
            #[inline]
            unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                Self {
                    _tab: flatbuffers::Table::new(buf, loc),
                }
            }
        }

        impl<'a> MessagePacket<'a> {
            pub const VT_MESSAGES: flatbuffers::VOffsetT = 4;
            pub const VT_GAMESECONDS: flatbuffers::VOffsetT = 6;
            pub const VT_FRAMENUM: flatbuffers::VOffsetT = 8;

            #[inline]
            pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                MessagePacket { _tab: table }
            }
            #[allow(unused_mut)]
            pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
                _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
                args: &'args MessagePacketArgs<'args>,
            ) -> flatbuffers::WIPOffset<MessagePacket<'bldr>> {
                let mut builder = MessagePacketBuilder::new(_fbb);
                builder.add_frameNum(args.frameNum);
                builder.add_gameSeconds(args.gameSeconds);
                if let Some(x) = args.messages {
                    builder.add_messages(x);
                }
                builder.finish()
            }

            pub fn unpack(&self) -> MessagePacketObject {
                let messages = self
                    .messages()
                    .map(|x| x.iter().map(|t| t.unpack()).collect());
                let gameSeconds = self.gameSeconds();
                let frameNum = self.frameNum();
                MessagePacketObject {
                    messages,
                    gameSeconds,
                    frameNum,
                }
            }

            #[inline]
            pub fn messages(
                &self,
            ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper<'a>>>>
            {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab.get::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper>>,
                    >>(MessagePacket::VT_MESSAGES, None)
                }
            }
            #[inline]
            pub fn gameSeconds(&self) -> f32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<f32>(MessagePacket::VT_GAMESECONDS, Some(0.0))
                        .unwrap()
                }
            }
            #[inline]
            pub fn frameNum(&self) -> i32 {
                // Safety:
                // Created from valid Table for this object
                // which contains a valid value in this slot
                unsafe {
                    self._tab
                        .get::<i32>(MessagePacket::VT_FRAMENUM, Some(0))
                        .unwrap()
                }
            }
        }

        impl flatbuffers::Verifiable for MessagePacket<'_> {
            #[inline]
            fn run_verifier(
                v: &mut flatbuffers::Verifier,
                pos: usize,
            ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                use self::flatbuffers::Verifiable;
                v.visit_table(pos)?
                    .visit_field::<flatbuffers::ForwardsUOffset<
                        flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<GameMessageWrapper>>,
                    >>("messages", Self::VT_MESSAGES, false)?
                    .visit_field::<f32>("gameSeconds", Self::VT_GAMESECONDS, false)?
                    .visit_field::<i32>("frameNum", Self::VT_FRAMENUM, false)?
                    .finish();
                Ok(())
            }
        }
        pub struct MessagePacketArgs<'a> {
            pub messages: Option<
                flatbuffers::WIPOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<GameMessageWrapper<'a>>>,
                >,
            >,
            pub gameSeconds: f32,
            pub frameNum: i32,
        }
        impl<'a> Default for MessagePacketArgs<'a> {
            #[inline]
            fn default() -> Self {
                MessagePacketArgs {
                    messages: None,
                    gameSeconds: 0.0,
                    frameNum: 0,
                }
            }
        }

        pub struct MessagePacketBuilder<'a: 'b, 'b> {
            fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
        }
        impl<'a: 'b, 'b> MessagePacketBuilder<'a, 'b> {
            #[inline]
            pub fn add_messages(
                &mut self,
                messages: flatbuffers::WIPOffset<
                    flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<GameMessageWrapper<'b>>>,
                >,
            ) {
                self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                    MessagePacket::VT_MESSAGES,
                    messages,
                );
            }
            #[inline]
            pub fn add_gameSeconds(&mut self, gameSeconds: f32) {
                self.fbb_
                    .push_slot::<f32>(MessagePacket::VT_GAMESECONDS, gameSeconds, 0.0);
            }
            #[inline]
            pub fn add_frameNum(&mut self, frameNum: i32) {
                self.fbb_
                    .push_slot::<i32>(MessagePacket::VT_FRAMENUM, frameNum, 0);
            }
            #[inline]
            pub fn new(
                _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> MessagePacketBuilder<'a, 'b> {
                let start = _fbb.start_table();
                MessagePacketBuilder {
                    fbb_: _fbb,
                    start_: start,
                }
            }
            #[inline]
            pub fn finish(self) -> flatbuffers::WIPOffset<MessagePacket<'a>> {
                let o = self.fbb_.end_table(self.start_);
                flatbuffers::WIPOffset::new(o.value())
            }
        }

        impl core::fmt::Debug for MessagePacket<'_> {
            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                let mut ds = f.debug_struct("MessagePacket");
                ds.field("messages", &self.messages());
                ds.field("gameSeconds", &self.gameSeconds());
                ds.field("frameNum", &self.frameNum());
                ds.finish()
            }
        }

        #[derive(Debug, Clone, PartialEq)]
        pub struct MessagePacketObject {
            pub messages: Option<Vec<GameMessageWrapperObject>>,
            pub gameSeconds: f32,
            pub frameNum: i32,
        }
        impl Default for MessagePacketObject {
            fn default() -> Self {
                Self {
                    messages: None,
                    gameSeconds: 0.0,
                    frameNum: 0,
                }
            }
        }
        impl MessagePacketObject {
            pub fn pack<'b>(
                &self,
                _fbb: &mut flatbuffers::FlatBufferBuilder<'b>,
            ) -> flatbuffers::WIPOffset<MessagePacket<'b>> {
                let messages = self.messages.as_ref().map(|x| {
                    let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                    _fbb.create_vector(&w)
                });
                let gameSeconds = self.gameSeconds;
                let frameNum = self.frameNum;
                MessagePacket::create(
                    _fbb,
                    &MessagePacketArgs {
                        messages,
                        gameSeconds,
                        frameNum,
                    },
                )
            }
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a `QuickChat`
        /// and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_quick_chat_unchecked`.
        pub fn root_as_quick_chat(buf: &[u8]) -> Result<QuickChat, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root::<QuickChat>(buf)
        }
        #[inline]
        /// Verifies that a buffer of bytes contains a size prefixed
        /// `QuickChat` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `size_prefixed_root_as_quick_chat_unchecked`.
        pub fn size_prefixed_root_as_quick_chat(
            buf: &[u8],
        ) -> Result<QuickChat, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root::<QuickChat>(buf)
        }
        #[inline]
        /// Verifies, with the given options, that a buffer of bytes
        /// contains a `QuickChat` and returns it.
        /// Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_quick_chat_unchecked`.
        pub fn root_as_quick_chat_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<QuickChat<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::root_with_opts::<QuickChat<'b>>(opts, buf)
        }
        #[inline]
        /// Verifies, with the given verifier options, that a buffer of
        /// bytes contains a size prefixed `QuickChat` and returns
        /// it. Note that verification is still experimental and may not
        /// catch every error, or be maximally performant. For the
        /// previous, unchecked, behavior use
        /// `root_as_quick_chat_unchecked`.
        pub fn size_prefixed_root_as_quick_chat_with_opts<'b, 'o>(
            opts: &'o flatbuffers::VerifierOptions,
            buf: &'b [u8],
        ) -> Result<QuickChat<'b>, flatbuffers::InvalidFlatbuffer> {
            flatbuffers::size_prefixed_root_with_opts::<QuickChat<'b>>(opts, buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a QuickChat and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid `QuickChat`.
        pub unsafe fn root_as_quick_chat_unchecked(buf: &[u8]) -> QuickChat {
            flatbuffers::root_unchecked::<QuickChat>(buf)
        }
        #[inline]
        /// Assumes, without verification, that a buffer of bytes contains a size prefixed QuickChat and returns it.
        /// # Safety
        /// Callers must trust the given bytes do indeed contain a valid size prefixed `QuickChat`.
        pub unsafe fn size_prefixed_root_as_quick_chat_unchecked(buf: &[u8]) -> QuickChat {
            flatbuffers::size_prefixed_root_unchecked::<QuickChat>(buf)
        }
        #[inline]
        pub fn finish_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish(root, None);
        }

        #[inline]
        pub fn finish_size_prefixed_quick_chat_buffer<'a, 'b>(
            fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
            root: flatbuffers::WIPOffset<QuickChat<'a>>,
        ) {
            fbb.finish_size_prefixed(root, None);
        }
    } // pub mod flat
} // pub mod rlbot
